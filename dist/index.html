<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: transparent;
      color: #fcbe24;
      padding: 0 24px;
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Open Sans, Helvetica Neue, sans-serif
    }
  </style>
  <script>global = window; var __bfs__ = function () { "use strict"; function t (t, r) { return r.forEach((function (r) { r && "string" != typeof r && !Array.isArray(r) && Object.keys(r).forEach((function (e) { if ("default" !== e && !(e in t)) { var n = Object.getOwnPropertyDescriptor(r, e); Object.defineProperty(t, e, n.get ? n : { enumerable: !0, get: function () { return r[e] } }) } })) })), Object.freeze(t) } var r = [], e = [], n = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = !1; function i () { o = !0; for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0, i = t.length; n < i; ++n)r[n] = t[n], e[t.charCodeAt(n)] = n; e["-".charCodeAt(0)] = 62, e["_".charCodeAt(0)] = 63 } function s (t, e, n) { for (var o, i, s = [], u = e; u < n; u += 3)o = (t[u] << 16) + (t[u + 1] << 8) + t[u + 2], s.push(r[(i = o) >> 18 & 63] + r[i >> 12 & 63] + r[i >> 6 & 63] + r[63 & i]); return s.join("") } function u (t) { var e; o || i(); for (var n = t.length, u = n % 3, a = "", f = [], c = 0, p = n - u; c < p; c += 16383)f.push(s(t, c, c + 16383 > p ? p : c + 16383)); return 1 === u ? (e = t[n - 1], a += r[e >> 2], a += r[e << 4 & 63], a += "==") : 2 === u && (e = (t[n - 2] << 8) + t[n - 1], a += r[e >> 10], a += r[e >> 4 & 63], a += r[e << 2 & 63], a += "="), f.push(a), f.join("") } function a (t, r, e, n, o) { var i, s, u = 8 * o - n - 1, a = (1 << u) - 1, f = a >> 1, c = -7, p = e ? o - 1 : 0, h = e ? -1 : 1, l = t[r + p]; for (p += h, i = l & (1 << -c) - 1, l >>= -c, c += u; c > 0; i = 256 * i + t[r + p], p += h, c -= 8); for (s = i & (1 << -c) - 1, i >>= -c, c += n; c > 0; s = 256 * s + t[r + p], p += h, c -= 8); if (0 === i) i = 1 - f; else { if (i === a) return s ? NaN : 1 / 0 * (l ? -1 : 1); s += Math.pow(2, n), i -= f } return (l ? -1 : 1) * s * Math.pow(2, i - n) } function f (t, r, e, n, o, i) { var s, u, a, f = 8 * i - o - 1, c = (1 << f) - 1, p = c >> 1, h = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l = n ? 0 : i - 1, y = n ? 1 : -1, d = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0; for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, s = c) : (s = Math.floor(Math.log(r) / Math.LN2), r * (a = Math.pow(2, -s)) < 1 && (s--, a *= 2), (r += s + p >= 1 ? h / a : h * Math.pow(2, 1 - p)) * a >= 2 && (s++, a /= 2), s + p >= c ? (u = 0, s = c) : s + p >= 1 ? (u = (r * a - 1) * Math.pow(2, o), s += p) : (u = r * Math.pow(2, p - 1) * Math.pow(2, o), s = 0)); o >= 8; t[e + l] = 255 & u, l += y, u /= 256, o -= 8); for (s = s << o | u, f += o; f > 0; t[e + l] = 255 & s, l += y, s /= 256, f -= 8); t[e + l - y] |= 128 * d } var c = {}.toString, p = Array.isArray || function (t) { return "[object Array]" == c.call(t) }; d.TYPED_ARRAY_SUPPORT = void 0 === global.TYPED_ARRAY_SUPPORT || global.TYPED_ARRAY_SUPPORT; var h = l(); function l () { return d.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function y (t, r) { if (l() < r) throw new RangeError("Invalid typed array length"); return d.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = d.prototype : (null === t && (t = new d(r)), t.length = r), t } function d (t, r, e) { if (!(d.TYPED_ARRAY_SUPPORT || this instanceof d)) return new d(t, r, e); if ("number" == typeof t) { if ("string" == typeof r) throw new Error("If encoding is specified then the first argument must be a string"); return m(this, t) } return E(this, t, r, e) } function E (t, r, e, n) { if ("number" == typeof r) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? function (t, r, e, n) { if (r.byteLength, e < 0 || r.byteLength < e) throw new RangeError("'offset' is out of bounds"); if (r.byteLength < e + (n || 0)) throw new RangeError("'length' is out of bounds"); r = void 0 === e && void 0 === n ? new Uint8Array(r) : void 0 === n ? new Uint8Array(r, e) : new Uint8Array(r, e, n); d.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = d.prototype : t = w(t, r); return t }(t, r, e, n) : "string" == typeof r ? function (t, r, e) { "string" == typeof e && "" !== e || (e = "utf8"); if (!d.isEncoding(e)) throw new TypeError('"encoding" must be a valid string encoding'); var n = 0 | b(r, e), o = (t = y(t, n)).write(r, e); o !== n && (t = t.slice(0, o)); return t }(t, r, e) : function (t, r) { if (S(r)) { var e = 0 | v(r.length); return 0 === (t = y(t, e)).length || r.copy(t, 0, 0, e), t } if (r) { if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length" in r) return "number" != typeof r.length || (n = r.length) != n ? y(t, 0) : w(t, r); if ("Buffer" === r.type && p(r.data)) return w(t, r.data) } var n; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(t, r) } function g (t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function m (t, r) { if (g(r), t = y(t, r < 0 ? 0 : 0 | v(r)), !d.TYPED_ARRAY_SUPPORT) for (var e = 0; e < r; ++e)t[e] = 0; return t } function w (t, r) { var e = r.length < 0 ? 0 : 0 | v(r.length); t = y(t, e); for (var n = 0; n < e; n += 1)t[n] = 255 & r[n]; return t } function v (t) { if (t >= l()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + l().toString(16) + " bytes"); return 0 | t } function S (t) { return !(null == t || !t._isBuffer) } function b (t, r) { if (S(t)) return t.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength; "string" != typeof t && (t = "" + t); var e = t.length; if (0 === e) return 0; for (var n = !1; ;)switch (r) { case "ascii": case "latin1": case "binary": return e; case "utf8": case "utf-8": case void 0: return H(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * e; case "hex": return e >>> 1; case "base64": return q(t).length; default: if (n) return H(t).length; r = ("" + r).toLowerCase(), n = !0 } } function A (t, r, e) { var n = !1; if ((void 0 === r || r < 0) && (r = 0), r > this.length) return ""; if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return ""; if ((e >>>= 0) <= (r >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return U(this, r, e); case "utf8": case "utf-8": return D(this, r, e); case "ascii": return B(this, r, e); case "latin1": case "binary": return k(this, r, e); case "base64": return L(this, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return x(this, r, e); default: if (n) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), n = !0 } } function T (t, r, e) { var n = t[r]; t[r] = t[e], t[e] = n } function _ (t, r, e, n, o) { if (0 === t.length) return -1; if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = o ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) { if (o) return -1; e = t.length - 1 } else if (e < 0) { if (!o) return -1; e = 0 } if ("string" == typeof r && (r = d.from(r, n)), S(r)) return 0 === r.length ? -1 : O(t, r, e, n, o); if ("number" == typeof r) return r &= 255, d.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : O(t, [r], e, n, o); throw new TypeError("val must be string, number or Buffer") } function O (t, r, e, n, o) { var i, s = 1, u = t.length, a = r.length; if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) { if (t.length < 2 || r.length < 2) return -1; s = 2, u /= 2, a /= 2, e /= 2 } function f (t, r) { return 1 === s ? t[r] : t.readUInt16BE(r * s) } if (o) { var c = -1; for (i = e; i < u; i++)if (f(t, i) === f(r, -1 === c ? 0 : i - c)) { if (-1 === c && (c = i), i - c + 1 === a) return c * s } else -1 !== c && (i -= i - c), c = -1 } else for (e + a > u && (e = u - a), i = e; i >= 0; i--) { for (var p = !0, h = 0; h < a; h++)if (f(t, i + h) !== f(r, h)) { p = !1; break } if (p) return i } return -1 } function F (t, r, e, n) { e = Number(e) || 0; var o = t.length - e; n ? (n = Number(n)) > o && (n = o) : n = o; var i = r.length; if (i % 2 != 0) throw new TypeError("Invalid hex string"); n > i / 2 && (n = i / 2); for (var s = 0; s < n; ++s) { var u = parseInt(r.substr(2 * s, 2), 16); if (isNaN(u)) return s; t[e + s] = u } return s } function N (t, r, e, n) { return G(H(r, t.length - e), t, e, n) } function I (t, r, e, n) { return G(function (t) { for (var r = [], e = 0; e < t.length; ++e)r.push(255 & t.charCodeAt(e)); return r }(r), t, e, n) } function P (t, r, e, n) { return I(t, r, e, n) } function C (t, r, e, n) { return G(q(r), t, e, n) } function R (t, r, e, n) { return G(function (t, r) { for (var e, n, o, i = [], s = 0; s < t.length && !((r -= 2) < 0); ++s)e = t.charCodeAt(s), n = e >> 8, o = e % 256, i.push(o), i.push(n); return i }(r, t.length - e), t, e, n) } function L (t, r, e) { return 0 === r && e === t.length ? u(t) : u(t.slice(r, e)) } function D (t, r, e) { e = Math.min(t.length, e); for (var n = [], o = r; o < e;) { var i, s, u, a, f = t[o], c = null, p = f > 239 ? 4 : f > 223 ? 3 : f > 191 ? 2 : 1; if (o + p <= e) switch (p) { case 1: f < 128 && (c = f); break; case 2: 128 == (192 & (i = t[o + 1])) && (a = (31 & f) << 6 | 63 & i) > 127 && (c = a); break; case 3: i = t[o + 1], s = t[o + 2], 128 == (192 & i) && 128 == (192 & s) && (a = (15 & f) << 12 | (63 & i) << 6 | 63 & s) > 2047 && (a < 55296 || a > 57343) && (c = a); break; case 4: i = t[o + 1], s = t[o + 2], u = t[o + 3], 128 == (192 & i) && 128 == (192 & s) && 128 == (192 & u) && (a = (15 & f) << 18 | (63 & i) << 12 | (63 & s) << 6 | 63 & u) > 65535 && a < 1114112 && (c = a) }null === c ? (c = 65533, p = 1) : c > 65535 && (c -= 65536, n.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), n.push(c), o += p } return function (t) { var r = t.length; if (r <= 4096) return String.fromCharCode.apply(String, t); var e = "", n = 0; for (; n < r;)e += String.fromCharCode.apply(String, t.slice(n, n += 4096)); return e }(n) } d.poolSize = 8192, d._augment = function (t) { return t.__proto__ = d.prototype, t }, d.from = function (t, r, e) { return E(null, t, r, e) }, d.TYPED_ARRAY_SUPPORT && (d.prototype.__proto__ = Uint8Array.prototype, d.__proto__ = Uint8Array), d.alloc = function (t, r, e) { return function (t, r, e, n) { return g(r), r <= 0 ? y(t, r) : void 0 !== e ? "string" == typeof n ? y(t, r).fill(e, n) : y(t, r).fill(e) : y(t, r) }(null, t, r, e) }, d.allocUnsafe = function (t) { return m(null, t) }, d.allocUnsafeSlow = function (t) { return m(null, t) }, d.isBuffer = $, d.compare = function (t, r) { if (!S(t) || !S(r)) throw new TypeError("Arguments must be Buffers"); if (t === r) return 0; for (var e = t.length, n = r.length, o = 0, i = Math.min(e, n); o < i; ++o)if (t[o] !== r[o]) { e = t[o], n = r[o]; break } return e < n ? -1 : n < e ? 1 : 0 }, d.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, d.concat = function (t, r) { if (!p(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return d.alloc(0); var e; if (void 0 === r) for (r = 0, e = 0; e < t.length; ++e)r += t[e].length; var n = d.allocUnsafe(r), o = 0; for (e = 0; e < t.length; ++e) { var i = t[e]; if (!S(i)) throw new TypeError('"list" argument must be an Array of Buffers'); i.copy(n, o), o += i.length } return n }, d.byteLength = b, d.prototype._isBuffer = !0, d.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var r = 0; r < t; r += 2)T(this, r, r + 1); return this }, d.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var r = 0; r < t; r += 4)T(this, r, r + 3), T(this, r + 1, r + 2); return this }, d.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var r = 0; r < t; r += 8)T(this, r, r + 7), T(this, r + 1, r + 6), T(this, r + 2, r + 5), T(this, r + 3, r + 4); return this }, d.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? D(this, 0, t) : A.apply(this, arguments) }, d.prototype.equals = function (t) { if (!S(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === d.compare(this, t) }, d.prototype.inspect = function () { var t = ""; return this.length > 0 && (t = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t += " ... ")), "<Buffer " + t + ">" }, d.prototype.compare = function (t, r, e, n, o) { if (!S(t)) throw new TypeError("Argument must be a Buffer"); if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === o && (o = this.length), r < 0 || e > t.length || n < 0 || o > this.length) throw new RangeError("out of range index"); if (n >= o && r >= e) return 0; if (n >= o) return -1; if (r >= e) return 1; if (this === t) return 0; for (var i = (o >>>= 0) - (n >>>= 0), s = (e >>>= 0) - (r >>>= 0), u = Math.min(i, s), a = this.slice(n, o), f = t.slice(r, e), c = 0; c < u; ++c)if (a[c] !== f[c]) { i = a[c], s = f[c]; break } return i < s ? -1 : s < i ? 1 : 0 }, d.prototype.includes = function (t, r, e) { return -1 !== this.indexOf(t, r, e) }, d.prototype.indexOf = function (t, r, e) { return _(this, t, r, e, !0) }, d.prototype.lastIndexOf = function (t, r, e) { return _(this, t, r, e, !1) }, d.prototype.write = function (t, r, e, n) { if (void 0 === r) n = "utf8", e = this.length, r = 0; else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0; else { if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); r |= 0, isFinite(e) ? (e |= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0) } var o = this.length - r; if ((void 0 === e || e > o) && (e = o), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); for (var i = !1; ;)switch (n) { case "hex": return F(this, t, r, e); case "utf8": case "utf-8": return N(this, t, r, e); case "ascii": return I(this, t, r, e); case "latin1": case "binary": return P(this, t, r, e); case "base64": return C(this, t, r, e); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return R(this, t, r, e); default: if (i) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), i = !0 } }, d.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function B (t, r, e) { var n = ""; e = Math.min(t.length, e); for (var o = r; o < e; ++o)n += String.fromCharCode(127 & t[o]); return n } function k (t, r, e) { var n = ""; e = Math.min(t.length, e); for (var o = r; o < e; ++o)n += String.fromCharCode(t[o]); return n } function U (t, r, e) { var n = t.length; (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n); for (var o = "", i = r; i < e; ++i)o += J(t[i]); return o } function x (t, r, e) { for (var n = t.slice(r, e), o = "", i = 0; i < n.length; i += 2)o += String.fromCharCode(n[i] + 256 * n[i + 1]); return o } function M (t, r, e) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + r > e) throw new RangeError("Trying to access beyond buffer length") } function Y (t, r, e, n, o, i) { if (!S(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (r > o || r < i) throw new RangeError('"value" argument is out of bounds'); if (e + n > t.length) throw new RangeError("Index out of range") } function j (t, r, e, n) { r < 0 && (r = 65535 + r + 1); for (var o = 0, i = Math.min(t.length - e, 2); o < i; ++o)t[e + o] = (r & 255 << 8 * (n ? o : 1 - o)) >>> 8 * (n ? o : 1 - o) } function V (t, r, e, n) { r < 0 && (r = 4294967295 + r + 1); for (var o = 0, i = Math.min(t.length - e, 4); o < i; ++o)t[e + o] = r >>> 8 * (n ? o : 3 - o) & 255 } function z (t, r, e, n, o, i) { if (e + n > t.length) throw new RangeError("Index out of range"); if (e < 0) throw new RangeError("Index out of range") } function W (t, r, e, n, o) { return o || z(t, 0, e, 4), f(t, r, e, n, 23, 4), e + 4 } function X (t, r, e, n, o) { return o || z(t, 0, e, 8), f(t, r, e, n, 52, 8), e + 8 } d.prototype.slice = function (t, r) { var e, n = this.length; if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (r = void 0 === r ? n : ~~r) < 0 ? (r += n) < 0 && (r = 0) : r > n && (r = n), r < t && (r = t), d.TYPED_ARRAY_SUPPORT) (e = this.subarray(t, r)).__proto__ = d.prototype; else { var o = r - t; e = new d(o, void 0); for (var i = 0; i < o; ++i)e[i] = this[i + t] } return e }, d.prototype.readUIntLE = function (t, r, e) { t |= 0, r |= 0, e || M(t, r, this.length); for (var n = this[t], o = 1, i = 0; ++i < r && (o *= 256);)n += this[t + i] * o; return n }, d.prototype.readUIntBE = function (t, r, e) { t |= 0, r |= 0, e || M(t, r, this.length); for (var n = this[t + --r], o = 1; r > 0 && (o *= 256);)n += this[t + --r] * o; return n }, d.prototype.readUInt8 = function (t, r) { return r || M(t, 1, this.length), this[t] }, d.prototype.readUInt16LE = function (t, r) { return r || M(t, 2, this.length), this[t] | this[t + 1] << 8 }, d.prototype.readUInt16BE = function (t, r) { return r || M(t, 2, this.length), this[t] << 8 | this[t + 1] }, d.prototype.readUInt32LE = function (t, r) { return r || M(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, d.prototype.readUInt32BE = function (t, r) { return r || M(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, d.prototype.readIntLE = function (t, r, e) { t |= 0, r |= 0, e || M(t, r, this.length); for (var n = this[t], o = 1, i = 0; ++i < r && (o *= 256);)n += this[t + i] * o; return n >= (o *= 128) && (n -= Math.pow(2, 8 * r)), n }, d.prototype.readIntBE = function (t, r, e) { t |= 0, r |= 0, e || M(t, r, this.length); for (var n = r, o = 1, i = this[t + --n]; n > 0 && (o *= 256);)i += this[t + --n] * o; return i >= (o *= 128) && (i -= Math.pow(2, 8 * r)), i }, d.prototype.readInt8 = function (t, r) { return r || M(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, d.prototype.readInt16LE = function (t, r) { r || M(t, 2, this.length); var e = this[t] | this[t + 1] << 8; return 32768 & e ? 4294901760 | e : e }, d.prototype.readInt16BE = function (t, r) { r || M(t, 2, this.length); var e = this[t + 1] | this[t] << 8; return 32768 & e ? 4294901760 | e : e }, d.prototype.readInt32LE = function (t, r) { return r || M(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, d.prototype.readInt32BE = function (t, r) { return r || M(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, d.prototype.readFloatLE = function (t, r) { return r || M(t, 4, this.length), a(this, t, !0, 23, 4) }, d.prototype.readFloatBE = function (t, r) { return r || M(t, 4, this.length), a(this, t, !1, 23, 4) }, d.prototype.readDoubleLE = function (t, r) { return r || M(t, 8, this.length), a(this, t, !0, 52, 8) }, d.prototype.readDoubleBE = function (t, r) { return r || M(t, 8, this.length), a(this, t, !1, 52, 8) }, d.prototype.writeUIntLE = function (t, r, e, n) { (t = +t, r |= 0, e |= 0, n) || Y(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var o = 1, i = 0; for (this[r] = 255 & t; ++i < e && (o *= 256);)this[r + i] = t / o & 255; return r + e }, d.prototype.writeUIntBE = function (t, r, e, n) { (t = +t, r |= 0, e |= 0, n) || Y(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var o = e - 1, i = 1; for (this[r + o] = 255 & t; --o >= 0 && (i *= 256);)this[r + o] = t / i & 255; return r + e }, d.prototype.writeUInt8 = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 1, 255, 0), d.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[r] = 255 & t, r + 1 }, d.prototype.writeUInt16LE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 2, 65535, 0), d.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : j(this, t, r, !0), r + 2 }, d.prototype.writeUInt16BE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 2, 65535, 0), d.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : j(this, t, r, !1), r + 2 }, d.prototype.writeUInt32LE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 4, 4294967295, 0), d.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t) : V(this, t, r, !0), r + 4 }, d.prototype.writeUInt32BE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 4, 4294967295, 0), d.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : V(this, t, r, !1), r + 4 }, d.prototype.writeIntLE = function (t, r, e, n) { if (t = +t, r |= 0, !n) { var o = Math.pow(2, 8 * e - 1); Y(this, t, r, e, o - 1, -o) } var i = 0, s = 1, u = 0; for (this[r] = 255 & t; ++i < e && (s *= 256);)t < 0 && 0 === u && 0 !== this[r + i - 1] && (u = 1), this[r + i] = (t / s >> 0) - u & 255; return r + e }, d.prototype.writeIntBE = function (t, r, e, n) { if (t = +t, r |= 0, !n) { var o = Math.pow(2, 8 * e - 1); Y(this, t, r, e, o - 1, -o) } var i = e - 1, s = 1, u = 0; for (this[r + i] = 255 & t; --i >= 0 && (s *= 256);)t < 0 && 0 === u && 0 !== this[r + i + 1] && (u = 1), this[r + i] = (t / s >> 0) - u & 255; return r + e }, d.prototype.writeInt8 = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 1, 127, -128), d.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1 }, d.prototype.writeInt16LE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 2, 32767, -32768), d.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : j(this, t, r, !0), r + 2 }, d.prototype.writeInt16BE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 2, 32767, -32768), d.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : j(this, t, r, !1), r + 2 }, d.prototype.writeInt32LE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 4, 2147483647, -2147483648), d.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24) : V(this, t, r, !0), r + 4 }, d.prototype.writeInt32BE = function (t, r, e) { return t = +t, r |= 0, e || Y(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), d.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : V(this, t, r, !1), r + 4 }, d.prototype.writeFloatLE = function (t, r, e) { return W(this, t, r, !0, e) }, d.prototype.writeFloatBE = function (t, r, e) { return W(this, t, r, !1, e) }, d.prototype.writeDoubleLE = function (t, r, e) { return X(this, t, r, !0, e) }, d.prototype.writeDoubleBE = function (t, r, e) { return X(this, t, r, !1, e) }, d.prototype.copy = function (t, r, e, n) { if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e) return 0; if (0 === t.length || 0 === this.length) return 0; if (r < 0) throw new RangeError("targetStart out of bounds"); if (e < 0 || e >= this.length) throw new RangeError("sourceStart out of bounds"); if (n < 0) throw new RangeError("sourceEnd out of bounds"); n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e); var o, i = n - e; if (this === t && e < r && r < n) for (o = i - 1; o >= 0; --o)t[o + r] = this[o + e]; else if (i < 1e3 || !d.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o)t[o + r] = this[o + e]; else Uint8Array.prototype.set.call(t, this.subarray(e, e + i), r); return i }, d.prototype.fill = function (t, r, e, n) { if ("string" == typeof t) { if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), 1 === t.length) { var o = t.charCodeAt(0); o < 256 && (t = o) } if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string"); if ("string" == typeof n && !d.isEncoding(n)) throw new TypeError("Unknown encoding: " + n) } else "number" == typeof t && (t &= 255); if (r < 0 || this.length < r || this.length < e) throw new RangeError("Out of range index"); if (e <= r) return this; var i; if (r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0), "number" == typeof t) for (i = r; i < e; ++i)this[i] = t; else { var s = S(t) ? t : H(new d(t, n).toString()), u = s.length; for (i = 0; i < e - r; ++i)this[i + r] = s[i % u] } return this }; var K = /[^+\/0-9A-Za-z-_]/g; function J (t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function H (t, r) { var e; r = r || 1 / 0; for (var n = t.length, o = null, i = [], s = 0; s < n; ++s) { if ((e = t.charCodeAt(s)) > 55295 && e < 57344) { if (!o) { if (e > 56319) { (r -= 3) > -1 && i.push(239, 191, 189); continue } if (s + 1 === n) { (r -= 3) > -1 && i.push(239, 191, 189); continue } o = e; continue } if (e < 56320) { (r -= 3) > -1 && i.push(239, 191, 189), o = e; continue } e = 65536 + (o - 55296 << 10 | e - 56320) } else o && (r -= 3) > -1 && i.push(239, 191, 189); if (o = null, e < 128) { if ((r -= 1) < 0) break; i.push(e) } else if (e < 2048) { if ((r -= 2) < 0) break; i.push(e >> 6 | 192, 63 & e | 128) } else if (e < 65536) { if ((r -= 3) < 0) break; i.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128) } else { if (!(e < 1114112)) throw new Error("Invalid code point"); if ((r -= 4) < 0) break; i.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128) } } return i } function q (t) { return function (t) { var r, s, u, a, f, c; o || i(); var p = t.length; if (p % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); f = "=" === t[p - 2] ? 2 : "=" === t[p - 1] ? 1 : 0, c = new n(3 * p / 4 - f), u = f > 0 ? p - 4 : p; var h = 0; for (r = 0, s = 0; r < u; r += 4, s += 3)a = e[t.charCodeAt(r)] << 18 | e[t.charCodeAt(r + 1)] << 12 | e[t.charCodeAt(r + 2)] << 6 | e[t.charCodeAt(r + 3)], c[h++] = a >> 16 & 255, c[h++] = a >> 8 & 255, c[h++] = 255 & a; return 2 === f ? (a = e[t.charCodeAt(r)] << 2 | e[t.charCodeAt(r + 1)] >> 4, c[h++] = 255 & a) : 1 === f && (a = e[t.charCodeAt(r)] << 10 | e[t.charCodeAt(r + 1)] << 4 | e[t.charCodeAt(r + 2)] >> 2, c[h++] = a >> 8 & 255, c[h++] = 255 & a), c }(function (t) { if ((t = function (t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") }(t).replace(K, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function G (t, r, e, n) { for (var o = 0; o < n && !(o + e >= r.length || o >= t.length); ++o)r[o + e] = t[o]; return o } function $ (t) { return null != t && (!!t._isBuffer || Z(t) || function (t) { return "function" == typeof t.readFloatLE && "function" == typeof t.slice && Z(t.slice(0, 0)) }(t)) } function Z (t) { return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t) } var Q = Object.freeze({ __proto__: null, INSPECT_MAX_BYTES: 50, kMaxLength: h, Buffer: d, SlowBuffer: function (t) { return +t != t && (t = 0), d.alloc(+t) }, isBuffer: $ }); function tt () { } function rt () { rt.init.call(this) } function et (t) { return void 0 === t._maxListeners ? rt.defaultMaxListeners : t._maxListeners } function nt (t, r, e) { if (r) t.call(e); else for (var n = t.length, o = pt(t, n), i = 0; i < n; ++i)o[i].call(e) } function ot (t, r, e, n) { if (r) t.call(e, n); else for (var o = t.length, i = pt(t, o), s = 0; s < o; ++s)i[s].call(e, n) } function it (t, r, e, n, o) { if (r) t.call(e, n, o); else for (var i = t.length, s = pt(t, i), u = 0; u < i; ++u)s[u].call(e, n, o) } function st (t, r, e, n, o, i) { if (r) t.call(e, n, o, i); else for (var s = t.length, u = pt(t, s), a = 0; a < s; ++a)u[a].call(e, n, o, i) } function ut (t, r, e, n) { if (r) t.apply(e, n); else for (var o = t.length, i = pt(t, o), s = 0; s < o; ++s)i[s].apply(e, n) } function at (t, r, e, n) { var o, i, s, u; if ("function" != typeof e) throw new TypeError('"listener" argument must be a function'); if ((i = t._events) ? (i.newListener && (t.emit("newListener", r, e.listener ? e.listener : e), i = t._events), s = i[r]) : (i = t._events = new tt, t._eventsCount = 0), s) { if ("function" == typeof s ? s = i[r] = n ? [e, s] : [s, e] : n ? s.unshift(e) : s.push(e), !s.warned && (o = et(t)) && o > 0 && s.length > o) { s.warned = !0; var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + r + " listeners added. Use emitter.setMaxListeners() to increase limit"); a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = r, a.count = s.length, u = a, "function" == typeof console.warn ? console.warn(u) : console.log(u) } } else s = i[r] = e, ++t._eventsCount; return t } function ft (t, r, e) { var n = !1; function o () { t.removeListener(r, o), n || (n = !0, e.apply(t, arguments)) } return o.listener = e, o } function ct (t) { var r = this._events; if (r) { var e = r[t]; if ("function" == typeof e) return 1; if (e) return e.length } return 0 } function pt (t, r) { for (var e = new Array(r); r--;)e[r] = t[r]; return e } function ht (t, r) { for (var e = 0, n = t.length - 1; n >= 0; n--) { var o = t[n]; "." === o ? t.splice(n, 1) : ".." === o ? (t.splice(n, 1), e++) : e && (t.splice(n, 1), e--) } if (r) for (; e--; e)t.unshift(".."); return t } tt.prototype = Object.create(null), rt.EventEmitter = rt, rt.usingDomains = !1, rt.prototype.domain = void 0, rt.prototype._events = void 0, rt.prototype._maxListeners = void 0, rt.defaultMaxListeners = 10, rt.init = function () { this.domain = null, rt.usingDomains && (void 0).active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new tt, this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, rt.prototype.setMaxListeners = function (t) { if ("number" != typeof t || t < 0 || isNaN(t)) throw new TypeError('"n" argument must be a positive number'); return this._maxListeners = t, this }, rt.prototype.getMaxListeners = function () { return et(this) }, rt.prototype.emit = function (t) { var r, e, n, o, i, s, u, a = "error" === t; if (s = this._events) a = a && null == s.error; else if (!a) return !1; if (u = this.domain, a) { if (r = arguments[1], !u) { if (r instanceof Error) throw r; var f = new Error('Uncaught, unspecified "error" event. (' + r + ")"); throw f.context = r, f } return r || (r = new Error('Uncaught, unspecified "error" event')), r.domainEmitter = this, r.domain = u, r.domainThrown = !1, u.emit("error", r), !1 } if (!(e = s[t])) return !1; var c = "function" == typeof e; switch (n = arguments.length) { case 1: nt(e, c, this); break; case 2: ot(e, c, this, arguments[1]); break; case 3: it(e, c, this, arguments[1], arguments[2]); break; case 4: st(e, c, this, arguments[1], arguments[2], arguments[3]); break; default: for (o = new Array(n - 1), i = 1; i < n; i++)o[i - 1] = arguments[i]; ut(e, c, this, o) }return !0 }, rt.prototype.addListener = function (t, r) { return at(this, t, r, !1) }, rt.prototype.on = rt.prototype.addListener, rt.prototype.prependListener = function (t, r) { return at(this, t, r, !0) }, rt.prototype.once = function (t, r) { if ("function" != typeof r) throw new TypeError('"listener" argument must be a function'); return this.on(t, ft(this, t, r)), this }, rt.prototype.prependOnceListener = function (t, r) { if ("function" != typeof r) throw new TypeError('"listener" argument must be a function'); return this.prependListener(t, ft(this, t, r)), this }, rt.prototype.removeListener = function (t, r) { var e, n, o, i, s; if ("function" != typeof r) throw new TypeError('"listener" argument must be a function'); if (!(n = this._events)) return this; if (!(e = n[t])) return this; if (e === r || e.listener && e.listener === r) 0 == --this._eventsCount ? this._events = new tt : (delete n[t], n.removeListener && this.emit("removeListener", t, e.listener || r)); else if ("function" != typeof e) { for (o = -1, i = e.length; i-- > 0;)if (e[i] === r || e[i].listener && e[i].listener === r) { s = e[i].listener, o = i; break } if (o < 0) return this; if (1 === e.length) { if (e[0] = void 0, 0 == --this._eventsCount) return this._events = new tt, this; delete n[t] } else !function (t, r) { for (var e = r, n = e + 1, o = t.length; n < o; e += 1, n += 1)t[e] = t[n]; t.pop() }(e, o); n.removeListener && this.emit("removeListener", t, s || r) } return this }, rt.prototype.removeAllListeners = function (t) { var r, e; if (!(e = this._events)) return this; if (!e.removeListener) return 0 === arguments.length ? (this._events = new tt, this._eventsCount = 0) : e[t] && (0 == --this._eventsCount ? this._events = new tt : delete e[t]), this; if (0 === arguments.length) { for (var n, o = Object.keys(e), i = 0; i < o.length; ++i)"removeListener" !== (n = o[i]) && this.removeAllListeners(n); return this.removeAllListeners("removeListener"), this._events = new tt, this._eventsCount = 0, this } if ("function" == typeof (r = e[t])) this.removeListener(t, r); else if (r) do { this.removeListener(t, r[r.length - 1]) } while (r[0]); return this }, rt.prototype.listeners = function (t) { var r, e = this._events; return e && (r = e[t]) ? "function" == typeof r ? [r.listener || r] : function (t) { for (var r = new Array(t.length), e = 0; e < r.length; ++e)r[e] = t[e].listener || t[e]; return r }(r) : [] }, rt.listenerCount = function (t, r) { return "function" == typeof t.listenerCount ? t.listenerCount(r) : ct.call(t, r) }, rt.prototype.listenerCount = ct, rt.prototype.eventNames = function () { return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [] }; var lt = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, yt = function (t) { return lt.exec(t).slice(1) }; function dt () { for (var t = "", r = !1, e = arguments.length - 1; e >= -1 && !r; e--) { var n = e >= 0 ? arguments[e] : "/"; if ("string" != typeof n) throw new TypeError("Arguments to path.resolve must be strings"); n && (t = n + "/" + t, r = "/" === n.charAt(0)) } return (r ? "/" : "") + (t = ht(Tt(t.split("/"), (function (t) { return !!t })), !r).join("/")) || "." } function Et (t) { var r = gt(t), e = "/" === _t(t, -1); return (t = ht(Tt(t.split("/"), (function (t) { return !!t })), !r).join("/")) || r || (t = "."), t && e && (t += "/"), (r ? "/" : "") + t } function gt (t) { return "/" === t.charAt(0) } function mt () { var t = Array.prototype.slice.call(arguments, 0); return Et(Tt(t, (function (t, r) { if ("string" != typeof t) throw new TypeError("Arguments to path.join must be strings"); return t })).join("/")) } function wt (t, r) { function e (t) { for (var r = 0; r < t.length && "" === t[r]; r++); for (var e = t.length - 1; e >= 0 && "" === t[e]; e--); return r > e ? [] : t.slice(r, e - r + 1) } t = dt(t).substr(1), r = dt(r).substr(1); for (var n = e(t.split("/")), o = e(r.split("/")), i = Math.min(n.length, o.length), s = i, u = 0; u < i; u++)if (n[u] !== o[u]) { s = u; break } var a = []; for (u = s; u < n.length; u++)a.push(".."); return (a = a.concat(o.slice(s))).join("/") } function vt (t) { var r = yt(t), e = r[0], n = r[1]; return e || n ? (n && (n = n.substr(0, n.length - 1)), e + n) : "." } function St (t, r) { var e = yt(t)[2]; return r && e.substr(-1 * r.length) === r && (e = e.substr(0, e.length - r.length)), e } function bt (t) { return yt(t)[3] } var At = { extname: bt, basename: St, dirname: vt, sep: "/", delimiter: ":", relative: wt, join: mt, isAbsolute: gt, normalize: Et, resolve: dt }; function Tt (t, r) { if (t.filter) return t.filter(r); for (var e = [], n = 0; n < t.length; n++)r(t[n], n, t) && e.push(t[n]); return e } var _t = "b" === "ab".substr(-1) ? function (t, r, e) { return t.substr(r, e) } : function (t, r, e) { return r < 0 && (r = t.length + r), t.substr(r, e) }, Ot = Object.freeze({ __proto__: null, resolve: dt, normalize: Et, isAbsolute: gt, join: mt, relative: wt, sep: "/", delimiter: ":", dirname: vt, basename: St, extname: bt, default: At }); function Ft () { throw new Error("setTimeout has not been defined") } function Nt () { throw new Error("clearTimeout has not been defined") } var It = Ft, Pt = Nt; function Ct (t) { if (It === setTimeout) return setTimeout(t, 0); if ((It === Ft || !It) && setTimeout) return It = setTimeout, setTimeout(t, 0); try { return It(t, 0) } catch (r) { try { return It.call(null, t, 0) } catch (r) { return It.call(this, t, 0) } } } "function" == typeof global.setTimeout && (It = setTimeout), "function" == typeof global.clearTimeout && (Pt = clearTimeout); var Rt, Lt = [], Dt = !1, Bt = -1; function kt () { Dt && Rt && (Dt = !1, Rt.length ? Lt = Rt.concat(Lt) : Bt = -1, Lt.length && Ut()) } function Ut () { if (!Dt) { var t = Ct(kt); Dt = !0; for (var r = Lt.length; r;) { for (Rt = Lt, Lt = []; ++Bt < r;)Rt && Rt[Bt].run(); Bt = -1, r = Lt.length } Rt = null, Dt = !1, function (t) { if (Pt === clearTimeout) return clearTimeout(t); if ((Pt === Nt || !Pt) && clearTimeout) return Pt = clearTimeout, clearTimeout(t); try { Pt(t) } catch (r) { try { return Pt.call(null, t) } catch (r) { return Pt.call(this, t) } } }(t) } } function xt (t) { var r = new Array(arguments.length - 1); if (arguments.length > 1) for (var e = 1; e < arguments.length; e++)r[e - 1] = arguments[e]; Lt.push(new Mt(t, r)), 1 !== Lt.length || Dt || Ct(Ut) } function Mt (t, r) { this.fun = t, this.array = r } Mt.prototype.run = function () { this.fun.apply(null, this.array) }; var Yt = {}, jt = [], Vt = {}, zt = {}, Wt = {}; function Xt () { } var Kt = Xt, Jt = Xt, Ht = Xt, qt = Xt, Gt = Xt, $t = Xt, Zt = Xt; function Qt (t) { throw new Error("process.binding is not supported") } function tr () { return "/" } function rr (t) { throw new Error("process.chdir is not supported") } function er () { return 0 } var nr = global.performance || {}, or = nr.now || nr.mozNow || nr.msNow || nr.oNow || nr.webkitNow || function () { return (new Date).getTime() }; function ir (t) { var r = .001 * or.call(nr), e = Math.floor(r), n = Math.floor(r % 1 * 1e9); return t && (e -= t[0], (n -= t[1]) < 0 && (e--, n += 1e9)), [e, n] } var sr = new Date; function ur () { return (new Date - sr) / 1e3 } var ar = { nextTick: xt, title: "browser", browser: !0, env: Yt, argv: jt, version: "", versions: Vt, on: Kt, addListener: Jt, once: Ht, off: qt, removeListener: Gt, removeAllListeners: $t, emit: Zt, binding: Qt, cwd: tr, chdir: rr, umask: er, hrtime: ir, platform: "browser", release: zt, config: Wt, uptime: ur }, fr = Object.freeze({ __proto__: null, nextTick: xt, title: "browser", platform: "browser", browser: !0, env: Yt, argv: jt, version: "", versions: Vt, release: zt, config: Wt, on: Kt, addListener: Jt, once: Ht, off: qt, removeListener: Gt, removeAllListeners: $t, emit: Zt, binding: Qt, cwd: tr, chdir: rr, umask: er, hrtime: ir, uptime: ur, default: ar }), cr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function pr (t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function hr (t, r, e) { return t(e = { path: r, exports: {}, require: function (t, r) { return function () { throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs") }(null == r && e.path) } }, e.exports), e.exports } var lr = hr((function (t, r) { var e, n, o = cr && cr.__extends || (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, r) { t.__proto__ = r } || function (t, r) { for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]) }, function (t, r) { function n () { this.constructor = t } e(t, r), t.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n) }); r.__esModule = !0, function (t) { t[t.EPERM = 1] = "EPERM", t[t.ENOENT = 2] = "ENOENT", t[t.EIO = 5] = "EIO", t[t.EBADF = 9] = "EBADF", t[t.EACCES = 13] = "EACCES", t[t.EBUSY = 16] = "EBUSY", t[t.EEXIST = 17] = "EEXIST", t[t.ENOTDIR = 20] = "ENOTDIR", t[t.EISDIR = 21] = "EISDIR", t[t.EINVAL = 22] = "EINVAL", t[t.EFBIG = 27] = "EFBIG", t[t.ENOSPC = 28] = "ENOSPC", t[t.EROFS = 30] = "EROFS", t[t.ENOTEMPTY = 39] = "ENOTEMPTY", t[t.ENOTSUP = 95] = "ENOTSUP" }(n = r.ErrorCode || (r.ErrorCode = {})), r.ErrorStrings = {}, r.ErrorStrings[n.EPERM] = "Operation not permitted.", r.ErrorStrings[n.ENOENT] = "No such file or directory.", r.ErrorStrings[n.EIO] = "Input/output error.", r.ErrorStrings[n.EBADF] = "Bad file descriptor.", r.ErrorStrings[n.EACCES] = "Permission denied.", r.ErrorStrings[n.EBUSY] = "Resource busy or locked.", r.ErrorStrings[n.EEXIST] = "File exists.", r.ErrorStrings[n.ENOTDIR] = "File is not a directory.", r.ErrorStrings[n.EISDIR] = "File is a directory.", r.ErrorStrings[n.EINVAL] = "Invalid argument.", r.ErrorStrings[n.EFBIG] = "File is too big.", r.ErrorStrings[n.ENOSPC] = "No space left on disk.", r.ErrorStrings[n.EROFS] = "Cannot modify a read-only file system.", r.ErrorStrings[n.ENOTEMPTY] = "Directory is not empty.", r.ErrorStrings[n.ENOTSUP] = "Operation is not supported."; var i = function (t) { function e (e, o, i) { void 0 === o && (o = r.ErrorStrings[e]); var s = t.call(this, o) || this; return s.syscall = "", s.errno = e, s.code = n[e], s.path = i, s.stack = (new Error).stack, s.message = "Error: " + s.code + ": " + o + (s.path ? ", '" + s.path + "'" : ""), s } return o(e, t), e.fromJSON = function (t) { var r = new e(0); return r.errno = t.errno, r.code = t.code, r.path = t.path, r.stack = t.stack, r.message = t.message, r }, e.fromBuffer = function (t, r) { return void 0 === r && (r = 0), e.fromJSON(JSON.parse(t.toString("utf8", r + 4, r + 4 + t.readUInt32LE(r)))) }, e.FileError = function (t, n) { return new e(t, r.ErrorStrings[t], n) }, e.ENOENT = function (t) { return this.FileError(n.ENOENT, t) }, e.EEXIST = function (t) { return this.FileError(n.EEXIST, t) }, e.EISDIR = function (t) { return this.FileError(n.EISDIR, t) }, e.ENOTDIR = function (t) { return this.FileError(n.ENOTDIR, t) }, e.EPERM = function (t) { return this.FileError(n.EPERM, t) }, e.ENOTEMPTY = function (t) { return this.FileError(n.ENOTEMPTY, t) }, e.prototype.toString = function () { return this.message }, e.prototype.toJSON = function () { return { errno: this.errno, code: this.code, path: this.path, stack: this.stack, message: this.message } }, e.prototype.writeToBuffer = function (t, r) { void 0 === t && (t = Buffer.alloc(this.bufferSize())), void 0 === r && (r = 0); var e = t.write(JSON.stringify(this.toJSON()), r + 4); return t.writeUInt32LE(e, r), t }, e.prototype.bufferSize = function () { return 4 + Buffer.byteLength(JSON.stringify(this.toJSON())) }, e }(Error); r.ApiError = i })); pr(lr); var yr = lr.ErrorCode; lr.ErrorStrings; var dr = lr.ApiError, Er = hr((function (t, r) { var e; r.__esModule = !0, function (t) { t[t.NOP = 0] = "NOP", t[t.THROW_EXCEPTION = 1] = "THROW_EXCEPTION", t[t.TRUNCATE_FILE = 2] = "TRUNCATE_FILE", t[t.CREATE_FILE = 3] = "CREATE_FILE" }(e = r.ActionType || (r.ActionType = {})); var n = function () { function t (r) { if (this.flagStr = r, t.validFlagStrs.indexOf(r) < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid flag: " + r) } return t.getFileFlag = function (r) { return t.flagCache.hasOwnProperty(r) ? t.flagCache[r] : t.flagCache[r] = new t(r) }, t.prototype.getFlagString = function () { return this.flagStr }, t.prototype.isReadable = function () { return -1 !== this.flagStr.indexOf("r") || -1 !== this.flagStr.indexOf("+") }, t.prototype.isWriteable = function () { return -1 !== this.flagStr.indexOf("w") || -1 !== this.flagStr.indexOf("a") || -1 !== this.flagStr.indexOf("+") }, t.prototype.isTruncating = function () { return -1 !== this.flagStr.indexOf("w") }, t.prototype.isAppendable = function () { return -1 !== this.flagStr.indexOf("a") }, t.prototype.isSynchronous = function () { return -1 !== this.flagStr.indexOf("s") }, t.prototype.isExclusive = function () { return -1 !== this.flagStr.indexOf("x") }, t.prototype.pathExistsAction = function () { return this.isExclusive() ? e.THROW_EXCEPTION : this.isTruncating() ? e.TRUNCATE_FILE : e.NOP }, t.prototype.pathNotExistsAction = function () { return (this.isWriteable() || this.isAppendable()) && "r+" !== this.flagStr ? e.CREATE_FILE : e.THROW_EXCEPTION }, t }(); n.flagCache = {}, n.validFlagStrs = ["r", "r+", "rs", "rs+", "w", "wx", "w+", "wx+", "a", "ax", "a+", "ax+"], r.FileFlag = n })); pr(Er), Er.ActionType, Er.FileFlag; var gr = hr((function (t, r) { function e (t, r, e, n, o) { return t < r || e < r ? t > e ? e + 1 : t + 1 : n === o ? r : r + 1 } r.__esModule = !0, r.default = function (t, r) { if (t === r) return 0; if (t.length > r.length) { var n = t; t = r, r = n } for (var o = t.length, i = r.length; o > 0 && t.charCodeAt(o - 1) === r.charCodeAt(i - 1);)o--, i--; for (var s = 0; s < o && t.charCodeAt(s) === r.charCodeAt(s);)s++; if (i -= s, 0 === (o -= s) || 1 === i) return i; for (var u, a, f, c, p, h = new Array(o << 1), l = 0; l < o;)h[o + l] = t.charCodeAt(s + l), h[l] = ++l; for (u = 0; u + 3 < i;) { var y = r.charCodeAt(s + (a = u)), d = r.charCodeAt(s + (f = u + 1)), E = r.charCodeAt(s + (c = u + 2)), g = r.charCodeAt(s + (p = u + 3)), m = u += 4; for (l = 0; l < o;) { var w = h[o + l]; a = e(S = h[l], a, f, y, w), f = e(a, f, c, d, w), c = e(f, c, p, E, w), m = e(c, p, m, g, w), h[l++] = m, p = c, c = f, f = a, a = S } } for (var v = 0; u < i;) { y = r.charCodeAt(s + (a = u)); v = ++u; for (l = 0; l < o; l++) { var S = h[l]; h[l] = v = S < a || v < a ? S > v ? v + 1 : S + 1 : y === h[o + l] ? a : a + 1, a = S } } return v } })); pr(gr); var mr = hr((function (t, r) { function e (t) { return t instanceof Uint8Array ? t : new Uint8Array(t) } function n (t) { return t instanceof Buffer ? t : 0 === t.byteOffset && t.byteLength === t.buffer.byteLength ? o(t.buffer) : Buffer.from(t.buffer, t.byteOffset, t.byteLength) } function o (t) { return Buffer.from(t) } r.__esModule = !0, r.deprecationMessage = function (t, r, e) { t && console.warn("[" + r + "] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '" + r + ".Create(" + JSON.stringify(e) + ", callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.") }, r.isIE = "undefined" != typeof navigator && !(!/(msie) ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) && -1 === navigator.userAgent.indexOf("Trident")), r.isWebWorker = "undefined" == typeof window, r.fail = function () { throw new Error("BFS has reached an impossible code path; please file a bug.") }, r.mkdirpSync = function t (r, e, n) { n.existsSync(r) || (t(At.dirname(r), e, n), n.mkdirSync(r, e)) }, r.buffer2ArrayBuffer = function (t) { var r = e(t), n = r.byteOffset, o = r.byteLength; return 0 === n && o === r.buffer.byteLength ? r.buffer : r.buffer.slice(n, n + o) }, r.buffer2Uint8array = e, r.arrayish2Buffer = function (t) { return t instanceof Buffer ? t : t instanceof Uint8Array ? n(t) : Buffer.from(t) }, r.uint8Array2Buffer = n, r.arrayBuffer2Buffer = o, r.copyingSlice = function (t, r, o) { if (void 0 === r && (r = 0), void 0 === o && (o = t.length), r < 0 || o < 0 || o > t.length || r > o) throw new TypeError("Invalid slice bounds on buffer of length " + t.length + ": [" + r + ", " + o + "]"); if (0 === t.length) return s(); var i = e(t), u = t[0], a = (u + 1) % 255; return t[0] = a, i[0] === a ? (i[0] = u, n(i.slice(r, o))) : (t[0] = u, n(i.subarray(r, o))) }; var i = null; function s () { return i || (i = Buffer.alloc(0)) } r.emptyBuffer = s, r.bufferValidator = function (t, r) { Buffer.isBuffer(t) ? r() : r(new lr.ApiError(lr.ErrorCode.EINVAL, "option must be a Buffer.")) }, r.checkOptions = function (t, r, e) { var n = t.Options, o = t.Name, i = 0, s = !1, u = !1; function a (t) { s || (t && (s = !0, e(t)), 0 === --i && u && e()) } var f = function (t) { if (n.hasOwnProperty(t)) { var u = n[t], f = r[t]; if (null == f) { if (!u.optional) { var c = Object.keys(r).filter((function (t) { return !(t in n) })).map((function (r) { return { str: r, distance: gr.default(t, r) } })).filter((function (t) { return t.distance < 5 })).sort((function (t, r) { return t.distance - r.distance })); return s ? { value: void 0 } : (s = !0, { value: e(new lr.ApiError(lr.ErrorCode.EINVAL, "[" + o + "] Required option '" + t + "' not provided." + (c.length > 0 ? " You provided unrecognized option '" + c[0].str + "'; perhaps you meant to type '" + t + "'." : "") + "\nOption description: " + u.description)) }) } } else { if (!(Array.isArray(u.type) ? -1 !== u.type.indexOf(typeof f) : typeof f === u.type)) return s ? { value: void 0 } : (s = !0, { value: e(new lr.ApiError(lr.ErrorCode.EINVAL, "[" + o + "] Value provided for option " + t + " is not the proper type. Expected " + (Array.isArray(u.type) ? "one of {" + u.type.join(", ") + "}" : u.type) + ", but received " + typeof f + "\nOption description: " + u.description)) }); u.validator && (i++, u.validator(f, a)) } } }; for (var c in n) { var p = f(c); if ("object" == typeof p) return p.value } u = !0, 0 !== i || s || e() } })); pr(mr), mr.deprecationMessage, mr.isIE, mr.isWebWorker, mr.fail, mr.mkdirpSync, mr.buffer2ArrayBuffer, mr.buffer2Uint8array, mr.arrayish2Buffer, mr.uint8Array2Buffer, mr.arrayBuffer2Buffer, mr.copyingSlice, mr.emptyBuffer, mr.bufferValidator, mr.checkOptions; var wr = hr((function (t, r) { var e, n = cr && cr.__extends || (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, r) { t.__proto__ = r } || function (t, r) { for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]) }, function (t, r) { function n () { this.constructor = t } e(t, r), t.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n) }); r.__esModule = !0; var o = function () { function t () { } return t.prototype.supportsLinks = function () { return !1 }, t.prototype.diskSpace = function (t, r) { r(0, 0) }, t.prototype.openFile = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.createFile = function (t, r, e, n) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.open = function (t, r, e, n) { var o = this; this.stat(t, !1, (function (i, s) { if (i) switch (r.pathNotExistsAction()) { case Er.ActionType.CREATE_FILE: return o.stat(At.dirname(t), !1, (function (i, s) { i ? n(i) : s && !s.isDirectory() ? n(lr.ApiError.ENOTDIR(At.dirname(t))) : o.createFile(t, r, e, n) })); case Er.ActionType.THROW_EXCEPTION: return n(lr.ApiError.ENOENT(t)); default: return n(new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid FileFlag object.")) } else { if (s && s.isDirectory()) return n(lr.ApiError.EISDIR(t)); switch (r.pathExistsAction()) { case Er.ActionType.THROW_EXCEPTION: return n(lr.ApiError.EEXIST(t)); case Er.ActionType.TRUNCATE_FILE: return o.openFile(t, r, (function (t, r) { t ? n(t) : r ? r.truncate(0, (function () { r.sync((function () { n(null, r) })) })) : mr.fail() })); case Er.ActionType.NOP: return o.openFile(t, r, n); default: return n(new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid FileFlag object.")) } } })) }, t.prototype.rename = function (t, r, e) { e(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.renameSync = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.stat = function (t, r, e) { e(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.statSync = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.openFileSync = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.createFileSync = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.openSync = function (t, r, e) { var n; try { n = this.statSync(t, !1) } catch (n) { switch (r.pathNotExistsAction()) { case Er.ActionType.CREATE_FILE: if (!this.statSync(At.dirname(t), !1).isDirectory()) throw lr.ApiError.ENOTDIR(At.dirname(t)); return this.createFileSync(t, r, e); case Er.ActionType.THROW_EXCEPTION: throw lr.ApiError.ENOENT(t); default: throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid FileFlag object.") } } if (n.isDirectory()) throw lr.ApiError.EISDIR(t); switch (r.pathExistsAction()) { case Er.ActionType.THROW_EXCEPTION: throw lr.ApiError.EEXIST(t); case Er.ActionType.TRUNCATE_FILE: return this.unlinkSync(t), this.createFileSync(t, r, n.mode); case Er.ActionType.NOP: return this.openFileSync(t, r, e); default: throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid FileFlag object.") } }, t.prototype.unlink = function (t, r) { r(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.unlinkSync = function (t) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.rmdir = function (t, r) { r(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.rmdirSync = function (t) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.mkdir = function (t, r, e) { e(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.mkdirSync = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.readdir = function (t, r) { r(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.readdirSync = function (t) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.exists = function (t, r) { this.stat(t, null, (function (t) { r(!t) })) }, t.prototype.existsSync = function (t) { try { return this.statSync(t, !0), !0 } catch (t) { return !1 } }, t.prototype.realpath = function (t, r, e) { if (this.supportsLinks()) for (var n = t.split(At.sep), o = 0; o < n.length; o++) { var i = n.slice(0, o + 1); n[o] = At.join.apply(null, i) } else this.exists(t, (function (r) { r ? e(null, t) : e(lr.ApiError.ENOENT(t)) })) }, t.prototype.realpathSync = function (t, r) { if (this.supportsLinks()) { for (var e = t.split(At.sep), n = 0; n < e.length; n++) { var o = e.slice(0, n + 1); e[n] = At.join.apply(At, o) } return e.join(At.sep) } if (this.existsSync(t)) return t; throw lr.ApiError.ENOENT(t) }, t.prototype.truncate = function (t, r, e) { this.open(t, Er.FileFlag.getFileFlag("r+"), 420, (function (t, n) { if (t) return e(t); n.truncate(r, (function (t) { n.close((function (r) { e(t || r) })) })) })) }, t.prototype.truncateSync = function (t, r) { var e = this.openSync(t, Er.FileFlag.getFileFlag("r+"), 420); try { e.truncateSync(r) } catch (t) { throw t } finally { e.closeSync() } }, t.prototype.readFile = function (t, r, e, n) { var o = n; this.open(t, e, 420, (function (t, e) { if (t) return n(t); n = function (t, r) { e.close((function (e) { return t || (t = e), o(t, r) })) }, e.stat((function (t, o) { if (t) return n(t); var i = Buffer.alloc(o.size); e.read(i, 0, o.size, 0, (function (t) { if (t) return n(t); if (null === r) return n(t, i); try { n(null, i.toString(r)) } catch (t) { n(t) } })) })) })) }, t.prototype.readFileSync = function (t, r, e) { var n = this.openSync(t, e, 420); try { var o = n.statSync(), i = Buffer.alloc(o.size); return n.readSync(i, 0, o.size, 0), n.closeSync(), null === r ? i : i.toString(r) } finally { n.closeSync() } }, t.prototype.writeFile = function (t, r, e, n, o, i) { var s = i; this.open(t, n, 420, (function (t, n) { if (t) return i(t); i = function (t) { n.close((function (r) { s(t || r) })) }; try { "string" == typeof r && (r = Buffer.from(r, e)) } catch (t) { return i(t) } n.write(r, 0, r.length, 0, i) })) }, t.prototype.writeFileSync = function (t, r, e, n, o) { var i = this.openSync(t, n, o); try { "string" == typeof r && (r = Buffer.from(r, e)), i.writeSync(r, 0, r.length, 0) } finally { i.closeSync() } }, t.prototype.appendFile = function (t, r, e, n, o, i) { var s = i; this.open(t, n, o, (function (t, n) { if (t) return i(t); i = function (t) { n.close((function (r) { s(t || r) })) }, "string" == typeof r && (r = Buffer.from(r, e)), n.write(r, 0, r.length, null, i) })) }, t.prototype.appendFileSync = function (t, r, e, n, o) { var i = this.openSync(t, n, o); try { "string" == typeof r && (r = Buffer.from(r, e)), i.writeSync(r, 0, r.length, null) } finally { i.closeSync() } }, t.prototype.chmod = function (t, r, e, n) { n(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.chmodSync = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.chown = function (t, r, e, n, o) { o(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.chownSync = function (t, r, e, n) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.utimes = function (t, r, e, n) { n(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.utimesSync = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.link = function (t, r, e) { e(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.linkSync = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.symlink = function (t, r, e, n) { n(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.symlinkSync = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.readlink = function (t, r) { r(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.readlinkSync = function (t) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t }(); r.BaseFileSystem = o; var i = function (t) { function r () { return null !== t && t.apply(this, arguments) || this } return n(r, t), r.prototype.supportsSynch = function () { return !0 }, r.prototype.rename = function (t, r, e) { try { this.renameSync(t, r), e() } catch (t) { e(t) } }, r.prototype.stat = function (t, r, e) { try { e(null, this.statSync(t, r)) } catch (t) { e(t) } }, r.prototype.open = function (t, r, e, n) { try { n(null, this.openSync(t, r, e)) } catch (t) { n(t) } }, r.prototype.unlink = function (t, r) { try { this.unlinkSync(t), r() } catch (t) { r(t) } }, r.prototype.rmdir = function (t, r) { try { this.rmdirSync(t), r() } catch (t) { r(t) } }, r.prototype.mkdir = function (t, r, e) { try { this.mkdirSync(t, r), e() } catch (t) { e(t) } }, r.prototype.readdir = function (t, r) { try { r(null, this.readdirSync(t)) } catch (t) { r(t) } }, r.prototype.chmod = function (t, r, e, n) { try { this.chmodSync(t, r, e), n() } catch (t) { n(t) } }, r.prototype.chown = function (t, r, e, n, o) { try { this.chownSync(t, r, e, n), o() } catch (t) { o(t) } }, r.prototype.utimes = function (t, r, e, n) { try { this.utimesSync(t, r, e), n() } catch (t) { n(t) } }, r.prototype.link = function (t, r, e) { try { this.linkSync(t, r), e() } catch (t) { e(t) } }, r.prototype.symlink = function (t, r, e, n) { try { this.symlinkSync(t, r, e), n() } catch (t) { n(t) } }, r.prototype.readlink = function (t, r) { try { r(null, this.readlinkSync(t)) } catch (t) { r(t) } }, r }(o); r.SynchronousFileSystem = i })); pr(wr), wr.BaseFileSystem; var vr = wr.SynchronousFileSystem, Sr = hr((function (t, r) { var e; r.__esModule = !0, function (t) { t[t.FILE = 32768] = "FILE", t[t.DIRECTORY = 16384] = "DIRECTORY", t[t.SYMLINK = 40960] = "SYMLINK" }(e = r.FileType || (r.FileType = {})); var n = function () { function t (t, r, n, o, i, s) { if (void 0 === o && (o = new Date), void 0 === i && (i = new Date), void 0 === s && (s = new Date), this.size = r, this.atime = o, this.mtime = i, this.ctime = s, this.dev = 0, this.ino = 0, this.rdev = 0, this.nlink = 1, this.blksize = 4096, this.uid = 0, this.gid = 0, this.birthtime = new Date(0), this.fileData = null, n) this.mode = n; else switch (t) { case e.FILE: this.mode = 420; break; case e.DIRECTORY: default: this.mode = 511 }this.blocks = Math.ceil(r / 512), this.mode < 4096 && (this.mode |= t) } return t.fromBuffer = function (r) { var e = r.readUInt32LE(0), n = r.readUInt32LE(4), o = r.readDoubleLE(8), i = r.readDoubleLE(16), s = r.readDoubleLE(24); return new t(61440 & n, e, 4095 & n, new Date(o), new Date(i), new Date(s)) }, t.prototype.toBuffer = function () { var t = Buffer.alloc(32); return t.writeUInt32LE(this.size, 0), t.writeUInt32LE(this.mode, 4), t.writeDoubleLE(this.atime.getTime(), 8), t.writeDoubleLE(this.mtime.getTime(), 16), t.writeDoubleLE(this.ctime.getTime(), 24), t }, t.prototype.clone = function () { return new t(61440 & this.mode, this.size, 4095 & this.mode, this.atime, this.mtime, this.ctime) }, t.prototype.isFile = function () { return (61440 & this.mode) === e.FILE }, t.prototype.isDirectory = function () { return (61440 & this.mode) === e.DIRECTORY }, t.prototype.isSymbolicLink = function () { return (61440 & this.mode) === e.SYMLINK }, t.prototype.chmod = function (t) { this.mode = 61440 & this.mode | t }, t.prototype.isSocket = function () { return !1 }, t.prototype.isBlockDevice = function () { return !1 }, t.prototype.isCharacterDevice = function () { return !1 }, t.prototype.isFIFO = function () { return !1 }, t }(); r.default = n })), br = pr(Sr), Ar = Sr.FileType, Tr = hr((function (t, r) { r.__esModule = !0; var e = function () { function t (t, r, e, n, o, i) { this.id = t, this.size = r, this.mode = e, this.atime = n, this.mtime = o, this.ctime = i } return t.fromBuffer = function (r) { if (void 0 === r) throw new Error("NO"); return new t(r.toString("ascii", 30), r.readUInt32LE(0), r.readUInt16LE(4), r.readDoubleLE(6), r.readDoubleLE(14), r.readDoubleLE(22)) }, t.prototype.toStats = function () { return new Sr.default((61440 & this.mode) === Sr.FileType.DIRECTORY ? Sr.FileType.DIRECTORY : Sr.FileType.FILE, this.size, this.mode, new Date(this.atime), new Date(this.mtime), new Date(this.ctime)) }, t.prototype.getSize = function () { return 30 + this.id.length }, t.prototype.toBuffer = function (t) { return void 0 === t && (t = Buffer.alloc(this.getSize())), t.writeUInt32LE(this.size, 0), t.writeUInt16LE(this.mode, 4), t.writeDoubleLE(this.atime, 6), t.writeDoubleLE(this.mtime, 14), t.writeDoubleLE(this.ctime, 22), t.write(this.id, 30, this.id.length, "ascii"), t }, t.prototype.update = function (t) { var r = !1; this.size !== t.size && (this.size = t.size, r = !0), this.mode !== t.mode && (this.mode = t.mode, r = !0); var e = t.atime.getTime(); this.atime !== e && (this.atime = e, r = !0); var n = t.mtime.getTime(); this.mtime !== n && (this.mtime = n, r = !0); var o = t.ctime.getTime(); return this.ctime !== o && (this.ctime = o, r = !0), r }, t.prototype.isFile = function () { return (61440 & this.mode) === Sr.FileType.FILE }, t.prototype.isDirectory = function () { return (61440 & this.mode) === Sr.FileType.DIRECTORY }, t }(); r.default = e })); pr(Tr); var _r = hr((function (t, r) { r.__esModule = !0; var e = function () { function t () { } return t.prototype.sync = function (t) { t(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.syncSync = function () { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.datasync = function (t) { this.sync(t) }, t.prototype.datasyncSync = function () { return this.syncSync() }, t.prototype.chown = function (t, r, e) { e(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.chownSync = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.chmod = function (t, r) { r(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.chmodSync = function (t) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.utimes = function (t, r, e) { e(new lr.ApiError(lr.ErrorCode.ENOTSUP)) }, t.prototype.utimesSync = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t }(); r.BaseFile = e })); pr(_r), _r.BaseFile; var Or = hr((function (t, r) { r.__esModule = !0; var e = At, n = function (t, r) { return t }; function o (t) { if (t) return t; throw new lr.ApiError(lr.ErrorCode.EIO, "Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)") } function i (t, r) { switch (typeof t) { case "number": return t; case "string": var e = parseInt(t, 8); return isNaN(e) ? r : e; default: return r } } function s (t) { if (t instanceof Date) return t; if ("number" == typeof t) return new Date(1e3 * t); throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid time.") } function u (t) { if (t.indexOf("\0") >= 0) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Path must be a string without null bytes."); if ("" === t) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Path must not be empty."); return e.resolve(t) } function a (t, r, e, n) { switch (typeof t) { case "object": return { encoding: void 0 !== t.encoding ? t.encoding : r, flag: void 0 !== t.flag ? t.flag : e, mode: i(t.mode, n) }; case "string": return { encoding: t, flag: e, mode: n }; default: return { encoding: r, flag: e, mode: n } } } function f () { } var c = function () { function t () { this.F_OK = 0, this.R_OK = 4, this.W_OK = 2, this.X_OK = 1, this.root = null, this.fdMap = {}, this.nextFd = 100 } return t.prototype.initialize = function (t) { if (!t.constructor.isAvailable()) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Tried to instantiate BrowserFS with an unavailable file system."); return this.root = t }, t.prototype._toUnixTimestamp = function (t) { if ("number" == typeof t) return t; if (t instanceof Date) return t.getTime() / 1e3; throw new Error("Cannot parse time: " + t) }, t.prototype.getRootFS = function () { return this.root ? this.root : null }, t.prototype.rename = function (t, r, e) { void 0 === e && (e = f); var i = n(e, 1); try { o(this.root).rename(u(t), u(r), i) } catch (t) { i(t) } }, t.prototype.renameSync = function (t, r) { o(this.root).renameSync(u(t), u(r)) }, t.prototype.exists = function (t, r) { void 0 === r && (r = f); var e = n(r, 1); try { return o(this.root).exists(u(t), e) } catch (t) { return e(!1) } }, t.prototype.existsSync = function (t) { try { return o(this.root).existsSync(u(t)) } catch (t) { return !1 } }, t.prototype.stat = function (t, r) { void 0 === r && (r = f); var e = n(r, 2); try { return o(this.root).stat(u(t), !1, e) } catch (t) { return e(t) } }, t.prototype.statSync = function (t) { return o(this.root).statSync(u(t), !1) }, t.prototype.lstat = function (t, r) { void 0 === r && (r = f); var e = n(r, 2); try { return o(this.root).stat(u(t), !0, e) } catch (t) { return e(t) } }, t.prototype.lstatSync = function (t) { return o(this.root).statSync(u(t), !0) }, t.prototype.truncate = function (t, r, e) { void 0 === r && (r = 0), void 0 === e && (e = f); var i = 0; "function" == typeof r ? e = r : "number" == typeof r && (i = r); var s = n(e, 1); try { if (i < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL); return o(this.root).truncate(u(t), i, s) } catch (t) { return s(t) } }, t.prototype.truncateSync = function (t, r) { if (void 0 === r && (r = 0), r < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL); return o(this.root).truncateSync(u(t), r) }, t.prototype.unlink = function (t, r) { void 0 === r && (r = f); var e = n(r, 1); try { return o(this.root).unlink(u(t), e) } catch (t) { return e(t) } }, t.prototype.unlinkSync = function (t) { return o(this.root).unlinkSync(u(t)) }, t.prototype.open = function (t, r, e, s) { var a = this; void 0 === s && (s = f); var c = i(e, 420), p = n(s = "function" == typeof e ? e : s, 2); try { o(this.root).open(u(t), Er.FileFlag.getFileFlag(r), c, (function (t, r) { r ? p(t, a.getFdForFile(r)) : p(t) })) } catch (t) { p(t) } }, t.prototype.openSync = function (t, r, e) { return void 0 === e && (e = 420), this.getFdForFile(o(this.root).openSync(u(t), Er.FileFlag.getFileFlag(r), i(e, 420))) }, t.prototype.readFile = function (t, r, e) { void 0 === r && (r = {}), void 0 === e && (e = f); var i = a(r, null, "r", null), s = n(e = "function" == typeof r ? r : e, 2); try { var c = Er.FileFlag.getFileFlag(i.flag); return c.isReadable() ? o(this.root).readFile(u(t), i.encoding, c, s) : s(new lr.ApiError(lr.ErrorCode.EINVAL, "Flag passed to readFile must allow for reading.")) } catch (t) { return s(t) } }, t.prototype.readFileSync = function (t, r) { void 0 === r && (r = {}); var e = a(r, null, "r", null), n = Er.FileFlag.getFileFlag(e.flag); if (!n.isReadable()) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Flag passed to readFile must allow for reading."); return o(this.root).readFileSync(u(t), e.encoding, n) }, t.prototype.writeFile = function (t, r, e, i) { void 0 === e && (e = {}), void 0 === i && (i = f); var s = a(e, "utf8", "w", 420), c = n(i = "function" == typeof e ? e : i, 1); try { var p = Er.FileFlag.getFileFlag(s.flag); return p.isWriteable() ? o(this.root).writeFile(u(t), r, s.encoding, p, s.mode, c) : c(new lr.ApiError(lr.ErrorCode.EINVAL, "Flag passed to writeFile must allow for writing.")) } catch (t) { return c(t) } }, t.prototype.writeFileSync = function (t, r, e) { var n = a(e, "utf8", "w", 420), i = Er.FileFlag.getFileFlag(n.flag); if (!i.isWriteable()) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Flag passed to writeFile must allow for writing."); return o(this.root).writeFileSync(u(t), r, n.encoding, i, n.mode) }, t.prototype.appendFile = function (t, r, e, i) { void 0 === i && (i = f); var s = a(e, "utf8", "a", 420), c = n(i = "function" == typeof e ? e : i, 1); try { var p = Er.FileFlag.getFileFlag(s.flag); if (!p.isAppendable()) return c(new lr.ApiError(lr.ErrorCode.EINVAL, "Flag passed to appendFile must allow for appending.")); o(this.root).appendFile(u(t), r, s.encoding, p, s.mode, c) } catch (t) { c(t) } }, t.prototype.appendFileSync = function (t, r, e) { var n = a(e, "utf8", "a", 420), i = Er.FileFlag.getFileFlag(n.flag); if (!i.isAppendable()) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Flag passed to appendFile must allow for appending."); return o(this.root).appendFileSync(u(t), r, n.encoding, i, n.mode) }, t.prototype.fstat = function (t, r) { void 0 === r && (r = f); var e = n(r, 2); try { this.fd2file(t).stat(e) } catch (t) { e(t) } }, t.prototype.fstatSync = function (t) { return this.fd2file(t).statSync() }, t.prototype.close = function (t, r) { var e = this; void 0 === r && (r = f); var o = n(r, 1); try { this.fd2file(t).close((function (r) { r || e.closeFd(t), o(r) })) } catch (t) { o(t) } }, t.prototype.closeSync = function (t) { this.fd2file(t).closeSync(), this.closeFd(t) }, t.prototype.ftruncate = function (t, r, e) { void 0 === e && (e = f); var o = "number" == typeof r ? r : 0, i = n(e = "function" == typeof r ? r : e, 1); try { var s = this.fd2file(t); if (o < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL); s.truncate(o, i) } catch (t) { i(t) } }, t.prototype.ftruncateSync = function (t, r) { void 0 === r && (r = 0); var e = this.fd2file(t); if (r < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL); e.truncateSync(r) }, t.prototype.fsync = function (t, r) { void 0 === r && (r = f); var e = n(r, 1); try { this.fd2file(t).sync(e) } catch (t) { e(t) } }, t.prototype.fsyncSync = function (t) { this.fd2file(t).syncSync() }, t.prototype.fdatasync = function (t, r) { void 0 === r && (r = f); var e = n(r, 1); try { this.fd2file(t).datasync(e) } catch (t) { e(t) } }, t.prototype.fdatasyncSync = function (t) { this.fd2file(t).datasyncSync() }, t.prototype.write = function (t, r, e, o, i, s) { void 0 === s && (s = f); var u, a, c, p = null; if ("string" == typeof r) { var h = "utf8"; switch (typeof e) { case "function": s = e; break; case "number": p = e, h = "string" == typeof o ? o : "utf8", s = "function" == typeof i ? i : s; break; default: return (s = "function" == typeof o ? o : "function" == typeof i ? i : s)(new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid arguments.")) }a = 0, c = (u = Buffer.from(r, h)).length } else u = r, a = e, c = o, p = "number" == typeof i ? i : null, s = "function" == typeof i ? i : s; var l = n(s, 3); try { var y = this.fd2file(t); null == p && (p = y.getPos()), y.write(u, a, c, p, l) } catch (t) { l(t) } }, t.prototype.writeSync = function (t, r, e, n, o) { var i, s, u, a = 0; if ("string" == typeof r) { u = "number" == typeof e ? e : null; var f = "string" == typeof n ? n : "utf8"; a = 0, s = (i = Buffer.from(r, f)).length } else i = r, a = e, s = n, u = "number" == typeof o ? o : null; var c = this.fd2file(t); return null == u && (u = c.getPos()), c.writeSync(i, a, s, u) }, t.prototype.read = function (t, r, e, o, i, s) { var u, a, c, p, h; if (void 0 === s && (s = f), "number" == typeof r) { c = r, u = e; var l = o; s = "function" == typeof i ? i : s, a = 0, p = Buffer.alloc(c), h = n((function (t, r, e) { if (t) return s(t); s(t, e.toString(l), r) }), 3) } else p = r, a = e, c = o, u = i, h = n(s, 3); try { var y = this.fd2file(t); null == u && (u = y.getPos()), y.read(p, a, c, u, h) } catch (t) { h(t) } }, t.prototype.readSync = function (t, r, e, n, o) { var i, s, u, a, f = !1, c = "utf8"; "number" == typeof r ? (u = r, a = e, c = n, s = 0, i = Buffer.alloc(u), f = !0) : (i = r, s = e, u = n, a = o); var p = this.fd2file(t); null == a && (a = p.getPos()); var h = p.readSync(i, s, u, a); return f ? [i.toString(c), h] : h }, t.prototype.fchown = function (t, r, e, o) { void 0 === o && (o = f); var i = n(o, 1); try { this.fd2file(t).chown(r, e, i) } catch (t) { i(t) } }, t.prototype.fchownSync = function (t, r, e) { this.fd2file(t).chownSync(r, e) }, t.prototype.fchmod = function (t, r, e) { var o = n(e, 1); try { var i = "string" == typeof r ? parseInt(r, 8) : r; this.fd2file(t).chmod(i, o) } catch (t) { o(t) } }, t.prototype.fchmodSync = function (t, r) { var e = "string" == typeof r ? parseInt(r, 8) : r; this.fd2file(t).chmodSync(e) }, t.prototype.futimes = function (t, r, e, o) { void 0 === o && (o = f); var i = n(o, 1); try { var s = this.fd2file(t); "number" == typeof r && (r = new Date(1e3 * r)), "number" == typeof e && (e = new Date(1e3 * e)), s.utimes(r, e, i) } catch (t) { i(t) } }, t.prototype.futimesSync = function (t, r, e) { this.fd2file(t).utimesSync(s(r), s(e)) }, t.prototype.rmdir = function (t, r) { void 0 === r && (r = f); var e = n(r, 1); try { t = u(t), o(this.root).rmdir(t, e) } catch (t) { e(t) } }, t.prototype.rmdirSync = function (t) { return t = u(t), o(this.root).rmdirSync(t) }, t.prototype.mkdir = function (t, r, e) { void 0 === e && (e = f), "function" == typeof r && (e = r, r = 511); var i = n(e, 1); try { t = u(t), o(this.root).mkdir(t, r, i) } catch (t) { i(t) } }, t.prototype.mkdirSync = function (t, r) { o(this.root).mkdirSync(u(t), i(r, 511)) }, t.prototype.readdir = function (t, r) { void 0 === r && (r = f); var e = n(r, 2); try { t = u(t), o(this.root).readdir(t, e) } catch (t) { e(t) } }, t.prototype.readdirSync = function (t) { return t = u(t), o(this.root).readdirSync(t) }, t.prototype.link = function (t, r, e) { void 0 === e && (e = f); var i = n(e, 1); try { t = u(t), r = u(r), o(this.root).link(t, r, i) } catch (t) { i(t) } }, t.prototype.linkSync = function (t, r) { return t = u(t), r = u(r), o(this.root).linkSync(t, r) }, t.prototype.symlink = function (t, r, e, i) { void 0 === i && (i = f); var s = "string" == typeof e ? e : "file", a = n(i = "function" == typeof e ? e : i, 1); try { if ("file" !== s && "dir" !== s) return a(new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid type: " + s)); t = u(t), r = u(r), o(this.root).symlink(t, r, s, a) } catch (t) { a(t) } }, t.prototype.symlinkSync = function (t, r, e) { if (e) { if ("file" !== e && "dir" !== e) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid type: " + e) } else e = "file"; return t = u(t), r = u(r), o(this.root).symlinkSync(t, r, e) }, t.prototype.readlink = function (t, r) { void 0 === r && (r = f); var e = n(r, 2); try { t = u(t), o(this.root).readlink(t, e) } catch (t) { e(t) } }, t.prototype.readlinkSync = function (t) { return t = u(t), o(this.root).readlinkSync(t) }, t.prototype.chown = function (t, r, e, i) { void 0 === i && (i = f); var s = n(i, 1); try { t = u(t), o(this.root).chown(t, !1, r, e, s) } catch (t) { s(t) } }, t.prototype.chownSync = function (t, r, e) { t = u(t), o(this.root).chownSync(t, !1, r, e) }, t.prototype.lchown = function (t, r, e, i) { void 0 === i && (i = f); var s = n(i, 1); try { t = u(t), o(this.root).chown(t, !0, r, e, s) } catch (t) { s(t) } }, t.prototype.lchownSync = function (t, r, e) { t = u(t), o(this.root).chownSync(t, !0, r, e) }, t.prototype.chmod = function (t, r, e) { void 0 === e && (e = f); var s = n(e, 1); try { var a = i(r, -1); if (a < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid mode."); o(this.root).chmod(u(t), !1, a, s) } catch (t) { s(t) } }, t.prototype.chmodSync = function (t, r) { var e = i(r, -1); if (e < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid mode."); t = u(t), o(this.root).chmodSync(t, !1, e) }, t.prototype.lchmod = function (t, r, e) { void 0 === e && (e = f); var s = n(e, 1); try { var a = i(r, -1); if (a < 0) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid mode."); o(this.root).chmod(u(t), !0, a, s) } catch (t) { s(t) } }, t.prototype.lchmodSync = function (t, r) { var e = i(r, -1); if (e < 1) throw new lr.ApiError(lr.ErrorCode.EINVAL, "Invalid mode."); o(this.root).chmodSync(u(t), !0, e) }, t.prototype.utimes = function (t, r, e, i) { void 0 === i && (i = f); var a = n(i, 1); try { o(this.root).utimes(u(t), s(r), s(e), a) } catch (t) { a(t) } }, t.prototype.utimesSync = function (t, r, e) { o(this.root).utimesSync(u(t), s(r), s(e)) }, t.prototype.realpath = function (t, r, e) { void 0 === e && (e = f); var i = "object" == typeof r ? r : {}, s = n(e = "function" == typeof r ? r : f, 2); try { t = u(t), o(this.root).realpath(t, i, s) } catch (t) { s(t) } }, t.prototype.realpathSync = function (t, r) { return void 0 === r && (r = {}), t = u(t), o(this.root).realpathSync(t, r) }, t.prototype.watchFile = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.unwatchFile = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.watch = function (t, r, e) { return "function" == typeof r ? o(this.root).watch(u(t), r) : o(this.root).watch(u(t), r, e) }, t.prototype.access = function (t, r, e) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.accessSync = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.createReadStream = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.createWriteStream = function (t, r) { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, t.prototype.wrapCallbacks = function (t) { n = t }, t.prototype.getFdForFile = function (t) { var r = this.nextFd++; return this.fdMap[r] = t, r }, t.prototype.fd2file = function (t) { var r = this.fdMap[t]; if (r) return r; throw new lr.ApiError(lr.ErrorCode.EBADF, "Invalid file descriptor.") }, t.prototype.closeFd = function (t) { delete this.fdMap[t] }, t }(); c.Stats = Sr.default, r.default = c })), Fr = pr(Or), Nr = hr((function (t, r) { r.__esModule = !0; var e = new Or.default, n = {}, o = Or.default.prototype; Object.keys(o).forEach((function (t) { "function" == typeof e[t] ? n[t] = function () { return e[t].apply(e, arguments) } : n[t] = e[t] })), n.changeFSModule = function (t) { e = t }, n.getFSModule = function () { return e }, n.FS = Or.default, r.default = n })), Ir = pr(Nr), Pr = hr((function (t, r) { var e, n = cr && cr.__extends || (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, r) { t.__proto__ = r } || function (t, r) { for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]) }, function (t, r) { function n () { this.constructor = t } e(t, r), t.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n) }); r.__esModule = !0; var o = function (t) { function r (r, e, n, o, i) { var s = t.call(this) || this; if (s._pos = 0, s._dirty = !1, s._fs = r, s._path = e, s._flag = n, s._stat = o, s._buffer = i || mr.emptyBuffer(), s._stat.size !== s._buffer.length && s._flag.isReadable()) throw new Error("Invalid buffer: Buffer is " + s._buffer.length + " long, yet Stats object specifies that file is " + s._stat.size + " long."); return s } return n(r, t), r.prototype.getBuffer = function () { return this._buffer }, r.prototype.getStats = function () { return this._stat }, r.prototype.getFlag = function () { return this._flag }, r.prototype.getPath = function () { return this._path }, r.prototype.getPos = function () { return this._flag.isAppendable() ? this._stat.size : this._pos }, r.prototype.advancePos = function (t) { return this._pos += t }, r.prototype.setPos = function (t) { return this._pos = t }, r.prototype.sync = function (t) { try { this.syncSync(), t() } catch (r) { t(r) } }, r.prototype.syncSync = function () { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, r.prototype.close = function (t) { try { this.closeSync(), t() } catch (r) { t(r) } }, r.prototype.closeSync = function () { throw new lr.ApiError(lr.ErrorCode.ENOTSUP) }, r.prototype.stat = function (t) { try { t(null, this._stat.clone()) } catch (r) { t(r) } }, r.prototype.statSync = function () { return this._stat.clone() }, r.prototype.truncate = function (t, r) { try { this.truncateSync(t), this._flag.isSynchronous() && !Nr.default.getRootFS().supportsSynch() && this.sync(r), r() } catch (t) { return r(t) } }, r.prototype.truncateSync = function (t) { if (this._dirty = !0, !this._flag.isWriteable()) throw new lr.ApiError(lr.ErrorCode.EPERM, "File not opened with a writeable mode."); if (this._stat.mtime = new Date, t > this._buffer.length) { var r = Buffer.alloc(t - this._buffer.length, 0); return this.writeSync(r, 0, r.length, this._buffer.length), void (this._flag.isSynchronous() && Nr.default.getRootFS().supportsSynch() && this.syncSync()) } this._stat.size = t; var e = Buffer.alloc(t); this._buffer.copy(e, 0, 0, t), this._buffer = e, this._flag.isSynchronous() && Nr.default.getRootFS().supportsSynch() && this.syncSync() }, r.prototype.write = function (t, r, e, n, o) { try { o(null, this.writeSync(t, r, e, n), t) } catch (t) { o(t) } }, r.prototype.writeSync = function (t, r, e, n) { if (this._dirty = !0, null == n && (n = this.getPos()), !this._flag.isWriteable()) throw new lr.ApiError(lr.ErrorCode.EPERM, "File not opened with a writeable mode."); var o = n + e; if (o > this._stat.size && (this._stat.size = o, o > this._buffer.length)) { var i = Buffer.alloc(o); this._buffer.copy(i), this._buffer = i } var s = t.copy(this._buffer, n, r, r + e); return this._stat.mtime = new Date, this._flag.isSynchronous() ? (this.syncSync(), s) : (this.setPos(n + s), s) }, r.prototype.read = function (t, r, e, n, o) { try { o(null, this.readSync(t, r, e, n), t) } catch (t) { o(t) } }, r.prototype.readSync = function (t, r, e, n) { if (!this._flag.isReadable()) throw new lr.ApiError(lr.ErrorCode.EPERM, "File not opened with a readable mode."); null == n && (n = this.getPos()), n + e > this._stat.size && (e = this._stat.size - n); var o = this._buffer.copy(t, r, n, n + e); return this._stat.atime = new Date, this._pos = n + e, o }, r.prototype.chmod = function (t, r) { try { this.chmodSync(t), r() } catch (t) { r(t) } }, r.prototype.chmodSync = function (t) { if (!this._fs.supportsProps()) throw new lr.ApiError(lr.ErrorCode.ENOTSUP); this._dirty = !0, this._stat.chmod(t), this.syncSync() }, r.prototype.isDirty = function () { return this._dirty }, r.prototype.resetDirty = function () { this._dirty = !1 }, r }(_r.BaseFile); r.default = o; var i = function (t) { function r (r, e, n, o, i) { return t.call(this, r, e, n, o, i) || this } return n(r, t), r.prototype.sync = function (t) { t() }, r.prototype.syncSync = function () { }, r.prototype.close = function (t) { t() }, r.prototype.closeSync = function () { }, r }(o); r.NoSyncFile = i })), Cr = pr(Pr); Pr.NoSyncFile; var Rr = hr((function (t, r) { var e, n = cr && cr.__extends || (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, r) { t.__proto__ = r } || function (t, r) { for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]) }, function (t, r) { function n () { this.constructor = t } e(t, r), t.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n) }); r.__esModule = !0; var o = null; function i () { return o || (o = Buffer.from("{}")) } function s () { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (t) { var r = 16 * Math.random() | 0; return ("x" === t ? r : 3 & r | 8).toString(16) })) } function u (t, r) { return !t || (r(t), !1) } function a (t, r, e) { return !t || (r.abort((function () { e(t) })), !1) } var f = function () { function t (t) { this.store = t, this.originalData = {}, this.modifiedKeys = [] } return t.prototype.get = function (t) { var r = this.store.get(t); return this.stashOldValue(t, r), r }, t.prototype.put = function (t, r, e) { return this.markModified(t), this.store.put(t, r, e) }, t.prototype.del = function (t) { this.markModified(t), this.store.del(t) }, t.prototype.commit = function () { }, t.prototype.abort = function () { for (var t = 0, r = this.modifiedKeys; t < r.length; t++) { var e = r[t], n = this.originalData[e]; n ? this.store.put(e, n, !0) : this.store.del(e) } }, t.prototype.stashOldValue = function (t, r) { this.originalData.hasOwnProperty(t) || (this.originalData[t] = r) }, t.prototype.markModified = function (t) { -1 === this.modifiedKeys.indexOf(t) && (this.modifiedKeys.push(t), this.originalData.hasOwnProperty(t) || (this.originalData[t] = this.store.get(t))) }, t }(); r.SimpleSyncRWTransaction = f; var c = function (t) { function r (r, e, n, o, i) { return t.call(this, r, e, n, o, i) || this } return n(r, t), r.prototype.syncSync = function () { this.isDirty() && (this._fs._syncSync(this.getPath(), this.getBuffer(), this.getStats()), this.resetDirty()) }, r.prototype.closeSync = function () { this.syncSync() }, r }(Pr.default); r.SyncKeyValueFile = c; var p = function (t) { function r (r) { var e = t.call(this) || this; return e.store = r.store, e.makeRootDirectory(), e } return n(r, t), r.isAvailable = function () { return !0 }, r.prototype.getName = function () { return this.store.name() }, r.prototype.isReadOnly = function () { return !1 }, r.prototype.supportsSymlinks = function () { return !1 }, r.prototype.supportsProps = function () { return !1 }, r.prototype.supportsSynch = function () { return !0 }, r.prototype.empty = function () { this.store.clear(), this.makeRootDirectory() }, r.prototype.renameSync = function (t, r) { var e = this.store.beginTransaction("readwrite"), n = At.dirname(t), o = At.basename(t), i = At.dirname(r), s = At.basename(r), u = this.findINode(e, n), a = this.getDirListing(e, n, u); if (!a[o]) throw lr.ApiError.ENOENT(t); var f, c, p = a[o]; if (delete a[o], 0 === (i + "/").indexOf(t + "/")) throw new lr.ApiError(lr.ErrorCode.EBUSY, n); if (i === n ? (f = u, c = a) : (f = this.findINode(e, i), c = this.getDirListing(e, i, f)), c[s]) { var h = this.getINode(e, r, c[s]); if (!h.isFile()) throw lr.ApiError.EPERM(r); try { e.del(h.id), e.del(c[s]) } catch (t) { throw e.abort(), t } } c[s] = p; try { e.put(u.id, Buffer.from(JSON.stringify(a)), !0), e.put(f.id, Buffer.from(JSON.stringify(c)), !0) } catch (t) { throw e.abort(), t } e.commit() }, r.prototype.statSync = function (t, r) { return this.findINode(this.store.beginTransaction("readonly"), t).toStats() }, r.prototype.createFileSync = function (t, r, e) { var n = this.store.beginTransaction("readwrite"), o = mr.emptyBuffer(), i = this.commitNewFile(n, t, Sr.FileType.FILE, e, o); return new c(this, t, r, i.toStats(), o) }, r.prototype.openFileSync = function (t, r) { var e = this.store.beginTransaction("readonly"), n = this.findINode(e, t), o = e.get(n.id); if (void 0 === o) throw lr.ApiError.ENOENT(t); return new c(this, t, r, n.toStats(), o) }, r.prototype.unlinkSync = function (t) { this.removeEntry(t, !1) }, r.prototype.rmdirSync = function (t) { if (this.readdirSync(t).length > 0) throw lr.ApiError.ENOTEMPTY(t); this.removeEntry(t, !0) }, r.prototype.mkdirSync = function (t, r) { var e = this.store.beginTransaction("readwrite"), n = Buffer.from("{}"); this.commitNewFile(e, t, Sr.FileType.DIRECTORY, r, n) }, r.prototype.readdirSync = function (t) { var r = this.store.beginTransaction("readonly"); return Object.keys(this.getDirListing(r, t, this.findINode(r, t))) }, r.prototype._syncSync = function (t, r, e) { var n = this.store.beginTransaction("readwrite"), o = this._findINode(n, At.dirname(t), At.basename(t)), i = this.getINode(n, t, o), s = i.update(e); try { n.put(i.id, r, !0), s && n.put(o, i.toBuffer(), !0) } catch (t) { throw n.abort(), t } n.commit() }, r.prototype.makeRootDirectory = function () { var t = this.store.beginTransaction("readwrite"); if (void 0 === t.get("/")) { var r = (new Date).getTime(), e = new Tr.default(s(), 4096, 511 | Sr.FileType.DIRECTORY, r, r, r); t.put(e.id, i(), !1), t.put("/", e.toBuffer(), !1), t.commit() } }, r.prototype._findINode = function (t, r, e) { var n = this, o = function (o) { var i = n.getDirListing(t, r, o); if (i[e]) return i[e]; throw lr.ApiError.ENOENT(At.resolve(r, e)) }; return "/" === r ? "" === e ? "/" : o(this.getINode(t, r, "/")) : o(this.getINode(t, r + At.sep + e, this._findINode(t, At.dirname(r), At.basename(r)))) }, r.prototype.findINode = function (t, r) { return this.getINode(t, r, this._findINode(t, At.dirname(r), At.basename(r))) }, r.prototype.getINode = function (t, r, e) { var n = t.get(e); if (void 0 === n) throw lr.ApiError.ENOENT(r); return Tr.default.fromBuffer(n) }, r.prototype.getDirListing = function (t, r, e) { if (!e.isDirectory()) throw lr.ApiError.ENOTDIR(r); var n = t.get(e.id); if (void 0 === n) throw lr.ApiError.ENOENT(r); return JSON.parse(n.toString()) }, r.prototype.addNewNode = function (t, r) { for (var e; ;)try { return e = s(), t.put(e, r, !1), e } catch (t) { } throw new lr.ApiError(lr.ErrorCode.EIO, "Unable to commit data to key-value store.") }, r.prototype.commitNewFile = function (t, r, e, n, o) { var i, s = At.dirname(r), u = At.basename(r), a = this.findINode(t, s), f = this.getDirListing(t, s, a), c = (new Date).getTime(); if ("/" === r) throw lr.ApiError.EEXIST(r); if (f[u]) throw lr.ApiError.EEXIST(r); try { var p = this.addNewNode(t, o); i = new Tr.default(p, o.length, n | e, c, c, c); var h = this.addNewNode(t, i.toBuffer()); f[u] = h, t.put(a.id, Buffer.from(JSON.stringify(f)), !0) } catch (r) { throw t.abort(), r } return t.commit(), i }, r.prototype.removeEntry = function (t, r) { var e = this.store.beginTransaction("readwrite"), n = At.dirname(t), o = this.findINode(e, n), i = this.getDirListing(e, n, o), s = At.basename(t); if (!i[s]) throw lr.ApiError.ENOENT(t); var u = i[s]; delete i[s]; var a = this.getINode(e, t, u); if (!r && a.isDirectory()) throw lr.ApiError.EISDIR(t); if (r && !a.isDirectory()) throw lr.ApiError.ENOTDIR(t); try { e.del(a.id), e.del(u), e.put(o.id, Buffer.from(JSON.stringify(i)), !0) } catch (t) { throw e.abort(), t } e.commit() }, r }(wr.SynchronousFileSystem); r.SyncKeyValueFileSystem = p; var h = function (t) { function r (r, e, n, o, i) { return t.call(this, r, e, n, o, i) || this } return n(r, t), r.prototype.sync = function (t) { var r = this; this.isDirty() ? this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (function (e) { e || r.resetDirty(), t(e) })) : t() }, r.prototype.close = function (t) { this.sync(t) }, r }(Pr.default); r.AsyncKeyValueFile = h; var l = function (t) { function r () { return null !== t && t.apply(this, arguments) || this } return n(r, t), r.isAvailable = function () { return !0 }, r.prototype.init = function (t, r) { this.store = t, this.makeRootDirectory(r) }, r.prototype.getName = function () { return this.store.name() }, r.prototype.isReadOnly = function () { return !1 }, r.prototype.supportsSymlinks = function () { return !1 }, r.prototype.supportsProps = function () { return !1 }, r.prototype.supportsSynch = function () { return !1 }, r.prototype.empty = function (t) { var r = this; this.store.clear((function (e) { u(e, t) && r.makeRootDirectory(t) })) }, r.prototype.rename = function (t, r, e) { var n = this, o = this.store.beginTransaction("readwrite"), i = At.dirname(t), s = At.basename(t), u = At.dirname(r), f = At.basename(r), c = {}, p = {}, h = !1; if (0 === (u + "/").indexOf(t + "/")) return e(new lr.ApiError(lr.ErrorCode.EBUSY, i)); var l = function (l) { n.findINodeAndDirListing(o, l, (function (y, d, E) { y ? h || (h = !0, o.abort((function () { e(y) }))) : (c[l] = d, p[l] = E, function () { if (!h && p.hasOwnProperty(i) && p.hasOwnProperty(u)) { var l = p[i], y = c[i], d = p[u], E = c[u]; if (l[s]) { var g = l[s]; delete l[s]; var m = function () { d[f] = g, o.put(y.id, Buffer.from(JSON.stringify(l)), !0, (function (t) { a(t, o, e) && (i === u ? o.commit(e) : o.put(E.id, Buffer.from(JSON.stringify(d)), !0, (function (t) { a(t, o, e) && o.commit(e) }))) })) }; d[f] ? n.getINode(o, r, d[f], (function (t, n) { a(t, o, e) && (n.isFile() ? o.del(n.id, (function (t) { a(t, o, e) && o.del(d[f], (function (t) { a(t, o, e) && m() })) })) : o.abort((function (t) { e(lr.ApiError.EPERM(r)) }))) })) : m() } else e(lr.ApiError.ENOENT(t)) } }()) })) }; l(i), i !== u && l(u) }, r.prototype.stat = function (t, r, e) { var n = this.store.beginTransaction("readonly"); this.findINode(n, t, (function (t, r) { u(t, e) && e(null, r.toStats()) })) }, r.prototype.createFile = function (t, r, e, n) { var o = this, i = this.store.beginTransaction("readwrite"), s = mr.emptyBuffer(); this.commitNewFile(i, t, Sr.FileType.FILE, e, s, (function (e, i) { u(e, n) && n(null, new h(o, t, r, i.toStats(), s)) })) }, r.prototype.openFile = function (t, r, e) { var n = this, o = this.store.beginTransaction("readonly"); this.findINode(o, t, (function (i, s) { u(i, e) && o.get(s.id, (function (o, i) { u(o, e) && (void 0 === i ? e(lr.ApiError.ENOENT(t)) : e(null, new h(n, t, r, s.toStats(), i))) })) })) }, r.prototype.unlink = function (t, r) { this.removeEntry(t, !1, r) }, r.prototype.rmdir = function (t, r) { var e = this; this.readdir(t, (function (n, o) { n ? r(n) : o.length > 0 ? r(lr.ApiError.ENOTEMPTY(t)) : e.removeEntry(t, !0, r) })) }, r.prototype.mkdir = function (t, r, e) { var n = this.store.beginTransaction("readwrite"), o = Buffer.from("{}"); this.commitNewFile(n, t, Sr.FileType.DIRECTORY, r, o, e) }, r.prototype.readdir = function (t, r) { var e = this, n = this.store.beginTransaction("readonly"); this.findINode(n, t, (function (o, i) { u(o, r) && e.getDirListing(n, t, i, (function (t, e) { u(t, r) && r(null, Object.keys(e)) })) })) }, r.prototype._sync = function (t, r, e, n) { var o = this, i = this.store.beginTransaction("readwrite"); this._findINode(i, At.dirname(t), At.basename(t), (function (s, u) { a(s, i, n) && o.getINode(i, t, u, (function (t, o) { if (a(t, i, n)) { var s = o.update(e); i.put(o.id, r, !0, (function (t) { a(t, i, n) && (s ? i.put(u, o.toBuffer(), !0, (function (t) { a(t, i, n) && i.commit(n) })) : i.commit(n)) })) } })) })) }, r.prototype.makeRootDirectory = function (t) { var r = this.store.beginTransaction("readwrite"); r.get("/", (function (e, n) { if (e || void 0 === n) { var o = (new Date).getTime(), u = new Tr.default(s(), 4096, 511 | Sr.FileType.DIRECTORY, o, o, o); r.put(u.id, i(), !1, (function (e) { a(e, r, t) && r.put("/", u.toBuffer(), !1, (function (e) { e ? r.abort((function () { t(e) })) : r.commit(t) })) })) } else r.commit(t) })) }, r.prototype._findINode = function (t, r, e, n) { var o = this, i = function (t, o, i) { t ? n(t) : i[e] ? n(null, i[e]) : n(lr.ApiError.ENOENT(At.resolve(r, e))) }; "/" === r ? "" === e ? n(null, "/") : this.getINode(t, r, "/", (function (e, s) { u(e, n) && o.getDirListing(t, r, s, (function (t, r) { i(t, 0, r) })) })) : this.findINodeAndDirListing(t, r, i) }, r.prototype.findINode = function (t, r, e) { var n = this; this._findINode(t, At.dirname(r), At.basename(r), (function (o, i) { u(o, e) && n.getINode(t, r, i, e) })) }, r.prototype.getINode = function (t, r, e, n) { t.get(e, (function (t, e) { u(t, n) && (void 0 === e ? n(lr.ApiError.ENOENT(r)) : n(null, Tr.default.fromBuffer(e))) })) }, r.prototype.getDirListing = function (t, r, e, n) { e.isDirectory() ? t.get(e.id, (function (t, e) { if (u(t, n)) try { n(null, JSON.parse(e.toString())) } catch (t) { n(lr.ApiError.ENOENT(r)) } })) : n(lr.ApiError.ENOTDIR(r)) }, r.prototype.findINodeAndDirListing = function (t, r, e) { var n = this; this.findINode(t, r, (function (o, i) { u(o, e) && n.getDirListing(t, r, i, (function (t, r) { u(t, e) && e(null, i, r) })) })) }, r.prototype.addNewNode = function (t, r, e) { var n, o = 0, i = function () { 5 == ++o ? e(new lr.ApiError(lr.ErrorCode.EIO, "Unable to commit data to key-value store.")) : (n = s(), t.put(n, r, !1, (function (t, r) { t || !r ? i() : e(null, n) }))) }; i() }, r.prototype.commitNewFile = function (t, r, e, n, o, i) { var s = this, u = At.dirname(r), f = At.basename(r), c = (new Date).getTime(); if ("/" === r) return i(lr.ApiError.EEXIST(r)); this.findINodeAndDirListing(t, u, (function (u, p, h) { a(u, t, i) && (h[f] ? t.abort((function () { i(lr.ApiError.EEXIST(r)) })) : s.addNewNode(t, o, (function (r, u) { if (a(r, t, i)) { var l = new Tr.default(u, o.length, n | e, c, c, c); s.addNewNode(t, l.toBuffer(), (function (r, e) { a(r, t, i) && (h[f] = e, t.put(p.id, Buffer.from(JSON.stringify(h)), !0, (function (r) { a(r, t, i) && t.commit((function (r) { a(r, t, i) && i(null, l) })) }))) })) } }))) })) }, r.prototype.removeEntry = function (t, r, e) { var n = this, o = this.store.beginTransaction("readwrite"), i = At.dirname(t), s = At.basename(t); this.findINodeAndDirListing(o, i, (function (i, u, f) { if (a(i, o, e)) if (f[s]) { var c = f[s]; delete f[s], n.getINode(o, t, c, (function (n, i) { a(n, o, e) && (!r && i.isDirectory() ? o.abort((function () { e(lr.ApiError.EISDIR(t)) })) : r && !i.isDirectory() ? o.abort((function () { e(lr.ApiError.ENOTDIR(t)) })) : o.del(i.id, (function (t) { a(t, o, e) && o.del(c, (function (t) { a(t, o, e) && o.put(u.id, Buffer.from(JSON.stringify(f)), !0, (function (t) { a(t, o, e) && o.commit(e) })) })) }))) })) } else o.abort((function () { e(lr.ApiError.ENOENT(t)) })) })) }, r }(wr.BaseFileSystem); r.AsyncKeyValueFileSystem = l })); pr(Rr), Rr.SimpleSyncRWTransaction, Rr.SyncKeyValueFile, Rr.SyncKeyValueFileSystem, Rr.AsyncKeyValueFile, Rr.AsyncKeyValueFileSystem; var Lr = hr((function (t, r) { var e, n = cr && cr.__extends || (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, r) { t.__proto__ = r } || function (t, r) { for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]) }, function (t, r) { function n () { this.constructor = t } e(t, r), t.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n) }); r.__esModule = !0; var o = function () { function t () { this.store = {} } return t.prototype.name = function () { return i.Name }, t.prototype.clear = function () { this.store = {} }, t.prototype.beginTransaction = function (t) { return new Rr.SimpleSyncRWTransaction(this) }, t.prototype.get = function (t) { return this.store[t] }, t.prototype.put = function (t, r, e) { return !(!e && this.store.hasOwnProperty(t)) && (this.store[t] = r, !0) }, t.prototype.del = function (t) { delete this.store[t] }, t }(); r.InMemoryStore = o; var i = function (t) { function r () { return t.call(this, { store: new o }) || this } return n(r, t), r.Create = function (t, e) { e(null, new r) }, r }(Rr.SyncKeyValueFileSystem); i.Name = "InMemory", i.Options = {}, r.default = i })), Dr = pr(Lr); Lr.InMemoryStore; var Br = hr((function (t, r) { r.endianness = function () { return "LE" }, r.hostname = function () { return "undefined" != typeof location ? location.hostname : "" }, r.loadavg = function () { return [] }, r.uptime = function () { return 0 }, r.freemem = function () { return Number.MAX_VALUE }, r.totalmem = function () { return Number.MAX_VALUE }, r.cpus = function () { return [] }, r.type = function () { return "Browser" }, r.release = function () { return "undefined" != typeof navigator ? navigator.appVersion : "" }, r.networkInterfaces = r.getNetworkInterfaces = function () { return {} }, r.arch = function () { return "javascript" }, r.platform = function () { return "browser" }, r.tmpdir = r.tmpDir = function () { return "/tmp" }, r.EOL = "\n", r.homedir = function () { return "/" } })), kr = Br.endianness, Ur = Br.hostname, xr = Br.loadavg, Mr = Br.uptime, Yr = Br.freemem, jr = Br.totalmem, Vr = Br.cpus, zr = Br.type, Wr = Br.release, Xr = Br.networkInterfaces, Kr = Br.getNetworkInterfaces, Jr = Br.arch, Hr = Br.platform, qr = Br.tmpdir, Gr = Br.tmpDir, $r = Br.EOL, Zr = Br.homedir, Qr = Object.freeze(t({ __proto__: null, default: Br, __moduleExports: Br, endianness: kr, hostname: Ur, loadavg: xr, uptime: Mr, freemem: Yr, totalmem: jr, cpus: Vr, type: zr, release: Wr, networkInterfaces: Xr, getNetworkInterfaces: Kr, arch: Jr, platform: Hr, tmpdir: qr, tmpDir: Gr, EOL: $r, homedir: Zr }, [Br])); class te extends Cr { constructor(t, r, e, n, o) { super(t, r, e, n, o) } sync (t) { if (this.isDirty()) { const r = this.getBuffer(); this._fs._sync(this.getPath(), r, (r, e) => { r || this.resetDirty(), t(r) }) } else t() } close (t) { this.sync(t) } syncSync () { this.isDirty() && (this._fs._syncSync(this.getPath(), this.getBuffer()), this.resetDirty()) } closeSync () { this.syncSync() } } class re extends vr { constructor(t) { super(), this.baseFS = t.baseFS, this.omitValueOnEvent = t.omitValueOnEvent } static Create (t, r) { r(null, new re(t)) } static isAvailable () { return !0 } getName () { return "VirtualFS" } isReadOnly () { return !1 } supportsProps () { return !1 } supportsSynch () { return !0 } empty (t) { const r = this.baseFS.getFiles(); Object.keys(r).forEach(t => { const e = r[t]; this.baseFS.removeFile(e.path) }), t() } renameSync (t, r) { const e = this.baseFS.getFiles(), n = Object.keys(e).filter(r => r.startsWith(t) + "/" || r === t); if (0 === n.length) throw dr.FileError(yr.ENOENT, t); n.map(t => ({ path: t, file: e[t] })).forEach(({ path: e, file: n }) => { this.baseFS.moveFile(n.path, e.replace(t, r)) }) } statSync (t, r) { const e = this.baseFS.getFiles(), n = e[t]; if (!n) { if (Object.keys(e).filter(r => r.startsWith(t.endsWith("/") ? t : t + "/") || r === t).length > 0) return new br(Ar.DIRECTORY, 0); throw dr.FileError(yr.ENOENT, t) } return new br(Ar.FILE, ((null == n ? void 0 : n.value) || "").length) } createFileSync (t, r, e) { if ("/" === t) throw dr.EEXIST(t); if (this.baseFS.getFiles()[t]) throw dr.EEXIST(t); this.baseFS.addFile(t); const n = Buffer.from(""), o = new br(Ar.FILE, n.length); return new te(this, t, r, o, n) } openFileSync (t, r, e) { const n = this.baseFS.getFiles()[t]; if (!n) throw dr.ENOENT(t); const o = n.value || "", i = Buffer.from(o), s = new br(Ar.FILE, i.length); return new te(this, t, r, s, i) } rmdirSync (t) { const r = this.baseFS.getFiles(); Object.keys(r).filter(r => r.startsWith(t + "/") || t === r).forEach(t => { const e = r[t]; this.baseFS.removeFile(e.path) }) } mkdirSync (t) { console.warn("mkdir [not implemented]", t) } readdirSync (t) { const r = Object.keys(this.baseFS.getFiles()), e = t.endsWith("/") ? t : t + "/", n = r.filter(t => t.startsWith(e)); if (0 === n.length) return []; const o = new Set, i = e.split("/").length; return n.filter(t => t.split("/").length >= i).forEach(t => { const r = t.split("/"); r.length = i, o.add(r.join("/")) }), Array.from(o).map(t => t.replace(e, "")) } _sync (t, r, e) { const n = vt(t); this.stat(n, !1, (o, i) => { if (o) e(dr.FileError(yr.ENOENT, n)); else { const n = this.baseFS.getFiles()[t]; this.omitValueOnEvent ? this.baseFS.updateFile(n.path, void 0) : this.baseFS.updateFile(n.path, r), e(null) } }) } _syncSync (t, r) { const e = vt(t); this.statSync(e, !1); const n = this.baseFS.getFiles()[t]; n && (this.omitValueOnEvent ? this.baseFS.updateFile(n.path, void 0) : this.baseFS.updateFile(n.path, r)) } unlinkSync (t) { const r = this.baseFS.getFiles()[t]; if (!r) throw dr.ENOENT(t); this.baseFS.removeFile(r.path) } watch (t, r, e) { if (!this.baseFS.getFiles()[t]) throw dr.ENOENT(t); return "function" == typeof r ? this.baseFS.watch(t, r) : this.baseFS.watch(t, e) } unwatchFile (t, r) { console.warn("unwatchFile: not implemented") } } re.Name = "VirtualFS", re.Options = { baseFS: { type: "object", description: "Base file system", validator: (t, r) => { t ? r() : r(new dr(yr.EINVAL, "Base FS is invalid")) } }, omitValueOnEvent: { type: "boolean", description: "Omit value on event", validator: (t, r) => { r() } } }; const ee = Object.getOwnPropertyDescriptors || function (t) { const r = Object.keys(t), e = {}; for (let n = 0; n < r.length; n++)e[r[n]] = Object.getOwnPropertyDescriptor(t, r[n]); return e }, ne = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0; function oe (t) { if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function'); if (ne && t[ne]) { const r = t[ne]; if ("function" != typeof r) throw new TypeError('The "util.promisify.custom" argument must be of type Function'); return Object.defineProperty(r, ne, { value: r, enumerable: !1, writable: !1, configurable: !0 }), r } function r () { let r, e; const n = new Promise((function (t, n) { r = t, e = n })), o = []; for (let t = 0; t < arguments.length; t++)o.push(arguments[t]); o.push((function (t, n) { 1 !== arguments.length || t instanceof Error ? t ? e(t) : r(n) : r(t) })); try { t.apply(this, o) } catch (t) { e(t) } return n } return Object.setPrototypeOf(r, Object.getPrototypeOf(t)), ne && Object.defineProperty(r, ne, { value: r, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(r, ee(t)) } oe.custom = ne; const ie = "undefined" != typeof window ? (se = window, new Proxy(se, { get (t, r, e) { const n = Symbol.for("__" + r + "__"); if (n) return t[n] }, set: (t, r, e) => t[Symbol.for("__" + r + "__")] = e })) : {}; var se; return { FS: Fr, backends: { InMemory: Dr, VirtualFS: re }, polyFills: { path: Ot, buffer: Q, process: fr, os: Qr, events: { EventEmitter: rt } }, plugins: {}, BFSRequire: function (t) { var r; switch (t) { case "fs": return Ir; case "fs/promises": return Ir.promises; case "path": return Object.assign(Object.assign({}, Ot), { posix: Ot }); case "buffer": return Q; case "process": const e = Object.assign({}, fr); return e.versions.node = "16.14.0", e; case "events": return rt; case "os": return Qr; default: ie.startedPackages || (ie.startedPackages = new Map); const n = ie.startedPackages, o = null === (r = ie.modules) || void 0 === r ? void 0 : r[t]; if (o) { if (n.has(t)) return n.get(t); { const r = o(window); return n.set(t, r), r } } throw new Error(`Module "${t}" does not exist`) } }, initialize: function (t) { ie.startedPackages = new Map; const r = Ir.initialize(t); var e; return (e = Ir).promises = { access: oe(e.access), appendFile: oe(e.appendFile), chmod: oe(e.chmod), chown: oe(e.chown), readdir: oe(e.readdir), readFile: oe(e.readFile), readlink: oe(e.readlink), realpath: oe(e.realpath), rename: oe(e.rename), rmdir: oe(e.rmdir), stat: oe(e.stat), symlink: oe(e.symlink), truncate: oe(e.truncate), unlink: oe(e.unlink), utimes: oe(e.utimes), writeFile: oe(e.writeFile) }, r } } }(); window.process = { env: { NODE_ENV: 'development' }, nextTick: function (cb) { return requestAnimationFrame(cb); }, browser: false, once: __bfs__.BFSRequire('process').once, }; window.path = __bfs__.BFSRequire('path'); window.fs = __bfs__.BFSRequire('fs'); window.events = __bfs__.BFSRequire('events'); window.os = __bfs__.BFSRequire('os'); window.process = __bfs__.BFSRequire('process'); window.process.stdout = { isTTY: true }; window.buffer = __bfs__.BFSRequire('buffer'); window.buffer.hasOwnProperty = () => true; window.Buffer = window.buffer.Buffer; window.require = __bfs__.BFSRequire; window.__filename = '/index.js'; window.__dirname = '/'; __bfs__.backends.InMemory.Create({}, (e, inMemory) => { if (e) { console.error(e); return; }; __bfs__.initialize(inMemory); });</script>
</head>

<body>
  <h1 id="header"></h1>

  <script path="/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod'] = (window) => {
      var __dependency__ = (() => {
        var Lt = Object.defineProperty; var Lr = Object.getOwnPropertyDescriptor; var Nr = Object.getOwnPropertyNames; var Dr = Object.prototype.hasOwnProperty; var qr = (Y, e, r) => e in Y ? Lt(Y, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : Y[e] = r; var F = (Y, e) => Lt(Y, "name", { value: e, configurable: !0 }); var Or = (Y, e) => { for (var r in e) Lt(Y, r, { get: e[r], enumerable: !0 }) }, Ur = (Y, e, r, t) => { if (e && typeof e == "object" || typeof e == "function") for (let a of Nr(e)) !Dr.call(Y, a) && a !== r && Lt(Y, a, { get: () => e[a], enumerable: !(t = Lr(e, a)) || t.enumerable }); return Y }; var Wr = Y => Ur(Lt({}, "__esModule", { value: !0 }), Y); var N = (Y, e, r) => (qr(Y, typeof e != "symbol" ? e + "" : e, r), r); var ds = {}; Or(ds, { AlphaTimeline: () => Ze, Animation: () => Ce, AnimationState: () => Ot, AnimationStateAdapter: () => ir, AnimationStateData: () => lr, AssetManagerBase: () => dr, AtlasAttachmentLoader: () => cr, Attachment: () => vt, AttachmentTimeline: () => me, BinaryInput: () => jt, BlendMode: () => Pt, Bone: () => St, BoneData: () => ft, BoundingBoxAttachment: () => Ae, CURRENT: () => Vr, ClippingAttachment: () => ot, Color: () => D, ConstraintData: () => Xe, CurveTimeline: () => he, CurveTimeline1: () => ce, CurveTimeline2: () => Yt, DebugUtils: () => er, DeformTimeline: () => rt, Downloader: () => _t, DrawOrderTimeline: () => fe, Event: () => mt, EventData: () => ut, EventQueue: () => Wt, EventTimeline: () => ve, EventType: () => oe, FIRST: () => Ir, FakeTexture: () => or, HOLD_FIRST: () => nr, HOLD_MIX: () => Pr, HOLD_SUBSEQUENT: () => Sr, IkConstraint: () => Et, IkConstraintData: () => gt, IkConstraintTimeline: () => st, IntSet: () => Qt, Interpolation: () => Nt, MathUtils: () => E, MeshAttachment: () => ue, MixBlend: () => C, MixDirection: () => ne, PathAttachment: () => ge, PathConstraint: () => Ee, PathConstraintData: () => xt, PathConstraintMixTimeline: () => lt, PathConstraintPositionTimeline: () => at, PathConstraintSpacingTimeline: () => nt, PointAttachment: () => dt, Pool: () => be, PositionMode: () => de, Pow: () => Dt, PowOut: () => Zt, RGB2Timeline: () => tt, RGBA2Timeline: () => et, RGBATimeline: () => Ke, RGBTimeline: () => Qe, RegionAttachment: () => $, RotateMode: () => Fe, RotateTimeline: () => Ye, SETUP: () => kr, SUBSEQUENT: () => ar, ScaleTimeline: () => $e, ScaleXTimeline: () => He, ScaleYTimeline: () => _e, SequenceTimeline: () => ye, ShearTimeline: () => Ge, ShearXTimeline: () => je, ShearYTimeline: () => Je, Skeleton: () => Gt, SkeletonBinary: () => fr, SkeletonBounds: () => gr, SkeletonClipping: () => kt, SkeletonData: () => pt, SkeletonJson: () => xr, Skin: () => Pe, SkinEntry: () => Rt, Slot: () => Tt, SlotData: () => wt, SpacingMode: () => ee, StringSet: () => qe, Texture: () => $t, TextureAtlas: () => Mt, TextureAtlasPage: () => Ht, TextureAtlasRegion: () => It, TextureFilter: () => ht, TextureRegion: () => Ft, TextureWrap: () => ct, TimeKeeper: () => tr, Timeline: () => Z, TrackEntry: () => Ut, TransformConstraint: () => Bt, TransformConstraintData: () => bt, TransformConstraintTimeline: () => it, TransformMode: () => ie, TranslateTimeline: () => Ue, TranslateXTimeline: () => We, TranslateYTimeline: () => ze, Triangulator: () => se, Utils: () => V, Vector2: () => Be, VertexAttachment: () => te, WindowedMean: () => rr }); var Qt = class { array = new Array; add (e) { let r = this.contains(e); return this.array[e | 0] = e | 0, !r } contains (e) { return this.array[e | 0] != null } remove (e) { this.array[e | 0] = void 0 } clear () { this.array.length = 0 } }; F(Qt, "IntSet"); var qe = class { entries = {}; size = 0; add (e) { let r = this.entries[e]; return this.entries[e] = !0, r ? !1 : (this.size++, !0) } addAll (e) { let r = this.size; for (var t = 0, a = e.length; t < a; t++)this.add(e[t]); return r != this.size } contains (e) { return this.entries[e] } clear () { this.entries = {}, this.size = 0 } }; F(qe, "StringSet"); var De = class { r; g; b; a; constructor(e = 0, r = 0, t = 0, a = 0) { this.r = e, this.g = r, this.b = t, this.a = a } set (e, r, t, a) { return this.r = e, this.g = r, this.b = t, this.a = a, this.clamp() } setFromColor (e) { return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this } setFromString (e) { return e = e.charAt(0) == "#" ? e.substr(1) : e, this.r = parseInt(e.substr(0, 2), 16) / 255, this.g = parseInt(e.substr(2, 2), 16) / 255, this.b = parseInt(e.substr(4, 2), 16) / 255, this.a = e.length != 8 ? 1 : parseInt(e.substr(6, 2), 16) / 255, this } add (e, r, t, a) { return this.r += e, this.g += r, this.b += t, this.a += a, this.clamp() } clamp () { return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this } static rgba8888ToColor (e, r) { e.r = ((r & 4278190080) >>> 24) / 255, e.g = ((r & 16711680) >>> 16) / 255, e.b = ((r & 65280) >>> 8) / 255, e.a = (r & 255) / 255 } static rgb888ToColor (e, r) { e.r = ((r & 16711680) >>> 16) / 255, e.g = ((r & 65280) >>> 8) / 255, e.b = (r & 255) / 255 } static fromString (e) { return new De().setFromString(e) } }, D = De; F(D, "Color"), N(D, "WHITE", new De(1, 1, 1, 1)), N(D, "RED", new De(1, 0, 0, 1)), N(D, "GREEN", new De(0, 1, 0, 1)), N(D, "BLUE", new De(0, 0, 1, 1)), N(D, "MAGENTA", new De(1, 0, 1, 1)); var ke = class { static clamp (e, r, t) { return e < r ? r : e > t ? t : e } static cosDeg (e) { return Math.cos(e * ke.degRad) } static sinDeg (e) { return Math.sin(e * ke.degRad) } static signum (e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } static toInt (e) { return e > 0 ? Math.floor(e) : Math.ceil(e) } static cbrt (e) { let r = Math.pow(Math.abs(e), .3333333333333333); return e < 0 ? -r : r } static randomTriangular (e, r) { return ke.randomTriangularWith(e, r, (e + r) * .5) } static randomTriangularWith (e, r, t) { let a = Math.random(), i = r - e; return a <= (t - e) / i ? e + Math.sqrt(a * i * (t - e)) : r - Math.sqrt((1 - a) * i * (r - t)) } static isPowerOfTwo (e) { return e && (e & e - 1) === 0 } }, E = ke; F(E, "MathUtils"), N(E, "PI", 3.1415927), N(E, "PI2", ke.PI * 2), N(E, "radiansToDegrees", 180 / ke.PI), N(E, "radDeg", ke.radiansToDegrees), N(E, "degreesToRadians", ke.PI / 180), N(E, "degRad", ke.degreesToRadians); var Nt = class { apply (e, r, t) { return e + (r - e) * this.applyInternal(t) } }; F(Nt, "Interpolation"); var Dt = class extends Nt { power = 2; constructor(e) { super(), this.power = e } applyInternal (e) { return e <= .5 ? Math.pow(e * 2, this.power) / 2 : Math.pow((e - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1 } }; F(Dt, "Pow"); var Zt = class extends Dt { constructor(e) { super(e) } applyInternal (e) { return Math.pow(e - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1 } }; F(Zt, "PowOut"); var yt = class { static arrayCopy (e, r, t, a, i) { for (let c = r, o = a; c < r + i; c++, o++)t[o] = e[c] } static arrayFill (e, r, t, a) { for (let i = r; i < t; i++)e[i] = a } static setArraySize (e, r, t = 0) { let a = e.length; if (a == r) return e; if (e.length = r, a < r) for (let i = a; i < r; i++)e[i] = t; return e } static ensureArrayCapacity (e, r, t = 0) { return e.length >= r ? e : yt.setArraySize(e, r, t) } static newArray (e, r) { let t = new Array(e); for (let a = 0; a < e; a++)t[a] = r; return t } static newFloatArray (e) { if (yt.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e); { let r = new Array(e); for (let t = 0; t < r.length; t++)r[t] = 0; return r } } static newShortArray (e) { if (yt.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e); { let r = new Array(e); for (let t = 0; t < r.length; t++)r[t] = 0; return r } } static toFloatArray (e) { return yt.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e } static toSinglePrecision (e) { return yt.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e } static webkit602BugfixHelper (e, r) { } static contains (e, r, t = !0) { for (var a = 0; a < e.length; a++)if (e[a] == r) return !0; return !1 } static enumValue (e, r) { return e[r[0].toUpperCase() + r.slice(1)] } }, V = yt; F(V, "Utils"), N(V, "SUPPORTS_TYPED_ARRAYS", typeof Float32Array < "u"); var er = class { static logBones (e) { for (let r = 0; r < e.bones.length; r++) { let t = e.bones[r]; console.log(t.data.name + ", " + t.a + ", " + t.b + ", " + t.c + ", " + t.d + ", " + t.worldX + ", " + t.worldY) } } }; F(er, "DebugUtils"); var be = class { items = new Array; instantiator; constructor(e) { this.instantiator = e } obtain () { return this.items.length > 0 ? this.items.pop() : this.instantiator() } free (e) { e.reset && e.reset(), this.items.push(e) } freeAll (e) { for (let r = 0; r < e.length; r++)this.free(e[r]) } clear () { this.items.length = 0 } }; F(be, "Pool"); var Be = class { x; y; constructor(e = 0, r = 0) { this.x = e, this.y = r } set (e, r) { return this.x = e, this.y = r, this } length () { let e = this.x, r = this.y; return Math.sqrt(e * e + r * r) } normalize () { let e = this.length(); return e != 0 && (this.x /= e, this.y /= e), this } }; F(Be, "Vector2"); var tr = class { maxDelta = .064; framesPerSecond = 0; delta = 0; totalTime = 0; lastTime = Date.now() / 1e3; frameCount = 0; frameTime = 0; update () { let e = Date.now() / 1e3; this.delta = e - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = e, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0) } }; F(tr, "TimeKeeper"); var rr = class { values; addedValues = 0; lastValue = 0; mean = 0; dirty = !0; constructor(e = 32) { this.values = new Array(e) } hasEnoughData () { return this.addedValues >= this.values.length } addValue (e) { this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = e, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0 } getMean () { if (this.hasEnoughData()) { if (this.dirty) { let e = 0; for (let r = 0; r < this.values.length; r++)e += this.values[r]; this.mean = e / this.values.length, this.dirty = !1 } return this.mean } return 0 } }; F(rr, "WindowedMean"); var vt = class { name; constructor(e) { if (!e) throw new Error("name cannot be null."); this.name = e } }; F(vt, "Attachment"); var yr = class extends vt { id = yr.nextID++; bones = null; vertices = []; worldVerticesLength = 0; timelineAttachment = this; constructor(e) { super(e) } computeWorldVertices (e, r, t, a, i, c) { t = i + (t >> 1) * c; let o = e.bone.skeleton, s = e.deform, l = this.vertices, n = this.bones; if (!n) { s.length > 0 && (l = s); let m = e.bone, x = m.worldX, p = m.worldY, b = m.a, y = m.b, u = m.c, g = m.d; for (let w = r, v = i; v < t; w += 2, v += c) { let I = l[w], S = l[w + 1]; a[v] = I * b + S * y + x, a[v + 1] = I * u + S * g + p } return } let h = 0, d = 0; for (let m = 0; m < r; m += 2) { let x = n[h]; h += x + 1, d += x } let f = o.bones; if (s.length == 0) for (let m = i, x = d * 3; m < t; m += c) { let p = 0, b = 0, y = n[h++]; for (y += h; h < y; h++, x += 3) { let u = f[n[h]], g = l[x], w = l[x + 1], v = l[x + 2]; p += (g * u.a + w * u.b + u.worldX) * v, b += (g * u.c + w * u.d + u.worldY) * v } a[m] = p, a[m + 1] = b } else { let m = s; for (let x = i, p = d * 3, b = d << 1; x < t; x += c) { let y = 0, u = 0, g = n[h++]; for (g += h; h < g; h++, p += 3, b += 2) { let w = f[n[h]], v = l[p] + m[b], I = l[p + 1] + m[b + 1], S = l[p + 2]; y += (v * w.a + I * w.b + w.worldX) * S, u += (v * w.c + I * w.d + w.worldY) * S } a[x] = y, a[x + 1] = u } } } copyTo (e) { this.bones ? (e.bones = new Array(this.bones.length), V.arrayCopy(this.bones, 0, e.bones, 0, this.bones.length)) : e.bones = null, this.vertices && (e.vertices = V.newFloatArray(this.vertices.length), V.arrayCopy(this.vertices, 0, e.vertices, 0, this.vertices.length)), e.worldVerticesLength = this.worldVerticesLength, e.timelineAttachment = this.timelineAttachment } }, te = yr; F(te, "VertexAttachment"), N(te, "nextID", 0); var qt = class { id = qt.nextID(); regions; start = 0; digits = 0; setupIndex = 0; constructor(e) { this.regions = new Array(e) } copy () { let e = new qt(this.regions.length); return V.arrayCopy(this.regions, 0, e.regions, 0, this.regions.length), e.start = this.start, e.digits = this.digits, e.setupIndex = this.setupIndex, e } apply (e, r) { let t = e.sequenceIndex; t == -1 && (t = this.setupIndex), t >= this.regions.length && (t = this.regions.length - 1); let a = this.regions[t]; r.region != a && (r.region = a, r.updateRegion()) } getPath (e, r) { let t = e, a = (this.start + r).toString(); for (let i = this.digits - a.length; i > 0; i--)t += "0"; return t += a, t } static nextID () { return qt._nextID++ } }, Oe = qt; F(Oe, "Sequence"), N(Oe, "_nextID", 0); var re; (function (Y) { Y[Y.hold = 0] = "hold", Y[Y.once = 1] = "once", Y[Y.loop = 2] = "loop", Y[Y.pingpong = 3] = "pingpong", Y[Y.onceReverse = 4] = "onceReverse", Y[Y.loopReverse = 5] = "loopReverse", Y[Y.pingpongReverse = 6] = "pingpongReverse" })(re || (re = {})); var sr = [re.hold, re.once, re.loop, re.pingpong, re.onceReverse, re.loopReverse, re.pingpongReverse]; var Ce = class { name; timelines = []; timelineIds = new qe; duration; constructor(e, r, t) { if (!e) throw new Error("name cannot be null."); this.name = e, this.setTimelines(r), this.duration = t } setTimelines (e) { if (!e) throw new Error("timelines cannot be null."); this.timelines = e, this.timelineIds.clear(); for (var r = 0; r < e.length; r++)this.timelineIds.addAll(e[r].getPropertyIds()) } hasTimeline (e) { for (let r = 0; r < e.length; r++)if (this.timelineIds.contains(e[r])) return !0; return !1 } apply (e, r, t, a, i, c, o, s) { if (!e) throw new Error("skeleton cannot be null."); a && this.duration != 0 && (t %= this.duration, r > 0 && (r %= this.duration)); let l = this.timelines; for (let n = 0, h = l.length; n < h; n++)l[n].apply(e, r, t, i, c, o, s) } }; F(Ce, "Animation"); var C; (function (Y) { Y[Y.setup = 0] = "setup", Y[Y.first = 1] = "first", Y[Y.replace = 2] = "replace", Y[Y.add = 3] = "add" })(C || (C = {})); var ne; (function (Y) { Y[Y.mixIn = 0] = "mixIn", Y[Y.mixOut = 1] = "mixOut" })(ne || (ne = {})); var K = { rotate: 0, x: 1, y: 2, scaleX: 3, scaleY: 4, shearX: 5, shearY: 6, rgb: 7, alpha: 8, rgb2: 9, attachment: 10, deform: 11, event: 12, drawOrder: 13, ikConstraint: 14, transformConstraint: 15, pathConstraintPosition: 16, pathConstraintSpacing: 17, pathConstraintMix: 18, sequence: 19 }, Z = class { propertyIds; frames; constructor(e, r) { this.propertyIds = r, this.frames = V.newFloatArray(e * this.getFrameEntries()) } getPropertyIds () { return this.propertyIds } getFrameEntries () { return 1 } getFrameCount () { return this.frames.length / this.getFrameEntries() } getDuration () { return this.frames[this.frames.length - this.getFrameEntries()] } static search1 (e, r) { let t = e.length; for (let a = 1; a < t; a++)if (e[a] > r) return a - 1; return t - 1 } static search (e, r, t) { let a = e.length; for (let i = t; i < a; i += t)if (e[i] > r) return i - t; return a - t } }; F(Z, "Timeline"); var he = class extends Z { curves; constructor(e, r, t) { super(e, t), this.curves = V.newFloatArray(e + r * 18), this.curves[e - 1] = 1 } setLinear (e) { this.curves[e] = 0 } setStepped (e) { this.curves[e] = 1 } shrink (e) { let r = this.getFrameCount() + e * 18; if (this.curves.length > r) { let t = V.newFloatArray(r); V.arrayCopy(this.curves, 0, t, 0, r), this.curves = t } } setBezier (e, r, t, a, i, c, o, s, l, n, h) { let d = this.curves, f = this.getFrameCount() + e * 18; t == 0 && (d[r] = 2 + f); let m = (a - c * 2 + s) * .03, x = (i - o * 2 + l) * .03, p = ((c - s) * 3 - a + n) * .006, b = ((o - l) * 3 - i + h) * .006, y = m * 2 + p, u = x * 2 + b, g = (c - a) * .3 + m + p * .16666667, w = (o - i) * .3 + x + b * .16666667, v = a + g, I = i + w; for (let S = f + 18; f < S; f += 2)d[f] = v, d[f + 1] = I, g += y, w += u, y += p, u += b, v += g, I += w } getBezierValue (e, r, t, a) { let i = this.curves; if (i[a] > e) { let l = this.frames[r], n = this.frames[r + t]; return n + (e - l) / (i[a] - l) * (i[a + 1] - n) } let c = a + 18; for (a += 2; a < c; a += 2)if (i[a] >= e) { let l = i[a - 2], n = i[a - 1]; return n + (e - l) / (i[a] - l) * (i[a + 1] - n) } r += this.getFrameEntries(); let o = i[c - 2], s = i[c - 1]; return s + (e - o) / (this.frames[r] - o) * (this.frames[r + t] - s) } }; F(he, "CurveTimeline"); var ce = class extends he { constructor(e, r, t) { super(e, r, [t]) } getFrameEntries () { return 2 } setFrame (e, r, t) { e <<= 1, this.frames[e] = r, this.frames[e + 1] = t } getCurveValue (e) { let r = this.frames, t = r.length - 2; for (let i = 2; i <= t; i += 2)if (r[i] > e) { t = i - 2; break } let a = this.curves[t >> 1]; switch (a) { case 0: let i = r[t], c = r[t + 1]; return c + (e - i) / (r[t + 2] - i) * (r[t + 2 + 1] - c); case 1: return r[t + 1] }return this.getBezierValue(e, t, 1, a - 2) } }; F(ce, "CurveTimeline1"); var Yt = class extends he { constructor(e, r, t, a) { super(e, r, [t, a]) } getFrameEntries () { return 3 } setFrame (e, r, t, a) { e *= 3, this.frames[e] = r, this.frames[e + 1] = t, this.frames[e + 2] = a } }; F(Yt, "CurveTimeline2"); var Ye = class extends ce { boneIndex = 0; constructor(e, r, t) { super(e, r, K.rotate + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.rotation = s.data.rotation; return; case C.first: s.rotation += (s.data.rotation - s.rotation) * i }return } let n = this.getCurveValue(t); switch (c) { case C.setup: s.rotation = s.data.rotation + n * i; break; case C.first: case C.replace: n += s.data.rotation - s.rotation; case C.add: s.rotation += n * i } } }; F(Ye, "RotateTimeline"); var Ue = class extends Yt { boneIndex = 0; constructor(e, r, t) { super(e, r, K.x + "|" + t, K.y + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.x = s.data.x, s.y = s.data.y; return; case C.first: s.x += (s.data.x - s.x) * i, s.y += (s.data.y - s.y) * i }return } let n = 0, h = 0, d = Z.search(l, t, 3), f = this.curves[d / 3]; switch (f) { case 0: let m = l[d]; n = l[d + 1], h = l[d + 2]; let x = (t - m) / (l[d + 3] - m); n += (l[d + 3 + 1] - n) * x, h += (l[d + 3 + 2] - h) * x; break; case 1: n = l[d + 1], h = l[d + 2]; break; default: n = this.getBezierValue(t, d, 1, f - 2), h = this.getBezierValue(t, d, 2, f + 18 - 2) }switch (c) { case C.setup: s.x = s.data.x + n * i, s.y = s.data.y + h * i; break; case C.first: case C.replace: s.x += (s.data.x + n - s.x) * i, s.y += (s.data.y + h - s.y) * i; break; case C.add: s.x += n * i, s.y += h * i } } }; F(Ue, "TranslateTimeline"); var We = class extends ce { boneIndex = 0; constructor(e, r, t) { super(e, r, K.x + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.x = s.data.x; return; case C.first: s.x += (s.data.x - s.x) * i }return } let n = this.getCurveValue(t); switch (c) { case C.setup: s.x = s.data.x + n * i; break; case C.first: case C.replace: s.x += (s.data.x + n - s.x) * i; break; case C.add: s.x += n * i } } }; F(We, "TranslateXTimeline"); var ze = class extends ce { boneIndex = 0; constructor(e, r, t) { super(e, r, K.y + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.y = s.data.y; return; case C.first: s.y += (s.data.y - s.y) * i }return } let n = this.getCurveValue(t); switch (c) { case C.setup: s.y = s.data.y + n * i; break; case C.first: case C.replace: s.y += (s.data.y + n - s.y) * i; break; case C.add: s.y += n * i } } }; F(ze, "TranslateYTimeline"); var $e = class extends Yt { boneIndex = 0; constructor(e, r, t) { super(e, r, K.scaleX + "|" + t, K.scaleY + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.scaleX = s.data.scaleX, s.scaleY = s.data.scaleY; return; case C.first: s.scaleX += (s.data.scaleX - s.scaleX) * i, s.scaleY += (s.data.scaleY - s.scaleY) * i }return } let n, h, d = Z.search(l, t, 3), f = this.curves[d / 3]; switch (f) { case 0: let m = l[d]; n = l[d + 1], h = l[d + 2]; let x = (t - m) / (l[d + 3] - m); n += (l[d + 3 + 1] - n) * x, h += (l[d + 3 + 2] - h) * x; break; case 1: n = l[d + 1], h = l[d + 2]; break; default: n = this.getBezierValue(t, d, 1, f - 2), h = this.getBezierValue(t, d, 2, f + 18 - 2) }if (n *= s.data.scaleX, h *= s.data.scaleY, i == 1) c == C.add ? (s.scaleX += n - s.data.scaleX, s.scaleY += h - s.data.scaleY) : (s.scaleX = n, s.scaleY = h); else { let m = 0, x = 0; if (o == ne.mixOut) switch (c) { case C.setup: m = s.data.scaleX, x = s.data.scaleY, s.scaleX = m + (Math.abs(n) * E.signum(m) - m) * i, s.scaleY = x + (Math.abs(h) * E.signum(x) - x) * i; break; case C.first: case C.replace: m = s.scaleX, x = s.scaleY, s.scaleX = m + (Math.abs(n) * E.signum(m) - m) * i, s.scaleY = x + (Math.abs(h) * E.signum(x) - x) * i; break; case C.add: s.scaleX += (n - s.data.scaleX) * i, s.scaleY += (h - s.data.scaleY) * i } else switch (c) { case C.setup: m = Math.abs(s.data.scaleX) * E.signum(n), x = Math.abs(s.data.scaleY) * E.signum(h), s.scaleX = m + (n - m) * i, s.scaleY = x + (h - x) * i; break; case C.first: case C.replace: m = Math.abs(s.scaleX) * E.signum(n), x = Math.abs(s.scaleY) * E.signum(h), s.scaleX = m + (n - m) * i, s.scaleY = x + (h - x) * i; break; case C.add: s.scaleX += (n - s.data.scaleX) * i, s.scaleY += (h - s.data.scaleY) * i } } } }; F($e, "ScaleTimeline"); var He = class extends ce { boneIndex = 0; constructor(e, r, t) { super(e, r, K.scaleX + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.scaleX = s.data.scaleX; return; case C.first: s.scaleX += (s.data.scaleX - s.scaleX) * i }return } let n = this.getCurveValue(t) * s.data.scaleX; if (i == 1) c == C.add ? s.scaleX += n - s.data.scaleX : s.scaleX = n; else { let h = 0; if (o == ne.mixOut) switch (c) { case C.setup: h = s.data.scaleX, s.scaleX = h + (Math.abs(n) * E.signum(h) - h) * i; break; case C.first: case C.replace: h = s.scaleX, s.scaleX = h + (Math.abs(n) * E.signum(h) - h) * i; break; case C.add: s.scaleX += (n - s.data.scaleX) * i } else switch (c) { case C.setup: h = Math.abs(s.data.scaleX) * E.signum(n), s.scaleX = h + (n - h) * i; break; case C.first: case C.replace: h = Math.abs(s.scaleX) * E.signum(n), s.scaleX = h + (n - h) * i; break; case C.add: s.scaleX += (n - s.data.scaleX) * i } } } }; F(He, "ScaleXTimeline"); var _e = class extends ce { boneIndex = 0; constructor(e, r, t) { super(e, r, K.scaleY + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.scaleY = s.data.scaleY; return; case C.first: s.scaleY += (s.data.scaleY - s.scaleY) * i }return } let n = this.getCurveValue(t) * s.data.scaleY; if (i == 1) c == C.add ? s.scaleY += n - s.data.scaleY : s.scaleY = n; else { let h = 0; if (o == ne.mixOut) switch (c) { case C.setup: h = s.data.scaleY, s.scaleY = h + (Math.abs(n) * E.signum(h) - h) * i; break; case C.first: case C.replace: h = s.scaleY, s.scaleY = h + (Math.abs(n) * E.signum(h) - h) * i; break; case C.add: s.scaleY += (n - s.data.scaleY) * i } else switch (c) { case C.setup: h = Math.abs(s.data.scaleY) * E.signum(n), s.scaleY = h + (n - h) * i; break; case C.first: case C.replace: h = Math.abs(s.scaleY) * E.signum(n), s.scaleY = h + (n - h) * i; break; case C.add: s.scaleY += (n - s.data.scaleY) * i } } } }; F(_e, "ScaleYTimeline"); var Ge = class extends Yt { boneIndex = 0; constructor(e, r, t) { super(e, r, K.shearX + "|" + t, K.shearY + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.shearX = s.data.shearX, s.shearY = s.data.shearY; return; case C.first: s.shearX += (s.data.shearX - s.shearX) * i, s.shearY += (s.data.shearY - s.shearY) * i }return } let n = 0, h = 0, d = Z.search(l, t, 3), f = this.curves[d / 3]; switch (f) { case 0: let m = l[d]; n = l[d + 1], h = l[d + 2]; let x = (t - m) / (l[d + 3] - m); n += (l[d + 3 + 1] - n) * x, h += (l[d + 3 + 2] - h) * x; break; case 1: n = l[d + 1], h = l[d + 2]; break; default: n = this.getBezierValue(t, d, 1, f - 2), h = this.getBezierValue(t, d, 2, f + 18 - 2) }switch (c) { case C.setup: s.shearX = s.data.shearX + n * i, s.shearY = s.data.shearY + h * i; break; case C.first: case C.replace: s.shearX += (s.data.shearX + n - s.shearX) * i, s.shearY += (s.data.shearY + h - s.shearY) * i; break; case C.add: s.shearX += n * i, s.shearY += h * i } } }; F(Ge, "ShearTimeline"); var je = class extends ce { boneIndex = 0; constructor(e, r, t) { super(e, r, K.shearX + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.shearX = s.data.shearX; return; case C.first: s.shearX += (s.data.shearX - s.shearX) * i }return } let n = this.getCurveValue(t); switch (c) { case C.setup: s.shearX = s.data.shearX + n * i; break; case C.first: case C.replace: s.shearX += (s.data.shearX + n - s.shearX) * i; break; case C.add: s.shearX += n * i } } }; F(je, "ShearXTimeline"); var Je = class extends ce { boneIndex = 0; constructor(e, r, t) { super(e, r, K.shearY + "|" + t), this.boneIndex = t } apply (e, r, t, a, i, c, o) { let s = e.bones[this.boneIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.shearY = s.data.shearY; return; case C.first: s.shearY += (s.data.shearY - s.shearY) * i }return } let n = this.getCurveValue(t); switch (c) { case C.setup: s.shearY = s.data.shearY + n * i; break; case C.first: case C.replace: s.shearY += (s.data.shearY + n - s.shearY) * i; break; case C.add: s.shearY += n * i } } }; F(Je, "ShearYTimeline"); var Ke = class extends he { slotIndex = 0; constructor(e, r, t) { super(e, r, [K.rgb + "|" + t, K.alpha + "|" + t]), this.slotIndex = t } getFrameEntries () { return 5 } setFrame (e, r, t, a, i, c) { e *= 5, this.frames[e] = r, this.frames[e + 1] = t, this.frames[e + 2] = a, this.frames[e + 3] = i, this.frames[e + 4] = c } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (!s.bone.active) return; let l = this.frames, n = s.color; if (t < l[0]) { let b = s.data.color; switch (c) { case C.setup: n.setFromColor(b); return; case C.first: n.add((b.r - n.r) * i, (b.g - n.g) * i, (b.b - n.b) * i, (b.a - n.a) * i) }return } let h = 0, d = 0, f = 0, m = 0, x = Z.search(l, t, 5), p = this.curves[x / 5]; switch (p) { case 0: let b = l[x]; h = l[x + 1], d = l[x + 2], f = l[x + 3], m = l[x + 4]; let y = (t - b) / (l[x + 5] - b); h += (l[x + 5 + 1] - h) * y, d += (l[x + 5 + 2] - d) * y, f += (l[x + 5 + 3] - f) * y, m += (l[x + 5 + 4] - m) * y; break; case 1: h = l[x + 1], d = l[x + 2], f = l[x + 3], m = l[x + 4]; break; default: h = this.getBezierValue(t, x, 1, p - 2), d = this.getBezierValue(t, x, 2, p + 18 - 2), f = this.getBezierValue(t, x, 3, p + 18 * 2 - 2), m = this.getBezierValue(t, x, 4, p + 18 * 3 - 2) }i == 1 ? n.set(h, d, f, m) : (c == C.setup && n.setFromColor(s.data.color), n.add((h - n.r) * i, (d - n.g) * i, (f - n.b) * i, (m - n.a) * i)) } }; F(Ke, "RGBATimeline"); var Qe = class extends he { slotIndex = 0; constructor(e, r, t) { super(e, r, [K.rgb + "|" + t]), this.slotIndex = t } getFrameEntries () { return 4 } setFrame (e, r, t, a, i) { e <<= 2, this.frames[e] = r, this.frames[e + 1] = t, this.frames[e + 2] = a, this.frames[e + 3] = i } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (!s.bone.active) return; let l = this.frames, n = s.color; if (t < l[0]) { let p = s.data.color; switch (c) { case C.setup: n.r = p.r, n.g = p.g, n.b = p.b; return; case C.first: n.r += (p.r - n.r) * i, n.g += (p.g - n.g) * i, n.b += (p.b - n.b) * i }return } let h = 0, d = 0, f = 0, m = Z.search(l, t, 4), x = this.curves[m >> 2]; switch (x) { case 0: let p = l[m]; h = l[m + 1], d = l[m + 2], f = l[m + 3]; let b = (t - p) / (l[m + 4] - p); h += (l[m + 4 + 1] - h) * b, d += (l[m + 4 + 2] - d) * b, f += (l[m + 4 + 3] - f) * b; break; case 1: h = l[m + 1], d = l[m + 2], f = l[m + 3]; break; default: h = this.getBezierValue(t, m, 1, x - 2), d = this.getBezierValue(t, m, 2, x + 18 - 2), f = this.getBezierValue(t, m, 3, x + 18 * 2 - 2) }if (i == 1) n.r = h, n.g = d, n.b = f; else { if (c == C.setup) { let p = s.data.color; n.r = p.r, n.g = p.g, n.b = p.b } n.r += (h - n.r) * i, n.g += (d - n.g) * i, n.b += (f - n.b) * i } } }; F(Qe, "RGBTimeline"); var Ze = class extends ce { slotIndex = 0; constructor(e, r, t) { super(e, r, K.alpha + "|" + t), this.slotIndex = t } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (!s.bone.active) return; let l = s.color; if (t < this.frames[0]) { let h = s.data.color; switch (c) { case C.setup: l.a = h.a; return; case C.first: l.a += (h.a - l.a) * i }return } let n = this.getCurveValue(t); i == 1 ? l.a = n : (c == C.setup && (l.a = s.data.color.a), l.a += (n - l.a) * i) } }; F(Ze, "AlphaTimeline"); var et = class extends he { slotIndex = 0; constructor(e, r, t) { super(e, r, [K.rgb + "|" + t, K.alpha + "|" + t, K.rgb2 + "|" + t]), this.slotIndex = t } getFrameEntries () { return 8 } setFrame (e, r, t, a, i, c, o, s, l) { e <<= 3, this.frames[e] = r, this.frames[e + 1] = t, this.frames[e + 2] = a, this.frames[e + 3] = i, this.frames[e + 4] = c, this.frames[e + 5] = o, this.frames[e + 6] = s, this.frames[e + 7] = l } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (!s.bone.active) return; let l = this.frames, n = s.color, h = s.darkColor; if (t < l[0]) { let w = s.data.color, v = s.data.darkColor; switch (c) { case C.setup: n.setFromColor(w), h.r = v.r, h.g = v.g, h.b = v.b; return; case C.first: n.add((w.r - n.r) * i, (w.g - n.g) * i, (w.b - n.b) * i, (w.a - n.a) * i), h.r += (v.r - h.r) * i, h.g += (v.g - h.g) * i, h.b += (v.b - h.b) * i }return } let d = 0, f = 0, m = 0, x = 0, p = 0, b = 0, y = 0, u = Z.search(l, t, 8), g = this.curves[u >> 3]; switch (g) { case 0: let w = l[u]; d = l[u + 1], f = l[u + 2], m = l[u + 3], x = l[u + 4], p = l[u + 5], b = l[u + 6], y = l[u + 7]; let v = (t - w) / (l[u + 8] - w); d += (l[u + 8 + 1] - d) * v, f += (l[u + 8 + 2] - f) * v, m += (l[u + 8 + 3] - m) * v, x += (l[u + 8 + 4] - x) * v, p += (l[u + 8 + 5] - p) * v, b += (l[u + 8 + 6] - b) * v, y += (l[u + 8 + 7] - y) * v; break; case 1: d = l[u + 1], f = l[u + 2], m = l[u + 3], x = l[u + 4], p = l[u + 5], b = l[u + 6], y = l[u + 7]; break; default: d = this.getBezierValue(t, u, 1, g - 2), f = this.getBezierValue(t, u, 2, g + 18 - 2), m = this.getBezierValue(t, u, 3, g + 18 * 2 - 2), x = this.getBezierValue(t, u, 4, g + 18 * 3 - 2), p = this.getBezierValue(t, u, 5, g + 18 * 4 - 2), b = this.getBezierValue(t, u, 6, g + 18 * 5 - 2), y = this.getBezierValue(t, u, 7, g + 18 * 6 - 2) }if (i == 1) n.set(d, f, m, x), h.r = p, h.g = b, h.b = y; else { if (c == C.setup) { n.setFromColor(s.data.color); let w = s.data.darkColor; h.r = w.r, h.g = w.g, h.b = w.b } n.add((d - n.r) * i, (f - n.g) * i, (m - n.b) * i, (x - n.a) * i), h.r += (p - h.r) * i, h.g += (b - h.g) * i, h.b += (y - h.b) * i } } }; F(et, "RGBA2Timeline"); var tt = class extends he { slotIndex = 0; constructor(e, r, t) { super(e, r, [K.rgb + "|" + t, K.rgb2 + "|" + t]), this.slotIndex = t } getFrameEntries () { return 7 } setFrame (e, r, t, a, i, c, o, s) { e *= 7, this.frames[e] = r, this.frames[e + 1] = t, this.frames[e + 2] = a, this.frames[e + 3] = i, this.frames[e + 4] = c, this.frames[e + 5] = o, this.frames[e + 6] = s } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (!s.bone.active) return; let l = this.frames, n = s.color, h = s.darkColor; if (t < l[0]) { let w = s.data.color, v = s.data.darkColor; switch (c) { case C.setup: n.r = w.r, n.g = w.g, n.b = w.b, h.r = v.r, h.g = v.g, h.b = v.b; return; case C.first: n.r += (w.r - n.r) * i, n.g += (w.g - n.g) * i, n.b += (w.b - n.b) * i, h.r += (v.r - h.r) * i, h.g += (v.g - h.g) * i, h.b += (v.b - h.b) * i }return } let d = 0, f = 0, m = 0, x = 0, p = 0, b = 0, y = 0, u = Z.search(l, t, 7), g = this.curves[u / 7]; switch (g) { case 0: let w = l[u]; d = l[u + 1], f = l[u + 2], m = l[u + 3], p = l[u + 4], b = l[u + 5], y = l[u + 6]; let v = (t - w) / (l[u + 7] - w); d += (l[u + 7 + 1] - d) * v, f += (l[u + 7 + 2] - f) * v, m += (l[u + 7 + 3] - m) * v, p += (l[u + 7 + 4] - p) * v, b += (l[u + 7 + 5] - b) * v, y += (l[u + 7 + 6] - y) * v; break; case 1: d = l[u + 1], f = l[u + 2], m = l[u + 3], p = l[u + 4], b = l[u + 5], y = l[u + 6]; break; default: d = this.getBezierValue(t, u, 1, g - 2), f = this.getBezierValue(t, u, 2, g + 18 - 2), m = this.getBezierValue(t, u, 3, g + 18 * 2 - 2), p = this.getBezierValue(t, u, 4, g + 18 * 3 - 2), b = this.getBezierValue(t, u, 5, g + 18 * 4 - 2), y = this.getBezierValue(t, u, 6, g + 18 * 5 - 2) }if (i == 1) n.r = d, n.g = f, n.b = m, h.r = p, h.g = b, h.b = y; else { if (c == C.setup) { let w = s.data.color, v = s.data.darkColor; n.r = w.r, n.g = w.g, n.b = w.b, h.r = v.r, h.g = v.g, h.b = v.b } n.r += (d - n.r) * i, n.g += (f - n.g) * i, n.b += (m - n.b) * i, h.r += (p - h.r) * i, h.g += (b - h.g) * i, h.b += (y - h.b) * i } } }; F(tt, "RGB2Timeline"); var me = class extends Z { slotIndex = 0; attachmentNames; constructor(e, r) { super(e, [K.attachment + "|" + r]), this.slotIndex = r, this.attachmentNames = new Array(e) } getFrameCount () { return this.frames.length } setFrame (e, r, t) { this.frames[e] = r, this.attachmentNames[e] = t } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (s.bone.active) { if (o == ne.mixOut) { c == C.setup && this.setAttachment(e, s, s.data.attachmentName); return } if (t < this.frames[0]) { (c == C.setup || c == C.first) && this.setAttachment(e, s, s.data.attachmentName); return } this.setAttachment(e, s, this.attachmentNames[Z.search1(this.frames, t)]) } } setAttachment (e, r, t) { r.setAttachment(t ? e.getAttachment(this.slotIndex, t) : null) } }; F(me, "AttachmentTimeline"); var rt = class extends he { slotIndex = 0; attachment; vertices; constructor(e, r, t, a) { super(e, r, [K.deform + "|" + t + "|" + a.id]), this.slotIndex = t, this.attachment = a, this.vertices = new Array(e) } getFrameCount () { return this.frames.length } setFrame (e, r, t) { this.frames[e] = r, this.vertices[e] = t } setBezier (e, r, t, a, i, c, o, s, l, n, h) { let d = this.curves, f = this.getFrameCount() + e * 18; t == 0 && (d[r] = 2 + f); let m = (a - c * 2 + s) * .03, x = l * .03 - o * .06, p = ((c - s) * 3 - a + n) * .006, b = (o - l + .33333333) * .018, y = m * 2 + p, u = x * 2 + b, g = (c - a) * .3 + m + p * .16666667, w = o * .3 + x + b * .16666667, v = a + g, I = w; for (let S = f + 18; f < S; f += 2)d[f] = v, d[f + 1] = I, g += y, w += u, y += p, u += b, v += g, I += w } getCurvePercent (e, r) { let t = this.curves, a = t[r]; switch (a) { case 0: let s = this.frames[r]; return (e - s) / (this.frames[r + this.getFrameEntries()] - s); case 1: return 0 }if (a -= 2, t[a] > e) { let s = this.frames[r]; return t[a + 1] * (e - s) / (t[a] - s) } let i = a + 18; for (a += 2; a < i; a += 2)if (t[a] >= e) { let s = t[a - 2], l = t[a - 1]; return l + (e - s) / (t[a] - s) * (t[a + 1] - l) } let c = t[i - 2], o = t[i - 1]; return o + (1 - o) * (e - c) / (this.frames[r + this.getFrameEntries()] - c) } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (!s.bone.active) return; let l = s.getAttachment(); if (!l || !(l instanceof te) || l.timelineAttachment != this.attachment) return; let n = s.deform; n.length == 0 && (c = C.setup); let h = this.vertices, d = h[0].length, f = this.frames; if (t < f[0]) { switch (c) { case C.setup: n.length = 0; return; case C.first: if (i == 1) { n.length = 0; return } n.length = d; let u = l; if (u.bones) { i = 1 - i; for (var m = 0; m < d; m++)n[m] *= i } else { let g = u.vertices; for (var m = 0; m < d; m++)n[m] += (g[m] - n[m]) * i } }return } if (n.length = d, t >= f[f.length - 1]) { let u = h[f.length - 1]; if (i == 1) if (c == C.add) { let g = l; if (g.bones) for (let w = 0; w < d; w++)n[w] += u[w]; else { let w = g.vertices; for (let v = 0; v < d; v++)n[v] += u[v] - w[v] } } else V.arrayCopy(u, 0, n, 0, d); else switch (c) { case C.setup: { let w = l; if (w.bones) for (let v = 0; v < d; v++)n[v] = u[v] * i; else { let v = w.vertices; for (let I = 0; I < d; I++) { let S = v[I]; n[I] = S + (u[I] - S) * i } } break } case C.first: case C.replace: for (let w = 0; w < d; w++)n[w] += (u[w] - n[w]) * i; break; case C.add: let g = l; if (g.bones) for (let w = 0; w < d; w++)n[w] += u[w] * i; else { let w = g.vertices; for (let v = 0; v < d; v++)n[v] += (u[v] - w[v]) * i } }return } let x = Z.search1(f, t), p = this.getCurvePercent(t, x), b = h[x], y = h[x + 1]; if (i == 1) if (c == C.add) { let u = l; if (u.bones) for (let g = 0; g < d; g++) { let w = b[g]; n[g] += w + (y[g] - w) * p } else { let g = u.vertices; for (let w = 0; w < d; w++) { let v = b[w]; n[w] += v + (y[w] - v) * p - g[w] } } } else for (let u = 0; u < d; u++) { let g = b[u]; n[u] = g + (y[u] - g) * p } else switch (c) { case C.setup: { let g = l; if (g.bones) for (let w = 0; w < d; w++) { let v = b[w]; n[w] = (v + (y[w] - v) * p) * i } else { let w = g.vertices; for (let v = 0; v < d; v++) { let I = b[v], S = w[v]; n[v] = S + (I + (y[v] - I) * p - S) * i } } break } case C.first: case C.replace: for (let g = 0; g < d; g++) { let w = b[g]; n[g] += (w + (y[g] - w) * p - n[g]) * i } break; case C.add: let u = l; if (u.bones) for (let g = 0; g < d; g++) { let w = b[g]; n[g] += (w + (y[g] - w) * p) * i } else { let g = u.vertices; for (let w = 0; w < d; w++) { let v = b[w]; n[w] += (v + (y[w] - v) * p - g[w]) * i } } } } }; F(rt, "DeformTimeline"); var vr = class extends Z { events; constructor(e) { super(e, vr.propertyIds), this.events = new Array(e) } getFrameCount () { return this.frames.length } setFrame (e, r) { this.frames[e] = r.time, this.events[e] = r } apply (e, r, t, a, i, c, o) { if (!a) return; let s = this.frames, l = this.frames.length; if (r > t) this.apply(e, r, Number.MAX_VALUE, a, i, c, o), r = -1; else if (r >= s[l - 1]) return; if (t < s[0]) return; let n = 0; if (r < s[0]) n = 0; else { n = Z.search1(s, r) + 1; let h = s[n]; for (; n > 0 && s[n - 1] == h;)n-- } for (; n < l && t >= s[n]; n++)a.push(this.events[n]) } }, ve = vr; F(ve, "EventTimeline"), N(ve, "propertyIds", ["" + K.event]); var Yr = class extends Z { drawOrders; constructor(e) { super(e, Yr.propertyIds), this.drawOrders = new Array(e) } getFrameCount () { return this.frames.length } setFrame (e, r, t) { this.frames[e] = r, this.drawOrders[e] = t } apply (e, r, t, a, i, c, o) { if (o == ne.mixOut) { c == C.setup && V.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length); return } if (t < this.frames[0]) { (c == C.setup || c == C.first) && V.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length); return } let s = Z.search1(this.frames, t), l = this.drawOrders[s]; if (!l) V.arrayCopy(e.slots, 0, e.drawOrder, 0, e.slots.length); else { let n = e.drawOrder, h = e.slots; for (let d = 0, f = l.length; d < f; d++)n[d] = h[l[d]] } } }, fe = Yr; F(fe, "DrawOrderTimeline"), N(fe, "propertyIds", ["" + K.drawOrder]); var st = class extends he { ikConstraintIndex = 0; constructor(e, r, t) { super(e, r, [K.ikConstraint + "|" + t]), this.ikConstraintIndex = t } getFrameEntries () { return 6 } setFrame (e, r, t, a, i, c, o) { e *= 6, this.frames[e] = r, this.frames[e + 1] = t, this.frames[e + 2] = a, this.frames[e + 3] = i, this.frames[e + 4] = c ? 1 : 0, this.frames[e + 5] = o ? 1 : 0 } apply (e, r, t, a, i, c, o) { let s = e.ikConstraints[this.ikConstraintIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.mix = s.data.mix, s.softness = s.data.softness, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch; return; case C.first: s.mix += (s.data.mix - s.mix) * i, s.softness += (s.data.softness - s.softness) * i, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch }return } let n = 0, h = 0, d = Z.search(l, t, 6), f = this.curves[d / 6]; switch (f) { case 0: let m = l[d]; n = l[d + 1], h = l[d + 2]; let x = (t - m) / (l[d + 6] - m); n += (l[d + 6 + 1] - n) * x, h += (l[d + 6 + 2] - h) * x; break; case 1: n = l[d + 1], h = l[d + 2]; break; default: n = this.getBezierValue(t, d, 1, f - 2), h = this.getBezierValue(t, d, 2, f + 18 - 2) }c == C.setup ? (s.mix = s.data.mix + (n - s.data.mix) * i, s.softness = s.data.softness + (h - s.data.softness) * i, o == ne.mixOut ? (s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch) : (s.bendDirection = l[d + 3], s.compress = l[d + 4] != 0, s.stretch = l[d + 5] != 0)) : (s.mix += (n - s.mix) * i, s.softness += (h - s.softness) * i, o == ne.mixIn && (s.bendDirection = l[d + 3], s.compress = l[d + 4] != 0, s.stretch = l[d + 5] != 0)) } }; F(st, "IkConstraintTimeline"); var it = class extends he { transformConstraintIndex = 0; constructor(e, r, t) { super(e, r, [K.transformConstraint + "|" + t]), this.transformConstraintIndex = t } getFrameEntries () { return 7 } setFrame (e, r, t, a, i, c, o, s) { let l = this.frames; e *= 7, l[e] = r, l[e + 1] = t, l[e + 2] = a, l[e + 3] = i, l[e + 4] = c, l[e + 5] = o, l[e + 6] = s } apply (e, r, t, a, i, c, o) { let s = e.transformConstraints[this.transformConstraintIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { let y = s.data; switch (c) { case C.setup: s.mixRotate = y.mixRotate, s.mixX = y.mixX, s.mixY = y.mixY, s.mixScaleX = y.mixScaleX, s.mixScaleY = y.mixScaleY, s.mixShearY = y.mixShearY; return; case C.first: s.mixRotate += (y.mixRotate - s.mixRotate) * i, s.mixX += (y.mixX - s.mixX) * i, s.mixY += (y.mixY - s.mixY) * i, s.mixScaleX += (y.mixScaleX - s.mixScaleX) * i, s.mixScaleY += (y.mixScaleY - s.mixScaleY) * i, s.mixShearY += (y.mixShearY - s.mixShearY) * i }return } let n, h, d, f, m, x, p = Z.search(l, t, 7), b = this.curves[p / 7]; switch (b) { case 0: let y = l[p]; n = l[p + 1], h = l[p + 2], d = l[p + 3], f = l[p + 4], m = l[p + 5], x = l[p + 6]; let u = (t - y) / (l[p + 7] - y); n += (l[p + 7 + 1] - n) * u, h += (l[p + 7 + 2] - h) * u, d += (l[p + 7 + 3] - d) * u, f += (l[p + 7 + 4] - f) * u, m += (l[p + 7 + 5] - m) * u, x += (l[p + 7 + 6] - x) * u; break; case 1: n = l[p + 1], h = l[p + 2], d = l[p + 3], f = l[p + 4], m = l[p + 5], x = l[p + 6]; break; default: n = this.getBezierValue(t, p, 1, b - 2), h = this.getBezierValue(t, p, 2, b + 18 - 2), d = this.getBezierValue(t, p, 3, b + 18 * 2 - 2), f = this.getBezierValue(t, p, 4, b + 18 * 3 - 2), m = this.getBezierValue(t, p, 5, b + 18 * 4 - 2), x = this.getBezierValue(t, p, 6, b + 18 * 5 - 2) }if (c == C.setup) { let y = s.data; s.mixRotate = y.mixRotate + (n - y.mixRotate) * i, s.mixX = y.mixX + (h - y.mixX) * i, s.mixY = y.mixY + (d - y.mixY) * i, s.mixScaleX = y.mixScaleX + (f - y.mixScaleX) * i, s.mixScaleY = y.mixScaleY + (m - y.mixScaleY) * i, s.mixShearY = y.mixShearY + (x - y.mixShearY) * i } else s.mixRotate += (n - s.mixRotate) * i, s.mixX += (h - s.mixX) * i, s.mixY += (d - s.mixY) * i, s.mixScaleX += (f - s.mixScaleX) * i, s.mixScaleY += (m - s.mixScaleY) * i, s.mixShearY += (x - s.mixShearY) * i } }; F(it, "TransformConstraintTimeline"); var at = class extends ce { pathConstraintIndex = 0; constructor(e, r, t) { super(e, r, K.pathConstraintPosition + "|" + t), this.pathConstraintIndex = t } apply (e, r, t, a, i, c, o) { let s = e.pathConstraints[this.pathConstraintIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.position = s.data.position; return; case C.first: s.position += (s.data.position - s.position) * i }return } let n = this.getCurveValue(t); c == C.setup ? s.position = s.data.position + (n - s.data.position) * i : s.position += (n - s.position) * i } }; F(at, "PathConstraintPositionTimeline"); var nt = class extends ce { pathConstraintIndex = 0; constructor(e, r, t) { super(e, r, K.pathConstraintSpacing + "|" + t), this.pathConstraintIndex = t } apply (e, r, t, a, i, c, o) { let s = e.pathConstraints[this.pathConstraintIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.spacing = s.data.spacing; return; case C.first: s.spacing += (s.data.spacing - s.spacing) * i }return } let n = this.getCurveValue(t); c == C.setup ? s.spacing = s.data.spacing + (n - s.data.spacing) * i : s.spacing += (n - s.spacing) * i } }; F(nt, "PathConstraintSpacingTimeline"); var lt = class extends he { pathConstraintIndex = 0; constructor(e, r, t) { super(e, r, [K.pathConstraintMix + "|" + t]), this.pathConstraintIndex = t } getFrameEntries () { return 4 } setFrame (e, r, t, a, i) { let c = this.frames; e <<= 2, c[e] = r, c[e + 1] = t, c[e + 2] = a, c[e + 3] = i } apply (e, r, t, a, i, c, o) { let s = e.pathConstraints[this.pathConstraintIndex]; if (!s.active) return; let l = this.frames; if (t < l[0]) { switch (c) { case C.setup: s.mixRotate = s.data.mixRotate, s.mixX = s.data.mixX, s.mixY = s.data.mixY; return; case C.first: s.mixRotate += (s.data.mixRotate - s.mixRotate) * i, s.mixX += (s.data.mixX - s.mixX) * i, s.mixY += (s.data.mixY - s.mixY) * i }return } let n, h, d, f = Z.search(l, t, 4), m = this.curves[f >> 2]; switch (m) { case 0: let x = l[f]; n = l[f + 1], h = l[f + 2], d = l[f + 3]; let p = (t - x) / (l[f + 4] - x); n += (l[f + 4 + 1] - n) * p, h += (l[f + 4 + 2] - h) * p, d += (l[f + 4 + 3] - d) * p; break; case 1: n = l[f + 1], h = l[f + 2], d = l[f + 3]; break; default: n = this.getBezierValue(t, f, 1, m - 2), h = this.getBezierValue(t, f, 2, m + 18 - 2), d = this.getBezierValue(t, f, 3, m + 18 * 2 - 2) }if (c == C.setup) { let x = s.data; s.mixRotate = x.mixRotate + (n - x.mixRotate) * i, s.mixX = x.mixX + (h - x.mixX) * i, s.mixY = x.mixY + (d - x.mixY) * i } else s.mixRotate += (n - s.mixRotate) * i, s.mixX += (h - s.mixX) * i, s.mixY += (d - s.mixY) * i } }; F(lt, "PathConstraintMixTimeline"); var Re = class extends Z { slotIndex; attachment; constructor(e, r, t) { super(e, [K.sequence + "|" + r + "|" + t.sequence.id]), this.slotIndex = r, this.attachment = t } getFrameEntries () { return Re.ENTRIES } getSlotIndex () { return this.slotIndex } getAttachment () { return this.attachment } setFrame (e, r, t, a, i) { let c = this.frames; e *= Re.ENTRIES, c[e] = r, c[e + Re.MODE] = t | a << 4, c[e + Re.DELAY] = i } apply (e, r, t, a, i, c, o) { let s = e.slots[this.slotIndex]; if (!s.bone.active) return; let l = s.attachment, n = this.attachment; if (l != n && (!(l instanceof te) || l.timelineAttachment != n)) return; let h = this.frames; if (t < h[0]) { (c == C.setup || c == C.first) && (s.sequenceIndex = -1); return } let d = Z.search(h, t, Re.ENTRIES), f = h[d], m = h[d + Re.MODE], x = h[d + Re.DELAY]; if (!this.attachment.sequence) return; let p = m >> 4, b = this.attachment.sequence.regions.length, y = sr[m & 15]; if (y != re.hold) switch (p += (t - f) / x + 1e-5 | 0, y) { case re.once: p = Math.min(b - 1, p); break; case re.loop: p %= b; break; case re.pingpong: { let u = (b << 1) - 2; p = u == 0 ? 0 : p % u, p >= b && (p = u - p); break } case re.onceReverse: p = Math.max(b - 1 - p, 0); break; case re.loopReverse: p = b - 1 - p % b; break; case re.pingpongReverse: { let u = (b << 1) - 2; p = u == 0 ? 0 : (p + b - 1) % u, p >= b && (p = u - p) } }s.sequenceIndex = p } }, ye = Re; F(ye, "SequenceTimeline"), N(ye, "ENTRIES", 3), N(ye, "MODE", 1), N(ye, "DELAY", 2); var zt = class { static emptyAnimation () { return zt._emptyAnimation } data; tracks = new Array; timeScale = 1; unkeyedState = 0; events = new Array; listeners = new Array; queue = new Wt(this); propertyIDs = new qe; animationsChanged = !1; trackEntryPool = new be(() => new Ut); constructor(e) { this.data = e } update (e) { e *= this.timeScale; let r = this.tracks; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (!i) continue; i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast; let c = e * i.timeScale; if (i.delay > 0) { if (i.delay -= c, i.delay > 0) continue; c = -i.delay, i.delay = 0 } let o = i.next; if (o) { let s = i.trackLast - o.delay; if (s >= 0) { for (o.delay = 0, o.trackTime += i.timeScale == 0 ? 0 : (s / i.timeScale + e) * o.timeScale, i.trackTime += c, this.setCurrent(t, o, !0); o.mixingFrom;)o.mixTime += e, o = o.mixingFrom; continue } } else if (i.trackLast >= i.trackEnd && !i.mixingFrom) { r[t] = null, this.queue.end(i), this.clearNext(i); continue } if (i.mixingFrom && this.updateMixingFrom(i, e)) { let s = i.mixingFrom; for (i.mixingFrom = null, s && (s.mixingTo = null); s;)this.queue.end(s), s = s.mixingFrom } i.trackTime += c } this.queue.drain() } updateMixingFrom (e, r) { let t = e.mixingFrom; if (!t) return !0; let a = this.updateMixingFrom(t, r); return t.animationLast = t.nextAnimationLast, t.trackLast = t.nextTrackLast, e.mixTime > 0 && e.mixTime >= e.mixDuration ? ((t.totalAlpha == 0 || e.mixDuration == 0) && (e.mixingFrom = t.mixingFrom, t.mixingFrom && (t.mixingFrom.mixingTo = e), e.interruptAlpha = t.interruptAlpha, this.queue.end(t)), a) : (t.trackTime += r * t.timeScale, e.mixTime += r, !1) } apply (e) { if (!e) throw new Error("skeleton cannot be null."); this.animationsChanged && this._animationsChanged(); let r = this.events, t = this.tracks, a = !1; for (let d = 0, f = t.length; d < f; d++) { let m = t[d]; if (!m || m.delay > 0) continue; a = !0; let x = d == 0 ? C.first : m.mixBlend, p = m.alpha; m.mixingFrom ? p *= this.applyMixingFrom(m, e, x) : m.trackTime >= m.trackEnd && !m.next && (p = 0); let b = m.animationLast, y = m.getAnimationTime(), u = y, g = r; m.reverse && (u = m.animation.duration - u, g = null); let w = m.animation.timelines, v = w.length; if (d == 0 && p == 1 || x == C.add) for (let I = 0; I < v; I++) { V.webkit602BugfixHelper(p, x); var i = w[I]; i instanceof me ? this.applyAttachmentTimeline(i, e, u, x, !0) : i.apply(e, b, u, g, p, x, ne.mixIn) } else { let I = m.timelineMode, S = m.shortestRotation, A = !S && m.timelinesRotation.length != v << 1; A && (m.timelinesRotation.length = v << 1); for (let M = 0; M < v; M++) { let B = w[M], L = I[M] == ar ? x : C.setup; !S && B instanceof Ye ? this.applyRotateTimeline(B, e, u, p, L, m.timelinesRotation, M << 1, A) : B instanceof me ? this.applyAttachmentTimeline(B, e, u, x, !0) : (V.webkit602BugfixHelper(p, x), B.apply(e, b, u, g, p, L, ne.mixIn)) } } this.queueEvents(m, y), r.length = 0, m.nextAnimationLast = y, m.nextTrackLast = m.trackTime } for (var c = this.unkeyedState + kr, o = e.slots, s = 0, l = e.slots.length; s < l; s++) { var n = o[s]; if (n.attachmentState == c) { var h = n.data.attachmentName; n.setAttachment(h ? e.getAttachment(n.data.index, h) : null) } } return this.unkeyedState += 2, this.queue.drain(), a } applyMixingFrom (e, r, t) { let a = e.mixingFrom; a.mixingFrom && this.applyMixingFrom(a, r, t); let i = 0; e.mixDuration == 0 ? (i = 1, t == C.first && (t = C.setup)) : (i = e.mixTime / e.mixDuration, i > 1 && (i = 1), t != C.first && (t = a.mixBlend)); let c = i < a.attachmentThreshold, o = i < a.drawOrderThreshold, s = a.animation.timelines, l = s.length, n = a.alpha * e.interruptAlpha, h = n * (1 - i), d = a.animationLast, f = a.getAnimationTime(), m = f, x = null; if (a.reverse ? m = a.animation.duration - m : i < a.eventThreshold && (x = this.events), t == C.add) for (let p = 0; p < l; p++)s[p].apply(r, d, m, x, h, t, ne.mixOut); else { let p = a.timelineMode, b = a.timelineHoldMix, y = a.shortestRotation, u = !y && a.timelinesRotation.length != l << 1; u && (a.timelinesRotation.length = l << 1), a.totalAlpha = 0; for (let g = 0; g < l; g++) { let w = s[g], v = ne.mixOut, I, S = 0; switch (p[g]) { case ar: if (!o && w instanceof fe) continue; I = t, S = h; break; case Ir: I = C.setup, S = h; break; case Sr: I = t, S = n; break; case nr: I = C.setup, S = n; break; default: I = C.setup; let A = b[g]; S = n * Math.max(0, 1 - A.mixTime / A.mixDuration); break }a.totalAlpha += S, !y && w instanceof Ye ? this.applyRotateTimeline(w, r, m, S, I, a.timelinesRotation, g << 1, u) : w instanceof me ? this.applyAttachmentTimeline(w, r, m, I, c) : (V.webkit602BugfixHelper(S, t), o && w instanceof fe && I == C.setup && (v = ne.mixIn), w.apply(r, d, m, x, S, I, v)) } } return e.mixDuration > 0 && this.queueEvents(a, f), this.events.length = 0, a.nextAnimationLast = f, a.nextTrackLast = a.trackTime, i } applyAttachmentTimeline (e, r, t, a, i) { var c = r.slots[e.slotIndex]; c.bone.active && (t < e.frames[0] ? (a == C.setup || a == C.first) && this.setAttachment(r, c, c.data.attachmentName, i) : this.setAttachment(r, c, e.attachmentNames[Z.search1(e.frames, t)], i), c.attachmentState <= this.unkeyedState && (c.attachmentState = this.unkeyedState + kr)) } setAttachment (e, r, t, a) { r.setAttachment(t ? e.getAttachment(r.data.index, t) : null), a && (r.attachmentState = this.unkeyedState + Vr) } applyRotateTimeline (e, r, t, a, i, c, o, s) { if (s && (c[o] = 0), a == 1) { e.apply(r, 0, t, null, 1, i, ne.mixIn); return } let l = r.bones[e.boneIndex]; if (!l.active) return; let n = e.frames, h = 0, d = 0; if (t < n[0]) switch (i) { case C.setup: l.rotation = l.data.rotation; default: return; case C.first: h = l.rotation, d = l.data.rotation } else h = i == C.setup ? l.data.rotation : l.rotation, d = l.data.rotation + e.getCurveValue(t); let f = 0, m = d - h; if (m -= (16384 - (16384.499999999996 - m / 360 | 0)) * 360, m == 0) f = c[o]; else { let x = 0, p = 0; s ? (x = 0, p = m) : (x = c[o], p = c[o + 1]); let b = m > 0, y = x >= 0; E.signum(p) != E.signum(m) && Math.abs(p) <= 90 && (Math.abs(x) > 180 && (x += 360 * E.signum(x)), y = b), f = m + x - x % 360, y != b && (f += 360 * E.signum(x)), c[o] = f } c[o + 1] = m, l.rotation = h + f * a } queueEvents (e, r) { let t = e.animationStart, a = e.animationEnd, i = a - t, c = e.trackLast % i, o = this.events, s = 0, l = o.length; for (; s < l; s++) { let h = o[s]; if (h.time < c) break; h.time > a || this.queue.event(e, h) } let n = !1; for (e.loop ? n = i == 0 || c > e.trackTime % i : n = r >= a && e.animationLast < a, n && this.queue.complete(e); s < l; s++) { let h = o[s]; h.time < t || this.queue.event(e, h) } } clearTracks () { let e = this.queue.drainDisabled; this.queue.drainDisabled = !0; for (let r = 0, t = this.tracks.length; r < t; r++)this.clearTrack(r); this.tracks.length = 0, this.queue.drainDisabled = e, this.queue.drain() } clearTrack (e) { if (e >= this.tracks.length) return; let r = this.tracks[e]; if (!r) return; this.queue.end(r), this.clearNext(r); let t = r; for (; ;) { let a = t.mixingFrom; if (!a) break; this.queue.end(a), t.mixingFrom = null, t.mixingTo = null, t = a } this.tracks[r.trackIndex] = null, this.queue.drain() } setCurrent (e, r, t) { let a = this.expandToIndex(e); this.tracks[e] = r, r.previous = null, a && (t && this.queue.interrupt(a), r.mixingFrom = a, a.mixingTo = r, r.mixTime = 0, a.mixingFrom && a.mixDuration > 0 && (r.interruptAlpha *= Math.min(1, a.mixTime / a.mixDuration)), a.timelinesRotation.length = 0), this.queue.start(r) } setAnimation (e, r, t = !1) { let a = this.data.skeletonData.findAnimation(r); if (!a) throw new Error("Animation not found: " + r); return this.setAnimationWith(e, a, t) } setAnimationWith (e, r, t = !1) { if (!r) throw new Error("animation cannot be null."); let a = !0, i = this.expandToIndex(e); i && (i.nextTrackLast == -1 ? (this.tracks[e] = i.mixingFrom, this.queue.interrupt(i), this.queue.end(i), this.clearNext(i), i = i.mixingFrom, a = !1) : this.clearNext(i)); let c = this.trackEntry(e, r, t, i); return this.setCurrent(e, c, a), this.queue.drain(), c } addAnimation (e, r, t = !1, a = 0) { let i = this.data.skeletonData.findAnimation(r); if (!i) throw new Error("Animation not found: " + r); return this.addAnimationWith(e, i, t, a) } addAnimationWith (e, r, t = !1, a = 0) { if (!r) throw new Error("animation cannot be null."); let i = this.expandToIndex(e); if (i) for (; i.next;)i = i.next; let c = this.trackEntry(e, r, t, i); return i ? (i.next = c, c.previous = i, a <= 0 && (a += i.getTrackComplete() - c.mixDuration)) : (this.setCurrent(e, c, !0), this.queue.drain()), c.delay = a, c } setEmptyAnimation (e, r = 0) { let t = this.setAnimationWith(e, zt.emptyAnimation(), !1); return t.mixDuration = r, t.trackEnd = r, t } addEmptyAnimation (e, r = 0, t = 0) { let a = this.addAnimationWith(e, zt.emptyAnimation(), !1, t); return t <= 0 && (a.delay += a.mixDuration - r), a.mixDuration = r, a.trackEnd = r, a } setEmptyAnimations (e = 0) { let r = this.queue.drainDisabled; this.queue.drainDisabled = !0; for (let t = 0, a = this.tracks.length; t < a; t++) { let i = this.tracks[t]; i && this.setEmptyAnimation(i.trackIndex, e) } this.queue.drainDisabled = r, this.queue.drain() } expandToIndex (e) { return e < this.tracks.length ? this.tracks[e] : (V.ensureArrayCapacity(this.tracks, e + 1, null), this.tracks.length = e + 1, null) } trackEntry (e, r, t, a) { let i = this.trackEntryPool.obtain(); return i.reset(), i.trackIndex = e, i.animation = r, i.loop = t, i.holdPrevious = !1, i.reverse = !1, i.shortestRotation = !1, i.eventThreshold = 0, i.attachmentThreshold = 0, i.drawOrderThreshold = 0, i.animationStart = 0, i.animationEnd = r.duration, i.animationLast = -1, i.nextAnimationLast = -1, i.delay = 0, i.trackTime = 0, i.trackLast = -1, i.nextTrackLast = -1, i.trackEnd = Number.MAX_VALUE, i.timeScale = 1, i.alpha = 1, i.mixTime = 0, i.mixDuration = a ? this.data.getMix(a.animation, r) : 0, i.interruptAlpha = 1, i.totalAlpha = 0, i.mixBlend = C.replace, i } clearNext (e) { let r = e.next; for (; r;)this.queue.dispose(r), r = r.next; e.next = null } _animationsChanged () { this.animationsChanged = !1, this.propertyIDs.clear(); let e = this.tracks; for (let r = 0, t = e.length; r < t; r++) { let a = e[r]; if (a) { for (; a.mixingFrom;)a = a.mixingFrom; do (!a.mixingTo || a.mixBlend != C.add) && this.computeHold(a), a = a.mixingTo; while (a) } } } computeHold (e) { let r = e.mixingTo, t = e.animation.timelines, a = e.animation.timelines.length, i = e.timelineMode; i.length = a; let c = e.timelineHoldMix; c.length = 0; let o = this.propertyIDs; if (r && r.holdPrevious) { for (let s = 0; s < a; s++)i[s] = o.addAll(t[s].getPropertyIds()) ? nr : Sr; return } e: for (let s = 0; s < a; s++) { let l = t[s], n = l.getPropertyIds(); if (!o.addAll(n)) i[s] = ar; else if (!r || l instanceof me || l instanceof fe || l instanceof ve || !r.animation.hasTimeline(n)) i[s] = Ir; else { for (let h = r.mixingTo; h; h = h.mixingTo)if (!h.animation.hasTimeline(n)) { if (e.mixDuration > 0) { i[s] = Pr, c[s] = h; continue e } break } i[s] = nr } } } getCurrent (e) { return e >= this.tracks.length ? null : this.tracks[e] } addListener (e) { if (!e) throw new Error("listener cannot be null."); this.listeners.push(e) } removeListener (e) { let r = this.listeners.indexOf(e); r >= 0 && this.listeners.splice(r, 1) } clearListeners () { this.listeners.length = 0 } clearListenerNotifications () { this.queue.clear() } }, Ot = zt; F(Ot, "AnimationState"), N(Ot, "_emptyAnimation", new Ce("<empty>", [], 0)); var Ut = class { animation = null; previous = null; next = null; mixingFrom = null; mixingTo = null; listener = null; trackIndex = 0; loop = !1; holdPrevious = !1; reverse = !1; shortestRotation = !1; eventThreshold = 0; attachmentThreshold = 0; drawOrderThreshold = 0; animationStart = 0; animationEnd = 0; animationLast = 0; nextAnimationLast = 0; delay = 0; trackTime = 0; trackLast = 0; nextTrackLast = 0; trackEnd = 0; timeScale = 0; alpha = 0; mixTime = 0; mixDuration = 0; interruptAlpha = 0; totalAlpha = 0; mixBlend = C.replace; timelineMode = new Array; timelineHoldMix = new Array; timelinesRotation = new Array; reset () { this.next = null, this.previous = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0 } getAnimationTime () { if (this.loop) { let e = this.animationEnd - this.animationStart; return e == 0 ? this.animationStart : this.trackTime % e + this.animationStart } return Math.min(this.trackTime + this.animationStart, this.animationEnd) } setAnimationLast (e) { this.animationLast = e, this.nextAnimationLast = e } isComplete () { return this.trackTime >= this.animationEnd - this.animationStart } resetRotationDirections () { this.timelinesRotation.length = 0 } getTrackComplete () { let e = this.animationEnd - this.animationStart; if (e != 0) { if (this.loop) return e * (1 + (this.trackTime / e | 0)); if (this.trackTime < e) return e } return this.trackTime } }; F(Ut, "TrackEntry"); var Wt = class { objects = []; drainDisabled = !1; animState; constructor(e) { this.animState = e } start (e) { this.objects.push(oe.start), this.objects.push(e), this.animState.animationsChanged = !0 } interrupt (e) { this.objects.push(oe.interrupt), this.objects.push(e) } end (e) { this.objects.push(oe.end), this.objects.push(e), this.animState.animationsChanged = !0 } dispose (e) { this.objects.push(oe.dispose), this.objects.push(e) } complete (e) { this.objects.push(oe.complete), this.objects.push(e) } event (e, r) { this.objects.push(oe.event), this.objects.push(e), this.objects.push(r) } drain () { if (this.drainDisabled) return; this.drainDisabled = !0; let e = this.objects, r = this.animState.listeners; for (let t = 0; t < e.length; t += 2) { let a = e[t], i = e[t + 1]; switch (a) { case oe.start: i.listener && i.listener.start && i.listener.start(i); for (let o = 0; o < r.length; o++) { let s = r[o]; s.start && s.start(i) } break; case oe.interrupt: i.listener && i.listener.interrupt && i.listener.interrupt(i); for (let o = 0; o < r.length; o++) { let s = r[o]; s.interrupt && s.interrupt(i) } break; case oe.end: i.listener && i.listener.end && i.listener.end(i); for (let o = 0; o < r.length; o++) { let s = r[o]; s.end && s.end(i) } case oe.dispose: i.listener && i.listener.dispose && i.listener.dispose(i); for (let o = 0; o < r.length; o++) { let s = r[o]; s.dispose && s.dispose(i) } this.animState.trackEntryPool.free(i); break; case oe.complete: i.listener && i.listener.complete && i.listener.complete(i); for (let o = 0; o < r.length; o++) { let s = r[o]; s.complete && s.complete(i) } break; case oe.event: let c = e[t++ + 2]; i.listener && i.listener.event && i.listener.event(i, c); for (let o = 0; o < r.length; o++) { let s = r[o]; s.event && s.event(i, c) } break } } this.clear(), this.drainDisabled = !1 } clear () { this.objects.length = 0 } }; F(Wt, "EventQueue"); var oe; (function (Y) { Y[Y.start = 0] = "start", Y[Y.interrupt = 1] = "interrupt", Y[Y.end = 2] = "end", Y[Y.dispose = 3] = "dispose", Y[Y.complete = 4] = "complete", Y[Y.event = 5] = "event" })(oe || (oe = {})); var ir = class { start (e) { } interrupt (e) { } end (e) { } dispose (e) { } complete (e) { } event (e, r) { } }; F(ir, "AnimationStateAdapter"); var ar = 0, Ir = 1, Sr = 2, nr = 3, Pr = 4, kr = 1, Vr = 2; var lr = class { skeletonData; animationToMixTime = {}; defaultMix = 0; constructor(e) { if (!e) throw new Error("skeletonData cannot be null."); this.skeletonData = e } setMix (e, r, t) { let a = this.skeletonData.findAnimation(e); if (!a) throw new Error("Animation not found: " + e); let i = this.skeletonData.findAnimation(r); if (!i) throw new Error("Animation not found: " + r); this.setMixWith(a, i, t) } setMixWith (e, r, t) { if (!e) throw new Error("from cannot be null."); if (!r) throw new Error("to cannot be null."); let a = e.name + "." + r.name; this.animationToMixTime[a] = t } getMix (e, r) { let t = e.name + "." + r.name, a = this.animationToMixTime[t]; return a === void 0 ? this.defaultMix : a } }; F(lr, "AnimationStateData"); var Ae = class extends te { color = new D(1, 1, 1, 1); constructor(e) { super(e) } copy () { let e = new Ae(this.name); return this.copyTo(e), e.color.setFromColor(this.color), e } }; F(Ae, "BoundingBoxAttachment"); var ot = class extends te { endSlot = null; color = new D(.2275, .2275, .8078, 1); constructor(e) { super(e) } copy () { let e = new ot(this.name); return this.copyTo(e), e.endSlot = this.endSlot, e.color.setFromColor(this.color), e } }; F(ot, "ClippingAttachment"); var $t = class { _image; constructor(e) { this._image = e } getImage () { return this._image } }; F($t, "Texture"); var ht; (function (Y) { Y[Y.Nearest = 9728] = "Nearest", Y[Y.Linear = 9729] = "Linear", Y[Y.MipMap = 9987] = "MipMap", Y[Y.MipMapNearestNearest = 9984] = "MipMapNearestNearest", Y[Y.MipMapLinearNearest = 9985] = "MipMapLinearNearest", Y[Y.MipMapNearestLinear = 9986] = "MipMapNearestLinear", Y[Y.MipMapLinearLinear = 9987] = "MipMapLinearLinear" })(ht || (ht = {})); var ct; (function (Y) { Y[Y.MirroredRepeat = 33648] = "MirroredRepeat", Y[Y.ClampToEdge = 33071] = "ClampToEdge", Y[Y.Repeat = 10497] = "Repeat" })(ct || (ct = {})); var Ft = class { texture; u = 0; v = 0; u2 = 0; v2 = 0; width = 0; height = 0; degrees = 0; offsetX = 0; offsetY = 0; originalWidth = 0; originalHeight = 0 }; F(Ft, "TextureRegion"); var or = class extends $t { setFilters (e, r) { } setWraps (e, r) { } dispose () { } }; F(or, "FakeTexture"); var Mt = class { pages = new Array; regions = new Array; constructor(e) { let r = new hr(e), t = new Array(4), a = {}; a.size = n => { n.width = parseInt(t[1]), n.height = parseInt(t[2]) }, a.format = () => { }, a.filter = n => { n.minFilter = V.enumValue(ht, t[1]), n.magFilter = V.enumValue(ht, t[2]) }, a.repeat = n => { t[1].indexOf("x") != -1 && (n.uWrap = ct.Repeat), t[1].indexOf("y") != -1 && (n.vWrap = ct.Repeat) }, a.pma = n => { n.pma = t[1] == "true" }; var i = {}; i.xy = n => { n.x = parseInt(t[1]), n.y = parseInt(t[2]) }, i.size = n => { n.width = parseInt(t[1]), n.height = parseInt(t[2]) }, i.bounds = n => { n.x = parseInt(t[1]), n.y = parseInt(t[2]), n.width = parseInt(t[3]), n.height = parseInt(t[4]) }, i.offset = n => { n.offsetX = parseInt(t[1]), n.offsetY = parseInt(t[2]) }, i.orig = n => { n.originalWidth = parseInt(t[1]), n.originalHeight = parseInt(t[2]) }, i.offsets = n => { n.offsetX = parseInt(t[1]), n.offsetY = parseInt(t[2]), n.originalWidth = parseInt(t[3]), n.originalHeight = parseInt(t[4]) }, i.rotate = n => { let h = t[1]; h == "true" ? n.degrees = 90 : h != "false" && (n.degrees = parseInt(h)) }, i.index = n => { n.index = parseInt(t[1]) }; let c = r.readLine(); for (; c && c.trim().length == 0;)c = r.readLine(); for (; !(!c || c.trim().length == 0 || r.readEntry(t, c) == 0);)c = r.readLine(); let o = null, s = null, l = null; for (; c !== null;)if (c.trim().length == 0) o = null, c = r.readLine(); else if (o) { let n = new It(o, c); for (; ;) { let h = r.readEntry(t, c = r.readLine()); if (h == 0) break; let d = i[t[0]]; if (d) d(n); else { s || (s = []), l || (l = []), s.push(t[0]); let f = []; for (let m = 0; m < h; m++)f.push(parseInt(t[m + 1])); l.push(f) } } n.originalWidth == 0 && n.originalHeight == 0 && (n.originalWidth = n.width, n.originalHeight = n.height), s && s.length > 0 && l && l.length > 0 && (n.names = s, n.values = l, s = null, l = null), n.u = n.x / o.width, n.v = n.y / o.height, n.degrees == 90 ? (n.u2 = (n.x + n.height) / o.width, n.v2 = (n.y + n.width) / o.height) : (n.u2 = (n.x + n.width) / o.width, n.v2 = (n.y + n.height) / o.height), this.regions.push(n) } else { for (o = new Ht(c.trim()); r.readEntry(t, c = r.readLine()) != 0;) { let n = a[t[0]]; n && n(o) } this.pages.push(o) } } findRegion (e) { for (let r = 0; r < this.regions.length; r++)if (this.regions[r].name == e) return this.regions[r]; return null } setTextures (e, r = "") { for (let t of this.pages) t.setTexture(e.get(r + t.name)) } dispose () { for (let e = 0; e < this.pages.length; e++)this.pages[e].texture?.dispose() } }; F(Mt, "TextureAtlas"); var hr = class { lines; index = 0; constructor(e) { this.lines = e.split(/\r\n|\r|\n/) } readLine () { return this.index >= this.lines.length ? null : this.lines[this.index++] } readEntry (e, r) { if (!r || (r = r.trim(), r.length == 0)) return 0; let t = r.indexOf(":"); if (t == -1) return 0; e[0] = r.substr(0, t).trim(); for (let a = 1, i = t + 1; ; a++) { let c = r.indexOf(",", i); if (c == -1) return e[a] = r.substr(i).trim(), a; if (e[a] = r.substr(i, c - i).trim(), i = c + 1, a == 4) return 4 } } }; F(hr, "TextureAtlasReader"); var Ht = class { name; minFilter = ht.Nearest; magFilter = ht.Nearest; uWrap = ct.ClampToEdge; vWrap = ct.ClampToEdge; texture = null; width = 0; height = 0; pma = !1; regions = new Array; constructor(e) { this.name = e } setTexture (e) { this.texture = e, e.setFilters(this.minFilter, this.magFilter), e.setWraps(this.uWrap, this.vWrap); for (let r of this.regions) r.texture = e } }; F(Ht, "TextureAtlasPage"); var It = class extends Ft { page; name; x = 0; y = 0; offsetX = 0; offsetY = 0; originalWidth = 0; originalHeight = 0; index = 0; degrees = 0; names = null; values = null; constructor(e, r) { super(), this.page = e, this.name = r, e.regions.push(this) } }; F(It, "TextureAtlasRegion"); var ue = class extends te { region = null; path; regionUVs = []; uvs = []; triangles = []; color = new D(1, 1, 1, 1); width = 0; height = 0; hullLength = 0; edges = []; parentMesh = null; sequence = null; tempColor = new D(0, 0, 0, 0); constructor(e, r) { super(e), this.path = r } updateRegion () { if (!this.region) throw new Error("Region not set."); let e = this.regionUVs; (!this.uvs || this.uvs.length != e.length) && (this.uvs = V.newFloatArray(e.length)); let r = this.uvs, t = this.uvs.length, a = this.region.u, i = this.region.v, c = 0, o = 0; if (this.region instanceof It) { let s = this.region, l = s.page.texture.getImage(), n = l.width, h = l.height; switch (s.degrees) { case 90: a -= (s.originalHeight - s.offsetY - s.height) / n, i -= (s.originalWidth - s.offsetX - s.width) / h, c = s.originalHeight / n, o = s.originalWidth / h; for (let d = 0; d < t; d += 2)r[d] = a + e[d + 1] * c, r[d + 1] = i + (1 - e[d]) * o; return; case 180: a -= (s.originalWidth - s.offsetX - s.width) / n, i -= s.offsetY / h, c = s.originalWidth / n, o = s.originalHeight / h; for (let d = 0; d < t; d += 2)r[d] = a + (1 - e[d]) * c, r[d + 1] = i + (1 - e[d + 1]) * o; return; case 270: a -= s.offsetY / n, i -= s.offsetX / h, c = s.originalHeight / n, o = s.originalWidth / h; for (let d = 0; d < t; d += 2)r[d] = a + (1 - e[d + 1]) * c, r[d + 1] = i + e[d] * o; return }a -= s.offsetX / n, i -= (s.originalHeight - s.offsetY - s.height) / h, c = s.originalWidth / n, o = s.originalHeight / h } else this.region ? (c = this.region.u2 - a, o = this.region.v2 - i) : (a = i = 0, c = o = 1); for (let s = 0; s < t; s += 2)r[s] = a + e[s] * c, r[s + 1] = i + e[s + 1] * o } getParentMesh () { return this.parentMesh } setParentMesh (e) { this.parentMesh = e, e && (this.bones = e.bones, this.vertices = e.vertices, this.worldVerticesLength = e.worldVerticesLength, this.regionUVs = e.regionUVs, this.triangles = e.triangles, this.hullLength = e.hullLength, this.worldVerticesLength = e.worldVerticesLength) } copy () { if (this.parentMesh) return this.newLinkedMesh(); let e = new ue(this.name, this.path); return e.region = this.region, e.color.setFromColor(this.color), this.copyTo(e), e.regionUVs = new Array(this.regionUVs.length), V.arrayCopy(this.regionUVs, 0, e.regionUVs, 0, this.regionUVs.length), e.uvs = new Array(this.uvs.length), V.arrayCopy(this.uvs, 0, e.uvs, 0, this.uvs.length), e.triangles = new Array(this.triangles.length), V.arrayCopy(this.triangles, 0, e.triangles, 0, this.triangles.length), e.hullLength = this.hullLength, e.sequence = this.sequence != null ? this.sequence.copy() : null, this.edges && (e.edges = new Array(this.edges.length), V.arrayCopy(this.edges, 0, e.edges, 0, this.edges.length)), e.width = this.width, e.height = this.height, e } computeWorldVertices (e, r, t, a, i, c) { this.sequence != null && this.sequence.apply(e, this), super.computeWorldVertices(e, r, t, a, i, c) } newLinkedMesh () { let e = new ue(this.name, this.path); return e.region = this.region, e.color.setFromColor(this.color), e.timelineAttachment = this.timelineAttachment, e.setParentMesh(this.parentMesh ? this.parentMesh : this), e.region != null && e.updateRegion(), e } }; F(ue, "MeshAttachment"); var ge = class extends te { lengths = []; closed = !1; constantSpeed = !1; color = new D(1, 1, 1, 1); constructor(e) { super(e) } copy () { let e = new ge(this.name); return this.copyTo(e), e.lengths = new Array(this.lengths.length), V.arrayCopy(this.lengths, 0, e.lengths, 0, this.lengths.length), e.closed = closed, e.constantSpeed = this.constantSpeed, e.color.setFromColor(this.color), e } }; F(ge, "PathAttachment"); var dt = class extends te { x = 0; y = 0; rotation = 0; color = new D(.38, .94, 0, 1); constructor(e) { super(e) } computeWorldPosition (e, r) { return r.x = this.x * e.a + this.y * e.b + e.worldX, r.y = this.x * e.c + this.y * e.d + e.worldY, r } computeWorldRotation (e) { let r = E.cosDeg(this.rotation), t = E.sinDeg(this.rotation), a = r * e.a + t * e.b, i = r * e.c + t * e.d; return Math.atan2(i, a) * E.radDeg } copy () { let e = new dt(this.name); return e.x = this.x, e.y = this.y, e.rotation = this.rotation, e.color.setFromColor(this.color), e } }; F(dt, "PointAttachment"); var Cr = class extends vt { x = 0; y = 0; scaleX = 1; scaleY = 1; rotation = 0; width = 0; height = 0; color = new D(1, 1, 1, 1); path; region = null; sequence = null; offset = V.newFloatArray(8); uvs = V.newFloatArray(8); tempColor = new D(1, 1, 1, 1); constructor(e, r) { super(e), this.path = r } updateRegion () { if (!this.region) throw new Error("Region not set."); let e = this.region, r = this.uvs; if (e == null) { r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 1, r[5] = 1, r[6] = 1, r[7] = 0; return } let t = this.width / this.region.originalWidth * this.scaleX, a = this.height / this.region.originalHeight * this.scaleY, i = -this.width / 2 * this.scaleX + this.region.offsetX * t, c = -this.height / 2 * this.scaleY + this.region.offsetY * a, o = i + this.region.width * t, s = c + this.region.height * a, l = this.rotation * Math.PI / 180, n = Math.cos(l), h = Math.sin(l), d = this.x, f = this.y, m = i * n + d, x = i * h, p = c * n + f, b = c * h, y = o * n + d, u = o * h, g = s * n + f, w = s * h, v = this.offset; v[0] = m - b, v[1] = p + x, v[2] = m - w, v[3] = g + x, v[4] = y - w, v[5] = g + u, v[6] = y - b, v[7] = p + u, e.degrees == 90 ? (r[0] = e.u2, r[1] = e.v2, r[2] = e.u, r[3] = e.v2, r[4] = e.u, r[5] = e.v, r[6] = e.u2, r[7] = e.v) : (r[0] = e.u, r[1] = e.v2, r[2] = e.u, r[3] = e.v, r[4] = e.u2, r[5] = e.v, r[6] = e.u2, r[7] = e.v2) } computeWorldVertices (e, r, t, a) { this.sequence != null && this.sequence.apply(e, this); let i = e.bone, c = this.offset, o = i.worldX, s = i.worldY, l = i.a, n = i.b, h = i.c, d = i.d, f = 0, m = 0; f = c[0], m = c[1], r[t] = f * l + m * n + o, r[t + 1] = f * h + m * d + s, t += a, f = c[2], m = c[3], r[t] = f * l + m * n + o, r[t + 1] = f * h + m * d + s, t += a, f = c[4], m = c[5], r[t] = f * l + m * n + o, r[t + 1] = f * h + m * d + s, t += a, f = c[6], m = c[7], r[t] = f * l + m * n + o, r[t + 1] = f * h + m * d + s } copy () { let e = new Cr(this.name, this.path); return e.region = this.region, e.x = this.x, e.y = this.y, e.scaleX = this.scaleX, e.scaleY = this.scaleY, e.rotation = this.rotation, e.width = this.width, e.height = this.height, V.arrayCopy(this.uvs, 0, e.uvs, 0, 8), V.arrayCopy(this.offset, 0, e.offset, 0, 8), e.color.setFromColor(this.color), e.sequence = this.sequence != null ? this.sequence.copy() : null, e } }, $ = Cr; F($, "RegionAttachment"), N($, "X1", 0), N($, "Y1", 1), N($, "C1R", 2), N($, "C1G", 3), N($, "C1B", 4), N($, "C1A", 5), N($, "U1", 6), N($, "V1", 7), N($, "X2", 8), N($, "Y2", 9), N($, "C2R", 10), N($, "C2G", 11), N($, "C2B", 12), N($, "C2A", 13), N($, "U2", 14), N($, "V2", 15), N($, "X3", 16), N($, "Y3", 17), N($, "C3R", 18), N($, "C3G", 19), N($, "C3B", 20), N($, "C3A", 21), N($, "U3", 22), N($, "V3", 23), N($, "X4", 24), N($, "Y4", 25), N($, "C4R", 26), N($, "C4G", 27), N($, "C4B", 28), N($, "C4A", 29), N($, "U4", 30), N($, "V4", 31); var cr = class { atlas; constructor(e) { this.atlas = e } loadSequence (e, r, t) { let a = t.regions; for (let i = 0, c = a.length; i < c; i++) { let o = t.getPath(r, i), s = this.atlas.findRegion(o); if (s == null) throw new Error("Region not found in atlas: " + o + " (sequence: " + e + ")"); a[i] = s } } newRegionAttachment (e, r, t, a) { let i = new $(r, t); if (a != null) this.loadSequence(r, t, a); else { let c = this.atlas.findRegion(t); if (!c) throw new Error("Region not found in atlas: " + t + " (region attachment: " + r + ")"); i.region = c } return i } newMeshAttachment (e, r, t, a) { let i = new ue(r, t); if (a != null) this.loadSequence(r, t, a); else { let c = this.atlas.findRegion(t); if (!c) throw new Error("Region not found in atlas: " + t + " (mesh attachment: " + r + ")"); i.region = c } return i } newBoundingBoxAttachment (e, r) { return new Ae(r) } newPathAttachment (e, r) { return new ge(r) } newPointAttachment (e, r) { return new dt(r) } newClippingAttachment (e, r) { return new ot(r) } }; F(cr, "AtlasAttachmentLoader"); var ft = class { index = 0; name; parent = null; length = 0; x = 0; y = 0; rotation = 0; scaleX = 1; scaleY = 1; shearX = 0; shearY = 0; transformMode = ie.Normal; skinRequired = !1; color = new D; constructor(e, r, t) { if (e < 0) throw new Error("index must be >= 0."); if (!r) throw new Error("name cannot be null."); this.index = e, this.name = r, this.parent = t } }; F(ft, "BoneData"); var ie; (function (Y) { Y[Y.Normal = 0] = "Normal", Y[Y.OnlyTranslation = 1] = "OnlyTranslation", Y[Y.NoRotationOrReflection = 2] = "NoRotationOrReflection", Y[Y.NoScale = 3] = "NoScale", Y[Y.NoScaleOrReflection = 4] = "NoScaleOrReflection" })(ie || (ie = {})); var St = class { data; skeleton; parent = null; children = new Array; x = 0; y = 0; rotation = 0; scaleX = 0; scaleY = 0; shearX = 0; shearY = 0; ax = 0; ay = 0; arotation = 0; ascaleX = 0; ascaleY = 0; ashearX = 0; ashearY = 0; a = 0; b = 0; c = 0; d = 0; worldY = 0; worldX = 0; sorted = !1; active = !1; constructor(e, r, t) { if (!e) throw new Error("data cannot be null."); if (!r) throw new Error("skeleton cannot be null."); this.data = e, this.skeleton = r, this.parent = t, this.setToSetupPose() } isActive () { return this.active } update () { this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY) } updateWorldTransform () { this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY) } updateWorldTransformWith (e, r, t, a, i, c, o) { this.ax = e, this.ay = r, this.arotation = t, this.ascaleX = a, this.ascaleY = i, this.ashearX = c, this.ashearY = o; let s = this.parent; if (!s) { let f = this.skeleton, m = t + 90 + o, x = f.scaleX, p = f.scaleY; this.a = E.cosDeg(t + c) * a * x, this.b = E.cosDeg(m) * i * x, this.c = E.sinDeg(t + c) * a * p, this.d = E.sinDeg(m) * i * p, this.worldX = e * x + f.x, this.worldY = r * p + f.y; return } let l = s.a, n = s.b, h = s.c, d = s.d; switch (this.worldX = l * e + n * r + s.worldX, this.worldY = h * e + d * r + s.worldY, this.data.transformMode) { case ie.Normal: { let f = t + 90 + o, m = E.cosDeg(t + c) * a, x = E.cosDeg(f) * i, p = E.sinDeg(t + c) * a, b = E.sinDeg(f) * i; this.a = l * m + n * p, this.b = l * x + n * b, this.c = h * m + d * p, this.d = h * x + d * b; return } case ie.OnlyTranslation: { let f = t + 90 + o; this.a = E.cosDeg(t + c) * a, this.b = E.cosDeg(f) * i, this.c = E.sinDeg(t + c) * a, this.d = E.sinDeg(f) * i; break } case ie.NoRotationOrReflection: { let f = l * l + h * h, m = 0; f > 1e-4 ? (f = Math.abs(l * d - n * h) / f, l /= this.skeleton.scaleX, h /= this.skeleton.scaleY, n = h * f, d = l * f, m = Math.atan2(h, l) * E.radDeg) : (l = 0, h = 0, m = 90 - Math.atan2(d, n) * E.radDeg); let x = t + c - m, p = t + o - m + 90, b = E.cosDeg(x) * a, y = E.cosDeg(p) * i, u = E.sinDeg(x) * a, g = E.sinDeg(p) * i; this.a = l * b - n * u, this.b = l * y - n * g, this.c = h * b + d * u, this.d = h * y + d * g; break } case ie.NoScale: case ie.NoScaleOrReflection: { let f = E.cosDeg(t), m = E.sinDeg(t), x = (l * f + n * m) / this.skeleton.scaleX, p = (h * f + d * m) / this.skeleton.scaleY, b = Math.sqrt(x * x + p * p); b > 1e-5 && (b = 1 / b), x *= b, p *= b, b = Math.sqrt(x * x + p * p), this.data.transformMode == ie.NoScale && l * d - n * h < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (b = -b); let y = Math.PI / 2 + Math.atan2(p, x), u = Math.cos(y) * b, g = Math.sin(y) * b, w = E.cosDeg(c) * a, v = E.cosDeg(90 + o) * i, I = E.sinDeg(c) * a, S = E.sinDeg(90 + o) * i; this.a = x * w + u * I, this.b = x * v + u * S, this.c = p * w + g * I, this.d = p * v + g * S; break } }this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, this.d *= this.skeleton.scaleY } setToSetupPose () { let e = this.data; this.x = e.x, this.y = e.y, this.rotation = e.rotation, this.scaleX = e.scaleX, this.scaleY = e.scaleY, this.shearX = e.shearX, this.shearY = e.shearY } getWorldRotationX () { return Math.atan2(this.c, this.a) * E.radDeg } getWorldRotationY () { return Math.atan2(this.d, this.b) * E.radDeg } getWorldScaleX () { return Math.sqrt(this.a * this.a + this.c * this.c) } getWorldScaleY () { return Math.sqrt(this.b * this.b + this.d * this.d) } updateAppliedTransform () { let e = this.parent; if (!e) { this.ax = this.worldX - this.skeleton.x, this.ay = this.worldY - this.skeleton.y, this.arotation = Math.atan2(this.c, this.a) * E.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * E.radDeg; return } let r = e.a, t = e.b, a = e.c, i = e.d, c = 1 / (r * i - t * a), o = this.worldX - e.worldX, s = this.worldY - e.worldY; this.ax = o * i * c - s * t * c, this.ay = s * r * c - o * a * c; let l = c * i, n = c * r, h = c * t, d = c * a, f = l * this.a - h * this.c, m = l * this.b - h * this.d, x = n * this.c - d * this.a, p = n * this.d - d * this.b; if (this.ashearX = 0, this.ascaleX = Math.sqrt(f * f + x * x), this.ascaleX > 1e-4) { let b = f * p - m * x; this.ascaleY = b / this.ascaleX, this.ashearY = Math.atan2(f * m + x * p, b) * E.radDeg, this.arotation = Math.atan2(x, f) * E.radDeg } else this.ascaleX = 0, this.ascaleY = Math.sqrt(m * m + p * p), this.ashearY = 0, this.arotation = 90 - Math.atan2(p, m) * E.radDeg } worldToLocal (e) { let r = 1 / (this.a * this.d - this.b * this.c), t = e.x - this.worldX, a = e.y - this.worldY; return e.x = t * this.d * r - a * this.b * r, e.y = a * this.a * r - t * this.c * r, e } localToWorld (e) { let r = e.x, t = e.y; return e.x = r * this.a + t * this.b + this.worldX, e.y = r * this.c + t * this.d + this.worldY, e } worldToLocalRotation (e) { let r = E.sinDeg(e), t = E.cosDeg(e); return Math.atan2(this.a * r - this.c * t, this.d * t - this.b * r) * E.radDeg + this.rotation - this.shearX } localToWorldRotation (e) { e -= this.rotation - this.shearX; let r = E.sinDeg(e), t = E.cosDeg(e); return Math.atan2(t * this.c + r * this.d, t * this.a + r * this.b) * E.radDeg } rotateWorld (e) { let r = this.a, t = this.b, a = this.c, i = this.d, c = E.cosDeg(e), o = E.sinDeg(e); this.a = c * r - o * a, this.b = c * t - o * i, this.c = o * r + c * a, this.d = o * t + c * i } }; F(St, "Bone"); var Xe = class { name; order; skinRequired; constructor(e, r, t) { this.name = e, this.order = r, this.skinRequired = t } }; F(Xe, "ConstraintData"); var dr = class {
          pathPrefix = ""; textureLoader; downloader; assets = {}; errors = {}; toLoad = 0; loaded = 0; constructor(e, r = "", t = new _t) { this.textureLoader = e, this.pathPrefix = r, this.downloader = t } start (e) { return this.toLoad++, this.pathPrefix + e } success (e, r, t) { this.toLoad--, this.loaded++, this.assets[r] = t, e && e(r, t) } error (e, r, t) { this.toLoad--, this.loaded++, this.errors[r] = t, e && e(r, t) } loadAll () { return new Promise((r, t) => { let a = F(() => { if (this.isLoadingComplete()) { this.hasErrors() ? t(this.errors) : r(this); return } requestAnimationFrame(a) }, "check"); requestAnimationFrame(a) }) } setRawDataURI (e, r) { this.downloader.rawDataUris[this.pathPrefix + e] = r } loadBinary (e, r = () => { }, t = () => { }) { e = this.start(e), this.downloader.downloadBinary(e, a => { this.success(r, e, a) }, (a, i) => { this.error(t, e, `Couldn't load binary ${e}: status ${a}, ${i}`) }) } loadText (e, r = () => { }, t = () => { }) { e = this.start(e), this.downloader.downloadText(e, a => { this.success(r, e, a) }, (a, i) => { this.error(t, e, `Couldn't load text ${e}: status ${a}, ${i}`) }) } loadJson (e, r = () => { }, t = () => { }) { e = this.start(e), this.downloader.downloadJson(e, a => { this.success(r, e, a) }, (a, i) => { this.error(t, e, `Couldn't load JSON ${e}: status ${a}, ${i}`) }) } loadTexture (e, r = () => { }, t = () => { }) { if (e = this.start(e), !!!(typeof window < "u" && typeof navigator < "u" && window.document)) fetch(e, { mode: "cors" }).then(c => c.ok ? c.blob() : (this.error(t, e, `Couldn't load image: ${e}`), null)).then(c => c ? createImageBitmap(c, { premultiplyAlpha: "none", colorSpaceConversion: "none" }) : null).then(c => { c && this.success(r, e, this.textureLoader(c)) }); else { let c = new Image; c.crossOrigin = "anonymous", c.onload = () => { this.success(r, e, this.textureLoader(c)) }, c.onerror = () => { this.error(t, e, `Couldn't load image: ${e}`) }, this.downloader.rawDataUris[e] && (e = this.downloader.rawDataUris[e]), c.src = e } } loadTextureAtlas (e, r = () => { }, t = () => { }, a) { let i = e.lastIndexOf("/"), c = i >= 0 ? e.substring(0, i + 1) : ""; e = this.start(e), this.downloader.downloadText(e, o => { try { let s = new Mt(o), l = s.pages.length, n = !1; for (let h of s.pages) this.loadTexture(a ? a[h.name] : c + h.name, (d, f) => { n || (h.setTexture(f), --l == 0 && this.success(r, e, s)) }, (d, f) => { n || this.error(t, e, `Couldn't load texture atlas ${e} page image: ${d}`), n = !0 }) } catch (s) { this.error(t, e, `Couldn't parse texture atlas ${e}: ${s.message}`) } }, (o, s) => { this.error(t, e, `Couldn't load texture atlas ${e}: status ${o}, ${s}`) }) } get (e) { return this.assets[this.pathPrefix + e] } require (e) {
            e = this.pathPrefix + e; let r = this.assets[e]; if (r) return r; let t = this.errors[e]; throw Error("Asset not found: " + e + (t ? `
`+ t : ""))
          } remove (e) { e = this.pathPrefix + e; let r = this.assets[e]; return r.dispose && r.dispose(), delete this.assets[e], r } removeAll () { for (let e in this.assets) { let r = this.assets[e]; r.dispose && r.dispose() } this.assets = {} } isLoadingComplete () { return this.toLoad == 0 } getToLoad () { return this.toLoad } getLoaded () { return this.loaded } dispose () { this.removeAll() } hasErrors () { return Object.keys(this.errors).length > 0 } getErrors () { return this.errors }
        }; F(dr, "AssetManagerBase"); var _t = class { callbacks = {}; rawDataUris = {}; dataUriToString (e) { if (!e.startsWith("data:")) throw new Error("Not a data URI."); let r = e.indexOf("base64,"); return r != -1 ? (r += 7, atob(e.substr(r))) : e.substr(e.indexOf(",") + 1) } base64ToUint8Array (e) { for (var r = window.atob(e), t = r.length, a = new Uint8Array(t), i = 0; i < t; i++)a[i] = r.charCodeAt(i); return a } dataUriToUint8Array (e) { if (!e.startsWith("data:")) throw new Error("Not a data URI."); let r = e.indexOf("base64,"); if (r == -1) throw new Error("Not a binary data URI."); return r += 7, this.base64ToUint8Array(e.substr(r)) } downloadText (e, r, t) { if (this.start(e, r, t)) return; if (this.rawDataUris[e]) { try { let c = this.rawDataUris[e]; this.finish(e, 200, this.dataUriToString(c)) } catch (c) { this.finish(e, 400, JSON.stringify(c)) } return } let a = new XMLHttpRequest; a.overrideMimeType("text/html"), a.open("GET", e, !0); let i = F(() => { this.finish(e, a.status, a.responseText) }, "done"); a.onload = i, a.onerror = i, a.send() } downloadJson (e, r, t) { this.downloadText(e, a => { r(JSON.parse(a)) }, t) } downloadBinary (e, r, t) { if (this.start(e, r, t)) return; if (this.rawDataUris[e]) { try { let c = this.rawDataUris[e]; this.finish(e, 200, this.dataUriToUint8Array(c)) } catch (c) { this.finish(e, 400, JSON.stringify(c)) } return } let a = new XMLHttpRequest; a.open("GET", e, !0), a.responseType = "arraybuffer"; let i = F(() => { this.finish(e, a.status, a.response) }, "onerror"); a.onload = () => { a.status == 200 || a.status == 0 ? this.finish(e, 200, new Uint8Array(a.response)) : i() }, a.onerror = i, a.send() } start (e, r, t) { let a = this.callbacks[e]; try { if (a) return !0; this.callbacks[e] = a = [] } finally { a.push(r, t) } } finish (e, r, t) { let a = this.callbacks[e]; delete this.callbacks[e]; let i = r == 200 || r == 0 ? [t] : [r, t]; for (let c = i.length - 1, o = a.length; c < o; c += 2)a[c].apply(null, i) } }; F(_t, "Downloader"); var mt = class { data; intValue = 0; floatValue = 0; stringValue = null; time = 0; volume = 0; balance = 0; constructor(e, r) { if (!r) throw new Error("data cannot be null."); this.time = e, this.data = r } }; F(mt, "Event"); var ut = class { name; intValue = 0; floatValue = 0; stringValue = null; audioPath = null; volume = 0; balance = 0; constructor(e) { this.name = e } }; F(ut, "EventData"); var Et = class { data; bones; target; bendDirection = 0; compress = !1; stretch = !1; mix = 1; softness = 0; active = !1; constructor(e, r) { if (!e) throw new Error("data cannot be null."); if (!r) throw new Error("skeleton cannot be null."); this.data = e, this.mix = e.mix, this.softness = e.softness, this.bendDirection = e.bendDirection, this.compress = e.compress, this.stretch = e.stretch, this.bones = new Array; for (let a = 0; a < e.bones.length; a++) { let i = r.findBone(e.bones[a].name); if (!i) throw new Error(`Couldn't find bone ${e.bones[a].name}`); this.bones.push(i) } let t = r.findBone(e.target.name); if (!t) throw new Error(`Couldn't find bone ${e.target.name}`); this.target = t } isActive () { return this.active } update () { if (this.mix == 0) return; let e = this.target, r = this.bones; switch (r.length) { case 1: this.apply1(r[0], e.worldX, e.worldY, this.compress, this.stretch, this.data.uniform, this.mix); break; case 2: this.apply2(r[0], r[1], e.worldX, e.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix); break } } apply1 (e, r, t, a, i, c, o) { let s = e.parent; if (!s) throw new Error("IK bone must have parent."); let l = s.a, n = s.b, h = s.c, d = s.d, f = -e.ashearX - e.arotation, m = 0, x = 0; switch (e.data.transformMode) { case ie.OnlyTranslation: m = (r - e.worldX) * E.signum(e.skeleton.scaleX), x = (t - e.worldY) * E.signum(e.skeleton.scaleY); break; case ie.NoRotationOrReflection: let y = Math.abs(l * d - n * h) / Math.max(1e-4, l * l + h * h), u = l / e.skeleton.scaleX, g = h / e.skeleton.scaleY; n = -g * y * e.skeleton.scaleX, d = u * y * e.skeleton.scaleY, f += Math.atan2(g, u) * E.radDeg; default: let w = r - s.worldX, v = t - s.worldY, I = l * d - n * h; Math.abs(I) <= 1e-4 ? (m = 0, x = 0) : (m = (w * d - v * n) / I - e.ax, x = (v * l - w * h) / I - e.ay) }f += Math.atan2(x, m) * E.radDeg, e.ascaleX < 0 && (f += 180), f > 180 ? f -= 360 : f < -180 && (f += 360); let p = e.ascaleX, b = e.ascaleY; if (a || i) { switch (e.data.transformMode) { case ie.NoScale: case ie.NoScaleOrReflection: m = r - e.worldX, x = t - e.worldY }let y = e.data.length * p, u = Math.sqrt(m * m + x * x); if (a && u < y || i && u > y && y > 1e-4) { let g = (u / y - 1) * o + 1; p *= g, c && (b *= g) } } e.updateWorldTransformWith(e.ax, e.ay, e.arotation + f * o, p, b, e.ashearX, e.ashearY) } apply2 (e, r, t, a, i, c, o, s, l) { let n = e.ax, h = e.ay, d = e.ascaleX, f = e.ascaleY, m = d, x = f, p = r.ascaleX, b = 0, y = 0, u = 0; d < 0 ? (d = -d, b = 180, u = -1) : (b = 0, u = 1), f < 0 && (f = -f, u = -u), p < 0 ? (p = -p, y = 180) : y = 0; let g = r.ax, w = 0, v = 0, I = 0, S = e.a, A = e.b, M = e.c, B = e.d, L = Math.abs(d - f) <= 1e-4; !L || c ? (w = 0, v = S * g + e.worldX, I = M * g + e.worldY) : (w = r.ay, v = S * g + A * w + e.worldX, I = M * g + B * w + e.worldY); let P = e.parent; if (!P) throw new Error("IK parent must itself have a parent."); S = P.a, A = P.b, M = P.c, B = P.d; let R = S * B - A * M, X = v - P.worldX, T = I - P.worldY; R = Math.abs(R) <= 1e-4 ? 0 : 1 / R; let q = (X * B - T * A) * R - n, H = (T * S - X * M) * R - h, O = Math.sqrt(q * q + H * H), _ = r.data.length * p, W, J; if (O < 1e-4) { this.apply1(e, t, a, !1, c, !1, l), r.updateWorldTransformWith(g, w, 0, r.ascaleX, r.ascaleY, r.ashearX, r.ashearY); return } X = t - P.worldX, T = a - P.worldY; let z = (X * B - T * A) * R - n, U = (T * S - X * M) * R - h, Q = z * z + U * U; if (s != 0) { s *= d * (p + 1) * .5; let ae = Math.sqrt(Q), xe = ae - O - _ * d + s; if (xe > 0) { let pe = Math.min(1, xe / (s * 2)) - 1; pe = (xe - s * (1 - pe * pe)) / ae, z -= pe * z, U -= pe * U, Q = z * z + U * U } } e: if (L) { _ *= d; let ae = (Q - O * O - _ * _) / (2 * O * _); ae < -1 ? (ae = -1, J = Math.PI * i) : ae > 1 ? (ae = 1, J = 0, c && (S = (Math.sqrt(Q) / (O + _) - 1) * l + 1, m *= S, o && (x *= S))) : J = Math.acos(ae) * i, S = O + _ * ae, A = _ * Math.sin(J), W = Math.atan2(U * S - z * A, z * S + U * A) } else { S = d * _, A = f * _; let ae = S * S, xe = A * A, pe = Math.atan2(U, z); M = xe * O * O + ae * Q - ae * xe; let Ne = -2 * xe * O, Ct = xe - ae; if (B = Ne * Ne - 4 * Ct * M, B >= 0) { let At = Math.sqrt(B); Ne < 0 && (At = -At), At = -(Ne + At) * .5; let Br = At / Ct, Rr = M / At, Xt = Math.abs(Br) < Math.abs(Rr) ? Br : Rr; if (Xt * Xt <= Q) { T = Math.sqrt(Q - Xt * Xt) * i, W = pe - Math.atan2(T, Xt), J = Math.atan2(T / f, (Xt - O) / d); break e } } let Vt = E.PI, Jt = O - S, wr = Jt * Jt, Mr = 0, Er = 0, Kt = O + S, br = Kt * Kt, Tr = 0; M = -S * O / (ae - xe), M >= -1 && M <= 1 && (M = Math.acos(M), X = S * Math.cos(M) + O, T = A * Math.sin(M), B = X * X + T * T, B < wr && (Vt = M, wr = B, Jt = X, Mr = T), B > br && (Er = M, br = B, Kt = X, Tr = T)), Q <= (wr + br) * .5 ? (W = pe - Math.atan2(Mr * i, Jt), J = Vt * i) : (W = pe - Math.atan2(Tr * i, Kt), J = Er * i) } let le = Math.atan2(w, g) * u, we = e.arotation; W = (W - le) * E.radDeg + b - we, W > 180 ? W -= 360 : W < -180 && (W += 360), e.updateWorldTransformWith(n, h, we + W * l, m, x, 0, 0), we = r.arotation, J = ((J + le) * E.radDeg - r.ashearX) * u + y - we, J > 180 ? J -= 360 : J < -180 && (J += 360), r.updateWorldTransformWith(g, w, we + J * l, r.ascaleX, r.ascaleY, r.ashearX, r.ashearY) } }; F(Et, "IkConstraint"); var gt = class extends Xe { bones = new Array; _target = null; set target (e) { this._target = e } get target () { if (this._target) return this._target; throw new Error("BoneData not set.") } bendDirection = 1; compress = !1; stretch = !1; uniform = !1; mix = 1; softness = 0; constructor(e) { super(e, 0, !1) } }; F(gt, "IkConstraintData"); var xt = class extends Xe { bones = new Array; _target = null; set target (e) { this._target = e } get target () { if (this._target) return this._target; throw new Error("SlotData not set.") } positionMode = de.Fixed; spacingMode = ee.Fixed; rotateMode = Fe.Chain; offsetRotation = 0; position = 0; spacing = 0; mixRotate = 0; mixX = 0; mixY = 0; constructor(e) { super(e, 0, !1) } }; F(xt, "PathConstraintData"); var de; (function (Y) { Y[Y.Fixed = 0] = "Fixed", Y[Y.Percent = 1] = "Percent" })(de || (de = {})); var ee; (function (Y) { Y[Y.Length = 0] = "Length", Y[Y.Fixed = 1] = "Fixed", Y[Y.Percent = 2] = "Percent", Y[Y.Proportional = 3] = "Proportional" })(ee || (ee = {})); var Fe; (function (Y) { Y[Y.Tangent = 0] = "Tangent", Y[Y.Chain = 1] = "Chain", Y[Y.ChainScale = 2] = "ChainScale" })(Fe || (Fe = {})); var Me = class { data; bones; target; position = 0; spacing = 0; mixRotate = 0; mixX = 0; mixY = 0; spaces = new Array; positions = new Array; world = new Array; curves = new Array; lengths = new Array; segments = new Array; active = !1; constructor(e, r) { if (!e) throw new Error("data cannot be null."); if (!r) throw new Error("skeleton cannot be null."); this.data = e, this.bones = new Array; for (let a = 0, i = e.bones.length; a < i; a++) { let c = r.findBone(e.bones[a].name); if (!c) throw new Error(`Couldn't find bone ${e.bones[a].name}.`); this.bones.push(c) } let t = r.findSlot(e.target.name); if (!t) throw new Error(`Couldn't find target bone ${e.target.name}`); this.target = t, this.position = e.position, this.spacing = e.spacing, this.mixRotate = e.mixRotate, this.mixX = e.mixX, this.mixY = e.mixY } isActive () { return this.active } update () { let e = this.target.getAttachment(); if (!(e instanceof ge)) return; let r = this.mixRotate, t = this.mixX, a = this.mixY; if (r == 0 && t == 0 && a == 0) return; let i = this.data, c = i.rotateMode == Fe.Tangent, o = i.rotateMode == Fe.ChainScale, s = this.bones, l = s.length, n = c ? l : l + 1, h = V.setArraySize(this.spaces, n), d = o ? this.lengths = V.setArraySize(this.lengths, l) : [], f = this.spacing; switch (i.spacingMode) { case ee.Percent: if (o) for (let w = 0, v = n - 1; w < v; w++) { let I = s[w], S = I.data.length; if (S < Me.epsilon) d[w] = 0; else { let A = S * I.a, M = S * I.c; d[w] = Math.sqrt(A * A + M * M) } } V.arrayFill(h, 1, n, f); break; case ee.Proportional: let u = 0; for (let w = 0, v = n - 1; w < v;) { let I = s[w], S = I.data.length; if (S < Me.epsilon) o && (d[w] = 0), h[++w] = f; else { let A = S * I.a, M = S * I.c, B = Math.sqrt(A * A + M * M); o && (d[w] = B), h[++w] = B, u += B } } if (u > 0) { u = n / u * f; for (let w = 1; w < n; w++)h[w] *= u } break; default: let g = i.spacingMode == ee.Length; for (let w = 0, v = n - 1; w < v;) { let I = s[w], S = I.data.length; if (S < Me.epsilon) o && (d[w] = 0), h[++w] = f; else { let A = S * I.a, M = S * I.c, B = Math.sqrt(A * A + M * M); o && (d[w] = B), h[++w] = (g ? S + f : f) * B / S } } }let m = this.computeWorldPositions(e, n, c), x = m[0], p = m[1], b = i.offsetRotation, y = !1; if (b == 0) y = i.rotateMode == Fe.Chain; else { y = !1; let u = this.target.bone; b *= u.a * u.d - u.b * u.c > 0 ? E.degRad : -E.degRad } for (let u = 0, g = 3; u < l; u++, g += 3) { let w = s[u]; w.worldX += (x - w.worldX) * t, w.worldY += (p - w.worldY) * a; let v = m[g], I = m[g + 1], S = v - x, A = I - p; if (o) { let M = d[u]; if (M != 0) { let B = (Math.sqrt(S * S + A * A) / M - 1) * r + 1; w.a *= B, w.c *= B } } if (x = v, p = I, r > 0) { let M = w.a, B = w.b, L = w.c, P = w.d, R = 0, X = 0, T = 0; if (c ? R = m[g - 1] : h[u + 1] == 0 ? R = m[g + 2] : R = Math.atan2(A, S), R -= Math.atan2(L, M), y) { X = Math.cos(R), T = Math.sin(R); let q = w.data.length; x += (q * (X * M - T * L) - S) * r, p += (q * (T * M + X * L) - A) * r } else R += b; R > E.PI ? R -= E.PI2 : R < -E.PI && (R += E.PI2), R *= r, X = Math.cos(R), T = Math.sin(R), w.a = X * M - T * L, w.b = X * B - T * P, w.c = T * M + X * L, w.d = T * B + X * P } w.updateAppliedTransform() } } computeWorldPositions (e, r, t) { let a = this.target, i = this.position, c = this.spaces, o = V.setArraySize(this.positions, r * 3 + 2), s = this.world, l = e.closed, n = e.worldVerticesLength, h = n / 6, d = Me.NONE; if (!e.constantSpeed) { let H = e.lengths; h -= l ? 1 : 2; let O = H[h]; this.data.positionMode == de.Percent && (i *= O); let _; switch (this.data.spacingMode) { case ee.Percent: _ = O; break; case ee.Proportional: _ = O / r; break; default: _ = 1 }s = V.setArraySize(this.world, 8); for (let W = 0, J = 0, z = 0; W < r; W++, J += 3) { let U = c[W] * _; i += U; let Q = i; if (l) Q %= O, Q < 0 && (Q += O), z = 0; else if (Q < 0) { d != Me.BEFORE && (d = Me.BEFORE, e.computeWorldVertices(a, 2, 4, s, 0, 2)), this.addBeforePosition(Q, s, 0, o, J); continue } else if (Q > O) { d != Me.AFTER && (d = Me.AFTER, e.computeWorldVertices(a, n - 6, 4, s, 0, 2)), this.addAfterPosition(Q - O, s, 0, o, J); continue } for (; ; z++) { let le = H[z]; if (!(Q > le)) { if (z == 0) Q /= le; else { let we = H[z - 1]; Q = (Q - we) / (le - we) } break } } z != d && (d = z, l && z == h ? (e.computeWorldVertices(a, n - 4, 4, s, 0, 2), e.computeWorldVertices(a, 0, 4, s, 4, 2)) : e.computeWorldVertices(a, z * 6 + 2, 8, s, 0, 2)), this.addCurvePosition(Q, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], o, J, t || W > 0 && U == 0) } return o } l ? (n += 2, s = V.setArraySize(this.world, n), e.computeWorldVertices(a, 2, n - 4, s, 0, 2), e.computeWorldVertices(a, 0, 2, s, n - 4, 2), s[n - 2] = s[0], s[n - 1] = s[1]) : (h--, n -= 4, s = V.setArraySize(this.world, n), e.computeWorldVertices(a, 2, n, s, 0, 2)); let f = V.setArraySize(this.curves, h), m = 0, x = s[0], p = s[1], b = 0, y = 0, u = 0, g = 0, w = 0, v = 0, I = 0, S = 0, A = 0, M = 0, B = 0, L = 0, P = 0, R = 0; for (let H = 0, O = 2; H < h; H++, O += 6)b = s[O], y = s[O + 1], u = s[O + 2], g = s[O + 3], w = s[O + 4], v = s[O + 5], I = (x - b * 2 + u) * .1875, S = (p - y * 2 + g) * .1875, A = ((b - u) * 3 - x + w) * .09375, M = ((y - g) * 3 - p + v) * .09375, B = I * 2 + A, L = S * 2 + M, P = (b - x) * .75 + I + A * .16666667, R = (y - p) * .75 + S + M * .16666667, m += Math.sqrt(P * P + R * R), P += B, R += L, B += A, L += M, m += Math.sqrt(P * P + R * R), P += B, R += L, m += Math.sqrt(P * P + R * R), P += B + A, R += L + M, m += Math.sqrt(P * P + R * R), f[H] = m, x = w, p = v; this.data.positionMode == de.Percent && (i *= m); let X; switch (this.data.spacingMode) { case ee.Percent: X = m; break; case ee.Proportional: X = m / r; break; default: X = 1 }let T = this.segments, q = 0; for (let H = 0, O = 0, _ = 0, W = 0; H < r; H++, O += 3) { let J = c[H] * X; i += J; let z = i; if (l) z %= m, z < 0 && (z += m), _ = 0; else if (z < 0) { this.addBeforePosition(z, s, 0, o, O); continue } else if (z > m) { this.addAfterPosition(z - m, s, n - 4, o, O); continue } for (; ; _++) { let U = f[_]; if (!(z > U)) { if (_ == 0) z /= U; else { let Q = f[_ - 1]; z = (z - Q) / (U - Q) } break } } if (_ != d) { d = _; let U = _ * 6; for (x = s[U], p = s[U + 1], b = s[U + 2], y = s[U + 3], u = s[U + 4], g = s[U + 5], w = s[U + 6], v = s[U + 7], I = (x - b * 2 + u) * .03, S = (p - y * 2 + g) * .03, A = ((b - u) * 3 - x + w) * .006, M = ((y - g) * 3 - p + v) * .006, B = I * 2 + A, L = S * 2 + M, P = (b - x) * .3 + I + A * .16666667, R = (y - p) * .3 + S + M * .16666667, q = Math.sqrt(P * P + R * R), T[0] = q, U = 1; U < 8; U++)P += B, R += L, B += A, L += M, q += Math.sqrt(P * P + R * R), T[U] = q; P += B, R += L, q += Math.sqrt(P * P + R * R), T[8] = q, P += B + A, R += L + M, q += Math.sqrt(P * P + R * R), T[9] = q, W = 0 } for (z *= q; ; W++) { let U = T[W]; if (!(z > U)) { if (W == 0) z /= U; else { let Q = T[W - 1]; z = W + (z - Q) / (U - Q) } break } } this.addCurvePosition(z * .1, x, p, b, y, u, g, w, v, o, O, t || H > 0 && J == 0) } return o } addBeforePosition (e, r, t, a, i) { let c = r[t], o = r[t + 1], s = r[t + 2] - c, l = r[t + 3] - o, n = Math.atan2(l, s); a[i] = c + e * Math.cos(n), a[i + 1] = o + e * Math.sin(n), a[i + 2] = n } addAfterPosition (e, r, t, a, i) { let c = r[t + 2], o = r[t + 3], s = c - r[t], l = o - r[t + 1], n = Math.atan2(l, s); a[i] = c + e * Math.cos(n), a[i + 1] = o + e * Math.sin(n), a[i + 2] = n } addCurvePosition (e, r, t, a, i, c, o, s, l, n, h, d) { if (e == 0 || isNaN(e)) { n[h] = r, n[h + 1] = t, n[h + 2] = Math.atan2(i - t, a - r); return } let f = e * e, m = f * e, x = 1 - e, p = x * x, b = p * x, y = x * e, u = y * 3, g = x * u, w = u * e, v = r * b + a * g + c * w + s * m, I = t * b + i * g + o * w + l * m; n[h] = v, n[h + 1] = I, d && (e < .001 ? n[h + 2] = Math.atan2(i - t, a - r) : n[h + 2] = Math.atan2(I - (t * p + i * y * 2 + o * f), v - (r * p + a * y * 2 + c * f))) } }, Ee = Me; F(Ee, "PathConstraint"), N(Ee, "NONE", -1), N(Ee, "BEFORE", -2), N(Ee, "AFTER", -3), N(Ee, "epsilon", 1e-5); var Tt = class { data; bone; color; darkColor = null; attachment = null; attachmentState = 0; sequenceIndex = -1; deform = new Array; constructor(e, r) { if (!e) throw new Error("data cannot be null."); if (!r) throw new Error("bone cannot be null."); this.data = e, this.bone = r, this.color = new D, this.darkColor = e.darkColor ? new D : null, this.setToSetupPose() } getSkeleton () { return this.bone.skeleton } getAttachment () { return this.attachment } setAttachment (e) { this.attachment != e && ((!(e instanceof te) || !(this.attachment instanceof te) || e.timelineAttachment != this.attachment.timelineAttachment) && (this.deform.length = 0), this.attachment = e, this.sequenceIndex = -1) } setToSetupPose () { this.color.setFromColor(this.data.color), this.darkColor && this.darkColor.setFromColor(this.data.darkColor), this.data.attachmentName ? (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName))) : this.attachment = null } }; F(Tt, "Slot"); var Bt = class { data; bones; target; mixRotate = 0; mixX = 0; mixY = 0; mixScaleX = 0; mixScaleY = 0; mixShearY = 0; temp = new Be; active = !1; constructor(e, r) { if (!e) throw new Error("data cannot be null."); if (!r) throw new Error("skeleton cannot be null."); this.data = e, this.mixRotate = e.mixRotate, this.mixX = e.mixX, this.mixY = e.mixY, this.mixScaleX = e.mixScaleX, this.mixScaleY = e.mixScaleY, this.mixShearY = e.mixShearY, this.bones = new Array; for (let a = 0; a < e.bones.length; a++) { let i = r.findBone(e.bones[a].name); if (!i) throw new Error(`Couldn't find bone ${e.bones[a].name}.`); this.bones.push(i) } let t = r.findBone(e.target.name); if (!t) throw new Error(`Couldn't find target bone ${e.target.name}.`); this.target = t } isActive () { return this.active } update () { this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleY == 0 && this.mixShearY == 0 || (this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()) } applyAbsoluteWorld () { let e = this.mixRotate, r = this.mixX, t = this.mixY, a = this.mixScaleX, i = this.mixScaleY, c = this.mixShearY, o = r != 0 || t != 0, s = this.target, l = s.a, n = s.b, h = s.c, d = s.d, f = l * d - n * h > 0 ? E.degRad : -E.degRad, m = this.data.offsetRotation * f, x = this.data.offsetShearY * f, p = this.bones; for (let b = 0, y = p.length; b < y; b++) { let u = p[b]; if (e != 0) { let g = u.a, w = u.b, v = u.c, I = u.d, S = Math.atan2(h, l) - Math.atan2(v, g) + m; S > E.PI ? S -= E.PI2 : S < -E.PI && (S += E.PI2), S *= e; let A = Math.cos(S), M = Math.sin(S); u.a = A * g - M * v, u.b = A * w - M * I, u.c = M * g + A * v, u.d = M * w + A * I } if (o) { let g = this.temp; s.localToWorld(g.set(this.data.offsetX, this.data.offsetY)), u.worldX += (g.x - u.worldX) * r, u.worldY += (g.y - u.worldY) * t } if (a != 0) { let g = Math.sqrt(u.a * u.a + u.c * u.c); g != 0 && (g = (g + (Math.sqrt(l * l + h * h) - g + this.data.offsetScaleX) * a) / g), u.a *= g, u.c *= g } if (i != 0) { let g = Math.sqrt(u.b * u.b + u.d * u.d); g != 0 && (g = (g + (Math.sqrt(n * n + d * d) - g + this.data.offsetScaleY) * i) / g), u.b *= g, u.d *= g } if (c > 0) { let g = u.b, w = u.d, v = Math.atan2(w, g), I = Math.atan2(d, n) - Math.atan2(h, l) - (v - Math.atan2(u.c, u.a)); I > E.PI ? I -= E.PI2 : I < -E.PI && (I += E.PI2), I = v + (I + x) * c; let S = Math.sqrt(g * g + w * w); u.b = Math.cos(I) * S, u.d = Math.sin(I) * S } u.updateAppliedTransform() } } applyRelativeWorld () { let e = this.mixRotate, r = this.mixX, t = this.mixY, a = this.mixScaleX, i = this.mixScaleY, c = this.mixShearY, o = r != 0 || t != 0, s = this.target, l = s.a, n = s.b, h = s.c, d = s.d, f = l * d - n * h > 0 ? E.degRad : -E.degRad, m = this.data.offsetRotation * f, x = this.data.offsetShearY * f, p = this.bones; for (let b = 0, y = p.length; b < y; b++) { let u = p[b]; if (e != 0) { let g = u.a, w = u.b, v = u.c, I = u.d, S = Math.atan2(h, l) + m; S > E.PI ? S -= E.PI2 : S < -E.PI && (S += E.PI2), S *= e; let A = Math.cos(S), M = Math.sin(S); u.a = A * g - M * v, u.b = A * w - M * I, u.c = M * g + A * v, u.d = M * w + A * I } if (o) { let g = this.temp; s.localToWorld(g.set(this.data.offsetX, this.data.offsetY)), u.worldX += g.x * r, u.worldY += g.y * t } if (a != 0) { let g = (Math.sqrt(l * l + h * h) - 1 + this.data.offsetScaleX) * a + 1; u.a *= g, u.c *= g } if (i != 0) { let g = (Math.sqrt(n * n + d * d) - 1 + this.data.offsetScaleY) * i + 1; u.b *= g, u.d *= g } if (c > 0) { let g = Math.atan2(d, n) - Math.atan2(h, l); g > E.PI ? g -= E.PI2 : g < -E.PI && (g += E.PI2); let w = u.b, v = u.d; g = Math.atan2(v, w) + (g - E.PI / 2 + x) * c; let I = Math.sqrt(w * w + v * v); u.b = Math.cos(g) * I, u.d = Math.sin(g) * I } u.updateAppliedTransform() } } applyAbsoluteLocal () { let e = this.mixRotate, r = this.mixX, t = this.mixY, a = this.mixScaleX, i = this.mixScaleY, c = this.mixShearY, o = this.target, s = this.bones; for (let l = 0, n = s.length; l < n; l++) { let h = s[l], d = h.arotation; if (e != 0) { let y = o.arotation - d + this.data.offsetRotation; y -= (16384 - (16384.499999999996 - y / 360 | 0)) * 360, d += y * e } let f = h.ax, m = h.ay; f += (o.ax - f + this.data.offsetX) * r, m += (o.ay - m + this.data.offsetY) * t; let x = h.ascaleX, p = h.ascaleY; a != 0 && x != 0 && (x = (x + (o.ascaleX - x + this.data.offsetScaleX) * a) / x), i != 0 && p != 0 && (p = (p + (o.ascaleY - p + this.data.offsetScaleY) * i) / p); let b = h.ashearY; if (c != 0) { let y = o.ashearY - b + this.data.offsetShearY; y -= (16384 - (16384.499999999996 - y / 360 | 0)) * 360, b += y * c } h.updateWorldTransformWith(f, m, d, x, p, h.ashearX, b) } } applyRelativeLocal () { let e = this.mixRotate, r = this.mixX, t = this.mixY, a = this.mixScaleX, i = this.mixScaleY, c = this.mixShearY, o = this.target, s = this.bones; for (let l = 0, n = s.length; l < n; l++) { let h = s[l], d = h.arotation + (o.arotation + this.data.offsetRotation) * e, f = h.ax + (o.ax + this.data.offsetX) * r, m = h.ay + (o.ay + this.data.offsetY) * t, x = h.ascaleX * ((o.ascaleX - 1 + this.data.offsetScaleX) * a + 1), p = h.ascaleY * ((o.ascaleY - 1 + this.data.offsetScaleY) * i + 1), b = h.ashearY + (o.ashearY + this.data.offsetShearY) * c; h.updateWorldTransformWith(f, m, d, x, p, h.ashearX, b) } } }; F(Bt, "TransformConstraint"); var Ar = class { data; bones; slots; drawOrder; ikConstraints; transformConstraints; pathConstraints; _updateCache = new Array; skin = null; color; scaleX = 1; _scaleY = 1; get scaleY () { return Ar.yDown ? -this._scaleY : this._scaleY } set scaleY (e) { this._scaleY = e } x = 0; y = 0; constructor(e) { if (!e) throw new Error("data cannot be null."); this.data = e, this.bones = new Array; for (let r = 0; r < e.bones.length; r++) { let t = e.bones[r], a; if (!t.parent) a = new St(t, this, null); else { let i = this.bones[t.parent.index]; a = new St(t, this, i), i.children.push(a) } this.bones.push(a) } this.slots = new Array, this.drawOrder = new Array; for (let r = 0; r < e.slots.length; r++) { let t = e.slots[r], a = this.bones[t.boneData.index], i = new Tt(t, a); this.slots.push(i), this.drawOrder.push(i) } this.ikConstraints = new Array; for (let r = 0; r < e.ikConstraints.length; r++) { let t = e.ikConstraints[r]; this.ikConstraints.push(new Et(t, this)) } this.transformConstraints = new Array; for (let r = 0; r < e.transformConstraints.length; r++) { let t = e.transformConstraints[r]; this.transformConstraints.push(new Bt(t, this)) } this.pathConstraints = new Array; for (let r = 0; r < e.pathConstraints.length; r++) { let t = e.pathConstraints[r]; this.pathConstraints.push(new Ee(t, this)) } this.color = new D(1, 1, 1, 1), this.updateCache() } updateCache () { let e = this._updateCache; e.length = 0; let r = this.bones; for (let n = 0, h = r.length; n < h; n++) { let d = r[n]; d.sorted = d.data.skinRequired, d.active = !d.sorted } if (this.skin) { let n = this.skin.bones; for (let h = 0, d = this.skin.bones.length; h < d; h++) { let f = this.bones[n[h].index]; do f.sorted = !1, f.active = !0, f = f.parent; while (f) } } let t = this.ikConstraints, a = this.transformConstraints, i = this.pathConstraints, c = t.length, o = a.length, s = i.length, l = c + o + s; e: for (let n = 0; n < l; n++) { for (let h = 0; h < c; h++) { let d = t[h]; if (d.data.order == n) { this.sortIkConstraint(d); continue e } } for (let h = 0; h < o; h++) { let d = a[h]; if (d.data.order == n) { this.sortTransformConstraint(d); continue e } } for (let h = 0; h < s; h++) { let d = i[h]; if (d.data.order == n) { this.sortPathConstraint(d); continue e } } } for (let n = 0, h = r.length; n < h; n++)this.sortBone(r[n]) } sortIkConstraint (e) { if (e.active = e.target.isActive() && (!e.data.skinRequired || this.skin && V.contains(this.skin.constraints, e.data, !0)), !e.active) return; let r = e.target; this.sortBone(r); let t = e.bones, a = t[0]; if (this.sortBone(a), t.length == 1) this._updateCache.push(e), this.sortReset(a.children); else { let i = t[t.length - 1]; this.sortBone(i), this._updateCache.push(e), this.sortReset(a.children), i.sorted = !0 } } sortPathConstraint (e) { if (e.active = e.target.bone.isActive() && (!e.data.skinRequired || this.skin && V.contains(this.skin.constraints, e.data, !0)), !e.active) return; let r = e.target, t = r.data.index, a = r.bone; this.skin && this.sortPathConstraintAttachment(this.skin, t, a), this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, t, a); for (let s = 0, l = this.data.skins.length; s < l; s++)this.sortPathConstraintAttachment(this.data.skins[s], t, a); let i = r.getAttachment(); i instanceof ge && this.sortPathConstraintAttachmentWith(i, a); let c = e.bones, o = c.length; for (let s = 0; s < o; s++)this.sortBone(c[s]); this._updateCache.push(e); for (let s = 0; s < o; s++)this.sortReset(c[s].children); for (let s = 0; s < o; s++)c[s].sorted = !0 } sortTransformConstraint (e) { if (e.active = e.target.isActive() && (!e.data.skinRequired || this.skin && V.contains(this.skin.constraints, e.data, !0)), !e.active) return; this.sortBone(e.target); let r = e.bones, t = r.length; if (e.data.local) for (let a = 0; a < t; a++) { let i = r[a]; this.sortBone(i.parent), this.sortBone(i) } else for (let a = 0; a < t; a++)this.sortBone(r[a]); this._updateCache.push(e); for (let a = 0; a < t; a++)this.sortReset(r[a].children); for (let a = 0; a < t; a++)r[a].sorted = !0 } sortPathConstraintAttachment (e, r, t) { let a = e.attachments[r]; if (a) for (let i in a) this.sortPathConstraintAttachmentWith(a[i], t) } sortPathConstraintAttachmentWith (e, r) { if (!(e instanceof ge)) return; let t = e.bones; if (!t) this.sortBone(r); else { let a = this.bones; for (let i = 0, c = t.length; i < c;) { let o = t[i++]; for (o += i; i < o;)this.sortBone(a[t[i++]]) } } } sortBone (e) { if (!e || e.sorted) return; let r = e.parent; r && this.sortBone(r), e.sorted = !0, this._updateCache.push(e) } sortReset (e) { for (let r = 0, t = e.length; r < t; r++) { let a = e[r]; a.active && (a.sorted && this.sortReset(a.children), a.sorted = !1) } } updateWorldTransform () { let e = this.bones; for (let t = 0, a = e.length; t < a; t++) { let i = e[t]; i.ax = i.x, i.ay = i.y, i.arotation = i.rotation, i.ascaleX = i.scaleX, i.ascaleY = i.scaleY, i.ashearX = i.shearX, i.ashearY = i.shearY } let r = this._updateCache; for (let t = 0, a = r.length; t < a; t++)r[t].update() } updateWorldTransformWith (e) { let r = this.getRootBone(); if (!r) throw new Error("Root bone must not be null."); let t = e.a, a = e.b, i = e.c, c = e.d; r.worldX = t * this.x + a * this.y + e.worldX, r.worldY = i * this.x + c * this.y + e.worldY; let o = r.rotation + 90 + r.shearY, s = E.cosDeg(r.rotation + r.shearX) * r.scaleX, l = E.cosDeg(o) * r.scaleY, n = E.sinDeg(r.rotation + r.shearX) * r.scaleX, h = E.sinDeg(o) * r.scaleY; r.a = (t * s + a * n) * this.scaleX, r.b = (t * l + a * h) * this.scaleX, r.c = (i * s + c * n) * this.scaleY, r.d = (i * l + c * h) * this.scaleY; let d = this._updateCache; for (let f = 0, m = d.length; f < m; f++) { let x = d[f]; x != r && x.update() } } setToSetupPose () { this.setBonesToSetupPose(), this.setSlotsToSetupPose() } setBonesToSetupPose () { let e = this.bones; for (let i = 0, c = e.length; i < c; i++)e[i].setToSetupPose(); let r = this.ikConstraints; for (let i = 0, c = r.length; i < c; i++) { let o = r[i]; o.mix = o.data.mix, o.softness = o.data.softness, o.bendDirection = o.data.bendDirection, o.compress = o.data.compress, o.stretch = o.data.stretch } let t = this.transformConstraints; for (let i = 0, c = t.length; i < c; i++) { let o = t[i], s = o.data; o.mixRotate = s.mixRotate, o.mixX = s.mixX, o.mixY = s.mixY, o.mixScaleX = s.mixScaleX, o.mixScaleY = s.mixScaleY, o.mixShearY = s.mixShearY } let a = this.pathConstraints; for (let i = 0, c = a.length; i < c; i++) { let o = a[i], s = o.data; o.position = s.position, o.spacing = s.spacing, o.mixRotate = s.mixRotate, o.mixX = s.mixX, o.mixY = s.mixY } } setSlotsToSetupPose () { let e = this.slots; V.arrayCopy(e, 0, this.drawOrder, 0, e.length); for (let r = 0, t = e.length; r < t; r++)e[r].setToSetupPose() } getRootBone () { return this.bones.length == 0 ? null : this.bones[0] } findBone (e) { if (!e) throw new Error("boneName cannot be null."); let r = this.bones; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.data.name == e) return i } return null } findSlot (e) { if (!e) throw new Error("slotName cannot be null."); let r = this.slots; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.data.name == e) return i } return null } setSkinByName (e) { let r = this.data.findSkin(e); if (!r) throw new Error("Skin not found: " + e); this.setSkin(r) } setSkin (e) { if (e != this.skin) { if (e) if (this.skin) e.attachAll(this, this.skin); else { let r = this.slots; for (let t = 0, a = r.length; t < a; t++) { let i = r[t], c = i.data.attachmentName; if (c) { let o = e.getAttachment(t, c); o && i.setAttachment(o) } } } this.skin = e, this.updateCache() } } getAttachmentByName (e, r) { let t = this.data.findSlot(e); if (!t) throw new Error(`Can't find slot with name ${e}`); return this.getAttachment(t.index, r) } getAttachment (e, r) { if (!r) throw new Error("attachmentName cannot be null."); if (this.skin) { let t = this.skin.getAttachment(e, r); if (t) return t } return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(e, r) : null } setAttachment (e, r) { if (!e) throw new Error("slotName cannot be null."); let t = this.slots; for (let a = 0, i = t.length; a < i; a++) { let c = t[a]; if (c.data.name == e) { let o = null; if (r && (o = this.getAttachment(a, r), !o)) throw new Error("Attachment not found: " + r + ", for slot: " + e); c.setAttachment(o); return } } throw new Error("Slot not found: " + e) } findIkConstraint (e) { if (!e) throw new Error("constraintName cannot be null."); let r = this.ikConstraints; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.data.name == e) return i } return null } findTransformConstraint (e) { if (!e) throw new Error("constraintName cannot be null."); let r = this.transformConstraints; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.data.name == e) return i } return null } findPathConstraint (e) { if (!e) throw new Error("constraintName cannot be null."); let r = this.pathConstraints; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.data.name == e) return i } return null } getBoundsRect () { let e = new Be, r = new Be; return this.getBounds(e, r), { x: e.x, y: e.y, width: r.x, height: r.y } } getBounds (e, r, t = new Array(2)) { if (!e) throw new Error("offset cannot be null."); if (!r) throw new Error("size cannot be null."); let a = this.drawOrder, i = Number.POSITIVE_INFINITY, c = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY; for (let l = 0, n = a.length; l < n; l++) { let h = a[l]; if (!h.bone.active) continue; let d = 0, f = null, m = h.getAttachment(); if (m instanceof $) d = 8, f = V.setArraySize(t, d, 0), m.computeWorldVertices(h, f, 0, 2); else if (m instanceof ue) { let x = m; d = x.worldVerticesLength, f = V.setArraySize(t, d, 0), x.computeWorldVertices(h, 0, d, f, 0, 2) } if (f) for (let x = 0, p = f.length; x < p; x += 2) { let b = f[x], y = f[x + 1]; i = Math.min(i, b), c = Math.min(c, y), o = Math.max(o, b), s = Math.max(s, y) } } e.set(i, c), r.set(o - i, s - c) } }, Gt = Ar; F(Gt, "Skeleton"), N(Gt, "yDown", !1); var pt = class { name = null; bones = new Array; slots = new Array; skins = new Array; defaultSkin = null; events = new Array; animations = new Array; ikConstraints = new Array; transformConstraints = new Array; pathConstraints = new Array; x = 0; y = 0; width = 0; height = 0; version = null; hash = null; fps = 0; imagesPath = null; audioPath = null; findBone (e) { if (!e) throw new Error("boneName cannot be null."); let r = this.bones; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } findSlot (e) { if (!e) throw new Error("slotName cannot be null."); let r = this.slots; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } findSkin (e) { if (!e) throw new Error("skinName cannot be null."); let r = this.skins; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } findEvent (e) { if (!e) throw new Error("eventDataName cannot be null."); let r = this.events; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } findAnimation (e) { if (!e) throw new Error("animationName cannot be null."); let r = this.animations; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } findIkConstraint (e) { if (!e) throw new Error("constraintName cannot be null."); let r = this.ikConstraints; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } findTransformConstraint (e) { if (!e) throw new Error("constraintName cannot be null."); let r = this.transformConstraints; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } findPathConstraint (e) { if (!e) throw new Error("constraintName cannot be null."); let r = this.pathConstraints; for (let t = 0, a = r.length; t < a; t++) { let i = r[t]; if (i.name == e) return i } return null } }; F(pt, "SkeletonData"); var Rt = class { slotIndex; name; attachment; constructor(e = 0, r, t) { this.slotIndex = e, this.name = r, this.attachment = t } }; F(Rt, "SkinEntry"); var Pe = class { name; attachments = new Array; bones = Array(); constraints = new Array; constructor(e) { if (!e) throw new Error("name cannot be null."); this.name = e } setAttachment (e, r, t) { if (!t) throw new Error("attachment cannot be null."); let a = this.attachments; e >= a.length && (a.length = e + 1), a[e] || (a[e] = {}), a[e][r] = t } addSkin (e) { for (let a = 0; a < e.bones.length; a++) { let i = e.bones[a], c = !1; for (let o = 0; o < this.bones.length; o++)if (this.bones[o] == i) { c = !0; break } c || this.bones.push(i) } for (let a = 0; a < e.constraints.length; a++) { let i = e.constraints[a], c = !1; for (let o = 0; o < this.constraints.length; o++)if (this.constraints[o] == i) { c = !0; break } c || this.constraints.push(i) } let r = e.getAttachments(); for (let a = 0; a < r.length; a++) { var t = r[a]; this.setAttachment(t.slotIndex, t.name, t.attachment) } } copySkin (e) { for (let a = 0; a < e.bones.length; a++) { let i = e.bones[a], c = !1; for (let o = 0; o < this.bones.length; o++)if (this.bones[o] == i) { c = !0; break } c || this.bones.push(i) } for (let a = 0; a < e.constraints.length; a++) { let i = e.constraints[a], c = !1; for (let o = 0; o < this.constraints.length; o++)if (this.constraints[o] == i) { c = !0; break } c || this.constraints.push(i) } let r = e.getAttachments(); for (let a = 0; a < r.length; a++) { var t = r[a]; t.attachment && (t.attachment instanceof ue ? (t.attachment = t.attachment.newLinkedMesh(), this.setAttachment(t.slotIndex, t.name, t.attachment)) : (t.attachment = t.attachment.copy(), this.setAttachment(t.slotIndex, t.name, t.attachment))) } } getAttachment (e, r) { let t = this.attachments[e]; return t ? t[r] : null } removeAttachment (e, r) { let t = this.attachments[e]; t && delete t[r] } getAttachments () { let e = new Array; for (var r = 0; r < this.attachments.length; r++) { let t = this.attachments[r]; if (t) for (let a in t) { let i = t[a]; i && e.push(new Rt(r, a, i)) } } return e } getAttachmentsForSlot (e, r) { let t = this.attachments[e]; if (t) for (let a in t) { let i = t[a]; i && r.push(new Rt(e, a, i)) } } clear () { this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0 } attachAll (e, r) { let t = 0; for (let a = 0; a < e.slots.length; a++) { let i = e.slots[a], c = i.getAttachment(); if (c && t < r.attachments.length) { let o = r.attachments[t]; for (let s in o) { let l = o[s]; if (c == l) { let n = this.getAttachment(t, s); n && i.setAttachment(n); break } } } t++ } } }; F(Pe, "Skin"); var wt = class { index = 0; name; boneData; color = new D(1, 1, 1, 1); darkColor = null; attachmentName = null; blendMode = Pt.Normal; constructor(e, r, t) { if (e < 0) throw new Error("index must be >= 0."); if (!r) throw new Error("name cannot be null."); if (!t) throw new Error("boneData cannot be null."); this.index = e, this.name = r, this.boneData = t } }; F(wt, "SlotData"); var Pt; (function (Y) { Y[Y.Normal = 0] = "Normal", Y[Y.Additive = 1] = "Additive", Y[Y.Multiply = 2] = "Multiply", Y[Y.Screen = 3] = "Screen" })(Pt || (Pt = {})); var bt = class extends Xe { bones = new Array; _target = null; set target (e) { this._target = e } get target () { if (this._target) return this._target; throw new Error("BoneData not set.") } mixRotate = 0; mixX = 0; mixY = 0; mixScaleX = 0; mixScaleY = 0; mixShearY = 0; offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0; relative = !1; local = !1; constructor(e) { super(e, 0, !1) } }; F(bt, "TransformConstraintData"); var fr = class { scale = 1; attachmentLoader; linkedMeshes = new Array; constructor(e) { this.attachmentLoader = e } readSkeletonData (e) { let r = this.scale, t = new pt; t.name = ""; let a = new jt(e), i = a.readInt32(), c = a.readInt32(); t.hash = c == 0 && i == 0 ? null : c.toString(16) + i.toString(16), t.version = a.readString(), t.x = a.readFloat(), t.y = a.readFloat(), t.width = a.readFloat(), t.height = a.readFloat(); let o = a.readBoolean(); o && (t.fps = a.readFloat(), t.imagesPath = a.readString(), t.audioPath = a.readString()); let s = 0; s = a.readInt(!0); for (let n = 0; n < s; n++) { let h = a.readString(); if (!h) throw new Error("String in string table must not be null."); a.strings.push(h) } s = a.readInt(!0); for (let n = 0; n < s; n++) { let h = a.readString(); if (!h) throw new Error("Bone name must not be null."); let d = n == 0 ? null : t.bones[a.readInt(!0)], f = new ft(n, h, d); f.rotation = a.readFloat(), f.x = a.readFloat() * r, f.y = a.readFloat() * r, f.scaleX = a.readFloat(), f.scaleY = a.readFloat(), f.shearX = a.readFloat(), f.shearY = a.readFloat(), f.length = a.readFloat() * r, f.transformMode = a.readInt(!0), f.skinRequired = a.readBoolean(), o && D.rgba8888ToColor(f.color, a.readInt32()), t.bones.push(f) } s = a.readInt(!0); for (let n = 0; n < s; n++) { let h = a.readString(); if (!h) throw new Error("Slot name must not be null."); let d = t.bones[a.readInt(!0)], f = new wt(n, h, d); D.rgba8888ToColor(f.color, a.readInt32()); let m = a.readInt32(); m != -1 && D.rgb888ToColor(f.darkColor = new D, m), f.attachmentName = a.readStringRef(), f.blendMode = a.readInt(!0), t.slots.push(f) } s = a.readInt(!0); for (let n = 0, h; n < s; n++) { let d = a.readString(); if (!d) throw new Error("IK constraint data name must not be null."); let f = new gt(d); f.order = a.readInt(!0), f.skinRequired = a.readBoolean(), h = a.readInt(!0); for (let m = 0; m < h; m++)f.bones.push(t.bones[a.readInt(!0)]); f.target = t.bones[a.readInt(!0)], f.mix = a.readFloat(), f.softness = a.readFloat() * r, f.bendDirection = a.readByte(), f.compress = a.readBoolean(), f.stretch = a.readBoolean(), f.uniform = a.readBoolean(), t.ikConstraints.push(f) } s = a.readInt(!0); for (let n = 0, h; n < s; n++) { let d = a.readString(); if (!d) throw new Error("Transform constraint data name must not be null."); let f = new bt(d); f.order = a.readInt(!0), f.skinRequired = a.readBoolean(), h = a.readInt(!0); for (let m = 0; m < h; m++)f.bones.push(t.bones[a.readInt(!0)]); f.target = t.bones[a.readInt(!0)], f.local = a.readBoolean(), f.relative = a.readBoolean(), f.offsetRotation = a.readFloat(), f.offsetX = a.readFloat() * r, f.offsetY = a.readFloat() * r, f.offsetScaleX = a.readFloat(), f.offsetScaleY = a.readFloat(), f.offsetShearY = a.readFloat(), f.mixRotate = a.readFloat(), f.mixX = a.readFloat(), f.mixY = a.readFloat(), f.mixScaleX = a.readFloat(), f.mixScaleY = a.readFloat(), f.mixShearY = a.readFloat(), t.transformConstraints.push(f) } s = a.readInt(!0); for (let n = 0, h; n < s; n++) { let d = a.readString(); if (!d) throw new Error("Path constraint data name must not be null."); let f = new xt(d); f.order = a.readInt(!0), f.skinRequired = a.readBoolean(), h = a.readInt(!0); for (let m = 0; m < h; m++)f.bones.push(t.bones[a.readInt(!0)]); f.target = t.slots[a.readInt(!0)], f.positionMode = a.readInt(!0), f.spacingMode = a.readInt(!0), f.rotateMode = a.readInt(!0), f.offsetRotation = a.readFloat(), f.position = a.readFloat(), f.positionMode == de.Fixed && (f.position *= r), f.spacing = a.readFloat(), (f.spacingMode == ee.Length || f.spacingMode == ee.Fixed) && (f.spacing *= r), f.mixRotate = a.readFloat(), f.mixX = a.readFloat(), f.mixY = a.readFloat(), t.pathConstraints.push(f) } let l = this.readSkin(a, t, !0, o); l && (t.defaultSkin = l, t.skins.push(l)); { let n = t.skins.length; for (V.setArraySize(t.skins, s = n + a.readInt(!0)); n < s; n++) { let h = this.readSkin(a, t, !1, o); if (!h) throw new Error("readSkin() should not have returned null."); t.skins[n] = h } } s = this.linkedMeshes.length; for (let n = 0; n < s; n++) { let h = this.linkedMeshes[n], d = h.skin ? t.findSkin(h.skin) : t.defaultSkin; if (!d) throw new Error("Not skin found for linked mesh."); if (!h.parent) throw new Error("Linked mesh parent must not be null"); let f = d.getAttachment(h.slotIndex, h.parent); if (!f) throw new Error(`Parent mesh not found: ${h.parent}`); h.mesh.timelineAttachment = h.inheritTimeline ? f : h.mesh, h.mesh.setParentMesh(f), h.mesh.region != null && h.mesh.updateRegion() } this.linkedMeshes.length = 0, s = a.readInt(!0); for (let n = 0; n < s; n++) { let h = a.readStringRef(); if (!h) throw new Error; let d = new ut(h); d.intValue = a.readInt(!1), d.floatValue = a.readFloat(), d.stringValue = a.readString(), d.audioPath = a.readString(), d.audioPath && (d.volume = a.readFloat(), d.balance = a.readFloat()), t.events.push(d) } s = a.readInt(!0); for (let n = 0; n < s; n++) { let h = a.readString(); if (!h) throw new Error("Animatio name must not be null."); t.animations.push(this.readAnimation(a, h, t)) } return t } readSkin (e, r, t, a) { let i = null, c = 0; if (t) { if (c = e.readInt(!0), c == 0) return null; i = new Pe("default") } else { let o = e.readStringRef(); if (!o) throw new Error("Skin name must not be null."); i = new Pe(o), i.bones.length = e.readInt(!0); for (let s = 0, l = i.bones.length; s < l; s++)i.bones[s] = r.bones[e.readInt(!0)]; for (let s = 0, l = e.readInt(!0); s < l; s++)i.constraints.push(r.ikConstraints[e.readInt(!0)]); for (let s = 0, l = e.readInt(!0); s < l; s++)i.constraints.push(r.transformConstraints[e.readInt(!0)]); for (let s = 0, l = e.readInt(!0); s < l; s++)i.constraints.push(r.pathConstraints[e.readInt(!0)]); c = e.readInt(!0) } for (let o = 0; o < c; o++) { let s = e.readInt(!0); for (let l = 0, n = e.readInt(!0); l < n; l++) { let h = e.readStringRef(); if (!h) throw new Error("Attachment name must not be null"); let d = this.readAttachment(e, r, i, s, h, a); d && i.setAttachment(s, h, d) } } return i } readAttachment (e, r, t, a, i, c) { let o = this.scale, s = e.readStringRef(); switch (s || (s = i), e.readByte()) { case Le.Region: { let l = e.readStringRef(), n = e.readFloat(), h = e.readFloat(), d = e.readFloat(), f = e.readFloat(), m = e.readFloat(), x = e.readFloat(), p = e.readFloat(), b = e.readInt32(), y = this.readSequence(e); l || (l = s); let u = this.attachmentLoader.newRegionAttachment(t, s, l, y); return u ? (u.path = l, u.x = h * o, u.y = d * o, u.scaleX = f, u.scaleY = m, u.rotation = n, u.width = x * o, u.height = p * o, D.rgba8888ToColor(u.color, b), u.sequence = y, y == null && u.updateRegion(), u) : null } case Le.BoundingBox: { let l = e.readInt(!0), n = this.readVertices(e, l), h = c ? e.readInt32() : 0, d = this.attachmentLoader.newBoundingBoxAttachment(t, s); return d ? (d.worldVerticesLength = l << 1, d.vertices = n.vertices, d.bones = n.bones, c && D.rgba8888ToColor(d.color, h), d) : null } case Le.Mesh: { let l = e.readStringRef(), n = e.readInt32(), h = e.readInt(!0), d = this.readFloatArray(e, h << 1, 1), f = this.readShortArray(e), m = this.readVertices(e, h), x = e.readInt(!0), p = this.readSequence(e), b = [], y = 0, u = 0; c && (b = this.readShortArray(e), y = e.readFloat(), u = e.readFloat()), l || (l = s); let g = this.attachmentLoader.newMeshAttachment(t, s, l, p); return g ? (g.path = l, D.rgba8888ToColor(g.color, n), g.bones = m.bones, g.vertices = m.vertices, g.worldVerticesLength = h << 1, g.triangles = f, g.regionUVs = d, p == null && g.updateRegion(), g.hullLength = x << 1, g.sequence = p, c && (g.edges = b, g.width = y * o, g.height = u * o), g) : null } case Le.LinkedMesh: { let l = e.readStringRef(), n = e.readInt32(), h = e.readStringRef(), d = e.readStringRef(), f = e.readBoolean(), m = this.readSequence(e), x = 0, p = 0; c && (x = e.readFloat(), p = e.readFloat()), l || (l = s); let b = this.attachmentLoader.newMeshAttachment(t, s, l, m); return b ? (b.path = l, D.rgba8888ToColor(b.color, n), b.sequence = m, c && (b.width = x * o, b.height = p * o), this.linkedMeshes.push(new mr(b, h, a, d, f)), b) : null } case Le.Path: { let l = e.readBoolean(), n = e.readBoolean(), h = e.readInt(!0), d = this.readVertices(e, h), f = V.newArray(h / 3, 0); for (let p = 0, b = f.length; p < b; p++)f[p] = e.readFloat() * o; let m = c ? e.readInt32() : 0, x = this.attachmentLoader.newPathAttachment(t, s); return x ? (x.closed = l, x.constantSpeed = n, x.worldVerticesLength = h << 1, x.vertices = d.vertices, x.bones = d.bones, x.lengths = f, c && D.rgba8888ToColor(x.color, m), x) : null } case Le.Point: { let l = e.readFloat(), n = e.readFloat(), h = e.readFloat(), d = c ? e.readInt32() : 0, f = this.attachmentLoader.newPointAttachment(t, s); return f ? (f.x = n * o, f.y = h * o, f.rotation = l, c && D.rgba8888ToColor(f.color, d), f) : null } case Le.Clipping: { let l = e.readInt(!0), n = e.readInt(!0), h = this.readVertices(e, n), d = c ? e.readInt32() : 0, f = this.attachmentLoader.newClippingAttachment(t, s); return f ? (f.endSlot = r.slots[l], f.worldVerticesLength = n << 1, f.vertices = h.vertices, f.bones = h.bones, c && D.rgba8888ToColor(f.color, d), f) : null } }return null } readSequence (e) { if (!e.readBoolean()) return null; let r = new Oe(e.readInt(!0)); return r.start = e.readInt(!0), r.digits = e.readInt(!0), r.setupIndex = e.readInt(!0), r } readVertices (e, r) { let t = this.scale, a = r << 1, i = new ur; if (!e.readBoolean()) return i.vertices = this.readFloatArray(e, a, t), i; let c = new Array, o = new Array; for (let s = 0; s < r; s++) { let l = e.readInt(!0); o.push(l); for (let n = 0; n < l; n++)o.push(e.readInt(!0)), c.push(e.readFloat() * t), c.push(e.readFloat() * t), c.push(e.readFloat()) } return i.vertices = V.toFloatArray(c), i.bones = o, i } readFloatArray (e, r, t) { let a = new Array(r); if (t == 1) for (let i = 0; i < r; i++)a[i] = e.readFloat(); else for (let i = 0; i < r; i++)a[i] = e.readFloat() * t; return a } readShortArray (e) { let r = e.readInt(!0), t = new Array(r); for (let a = 0; a < r; a++)t[a] = e.readShort(); return t } readAnimation (e, r, t) { e.readInt(!0); let a = new Array, i = this.scale, c = new D, o = new D; for (let h = 0, d = e.readInt(!0); h < d; h++) { let f = e.readInt(!0); for (let m = 0, x = e.readInt(!0); m < x; m++) { let p = e.readByte(), b = e.readInt(!0), y = b - 1; switch (p) { case es: { let u = new me(b, f); for (let g = 0; g < b; g++)u.setFrame(g, e.readFloat(), e.readStringRef()); a.push(u); break } case ts: { let u = e.readInt(!0), g = new Ke(b, u, f), w = e.readFloat(), v = e.readUnsignedByte() / 255, I = e.readUnsignedByte() / 255, S = e.readUnsignedByte() / 255, A = e.readUnsignedByte() / 255; for (let M = 0, B = 0; g.setFrame(M, w, v, I, S, A), M != y; M++) { let L = e.readFloat(), P = e.readUnsignedByte() / 255, R = e.readUnsignedByte() / 255, X = e.readUnsignedByte() / 255, T = e.readUnsignedByte() / 255; switch (e.readByte()) { case Ie: g.setStepped(M); break; case Se: G(e, g, B++, M, 0, w, L, v, P, 1), G(e, g, B++, M, 1, w, L, I, R, 1), G(e, g, B++, M, 2, w, L, S, X, 1), G(e, g, B++, M, 3, w, L, A, T, 1) }w = L, v = P, I = R, S = X, A = T } a.push(g); break } case rs: { let u = e.readInt(!0), g = new Qe(b, u, f), w = e.readFloat(), v = e.readUnsignedByte() / 255, I = e.readUnsignedByte() / 255, S = e.readUnsignedByte() / 255; for (let A = 0, M = 0; g.setFrame(A, w, v, I, S), A != y; A++) { let B = e.readFloat(), L = e.readUnsignedByte() / 255, P = e.readUnsignedByte() / 255, R = e.readUnsignedByte() / 255; switch (e.readByte()) { case Ie: g.setStepped(A); break; case Se: G(e, g, M++, A, 0, w, B, v, L, 1), G(e, g, M++, A, 1, w, B, I, P, 1), G(e, g, M++, A, 2, w, B, S, R, 1) }w = B, v = L, I = P, S = R } a.push(g); break } case ss: { let u = e.readInt(!0), g = new et(b, u, f), w = e.readFloat(), v = e.readUnsignedByte() / 255, I = e.readUnsignedByte() / 255, S = e.readUnsignedByte() / 255, A = e.readUnsignedByte() / 255, M = e.readUnsignedByte() / 255, B = e.readUnsignedByte() / 255, L = e.readUnsignedByte() / 255; for (let P = 0, R = 0; g.setFrame(P, w, v, I, S, A, M, B, L), P != y; P++) { let X = e.readFloat(), T = e.readUnsignedByte() / 255, q = e.readUnsignedByte() / 255, H = e.readUnsignedByte() / 255, O = e.readUnsignedByte() / 255, _ = e.readUnsignedByte() / 255, W = e.readUnsignedByte() / 255, J = e.readUnsignedByte() / 255; switch (e.readByte()) { case Ie: g.setStepped(P); break; case Se: G(e, g, R++, P, 0, w, X, v, T, 1), G(e, g, R++, P, 1, w, X, I, q, 1), G(e, g, R++, P, 2, w, X, S, H, 1), G(e, g, R++, P, 3, w, X, A, O, 1), G(e, g, R++, P, 4, w, X, M, _, 1), G(e, g, R++, P, 5, w, X, B, W, 1), G(e, g, R++, P, 6, w, X, L, J, 1) }w = X, v = T, I = q, S = H, A = O, M = _, B = W, L = J } a.push(g); break } case is: { let u = e.readInt(!0), g = new tt(b, u, f), w = e.readFloat(), v = e.readUnsignedByte() / 255, I = e.readUnsignedByte() / 255, S = e.readUnsignedByte() / 255, A = e.readUnsignedByte() / 255, M = e.readUnsignedByte() / 255, B = e.readUnsignedByte() / 255; for (let L = 0, P = 0; g.setFrame(L, w, v, I, S, A, M, B), L != y; L++) { let R = e.readFloat(), X = e.readUnsignedByte() / 255, T = e.readUnsignedByte() / 255, q = e.readUnsignedByte() / 255, H = e.readUnsignedByte() / 255, O = e.readUnsignedByte() / 255, _ = e.readUnsignedByte() / 255; switch (e.readByte()) { case Ie: g.setStepped(L); break; case Se: G(e, g, P++, L, 0, w, R, v, X, 1), G(e, g, P++, L, 1, w, R, I, T, 1), G(e, g, P++, L, 2, w, R, S, q, 1), G(e, g, P++, L, 3, w, R, A, H, 1), G(e, g, P++, L, 4, w, R, M, O, 1), G(e, g, P++, L, 5, w, R, B, _, 1) }w = R, v = X, I = T, S = q, A = H, M = O, B = _ } a.push(g); break } case as: { let u = new Ze(b, e.readInt(!0), f), g = e.readFloat(), w = e.readUnsignedByte() / 255; for (let v = 0, I = 0; u.setFrame(v, g, w), v != y; v++) { let S = e.readFloat(), A = e.readUnsignedByte() / 255; switch (e.readByte()) { case Ie: u.setStepped(v); break; case Se: G(e, u, I++, v, 0, g, S, w, A, 1) }g = S, w = A } a.push(u) } } } } for (let h = 0, d = e.readInt(!0); h < d; h++) { let f = e.readInt(!0); for (let m = 0, x = e.readInt(!0); m < x; m++) { let p = e.readByte(), b = e.readInt(!0), y = e.readInt(!0); switch (p) { case zr: a.push(Ve(e, new Ye(b, y, f), 1)); break; case $r: a.push(Xr(e, new Ue(b, y, f), i)); break; case Hr: a.push(Ve(e, new We(b, y, f), i)); break; case _r: a.push(Ve(e, new ze(b, y, f), i)); break; case Gr: a.push(Xr(e, new $e(b, y, f), 1)); break; case jr: a.push(Ve(e, new He(b, y, f), 1)); break; case Jr: a.push(Ve(e, new _e(b, y, f), 1)); break; case Kr: a.push(Xr(e, new Ge(b, y, f), 1)); break; case Qr: a.push(Ve(e, new je(b, y, f), 1)); break; case Zr: a.push(Ve(e, new Je(b, y, f), 1)) } } } for (let h = 0, d = e.readInt(!0); h < d; h++) { let f = e.readInt(!0), m = e.readInt(!0), x = m - 1, p = new st(m, e.readInt(!0), f), b = e.readFloat(), y = e.readFloat(), u = e.readFloat() * i; for (let g = 0, w = 0; p.setFrame(g, b, y, u, e.readByte(), e.readBoolean(), e.readBoolean()), g != x; g++) { let v = e.readFloat(), I = e.readFloat(), S = e.readFloat() * i; switch (e.readByte()) { case Ie: p.setStepped(g); break; case Se: G(e, p, w++, g, 0, b, v, y, I, 1), G(e, p, w++, g, 1, b, v, u, S, i) }b = v, y = I, u = S } a.push(p) } for (let h = 0, d = e.readInt(!0); h < d; h++) { let f = e.readInt(!0), m = e.readInt(!0), x = m - 1, p = new it(m, e.readInt(!0), f), b = e.readFloat(), y = e.readFloat(), u = e.readFloat(), g = e.readFloat(), w = e.readFloat(), v = e.readFloat(), I = e.readFloat(); for (let S = 0, A = 0; p.setFrame(S, b, y, u, g, w, v, I), S != x; S++) { let M = e.readFloat(), B = e.readFloat(), L = e.readFloat(), P = e.readFloat(), R = e.readFloat(), X = e.readFloat(), T = e.readFloat(); switch (e.readByte()) { case Ie: p.setStepped(S); break; case Se: G(e, p, A++, S, 0, b, M, y, B, 1), G(e, p, A++, S, 1, b, M, u, L, 1), G(e, p, A++, S, 2, b, M, g, P, 1), G(e, p, A++, S, 3, b, M, w, R, 1), G(e, p, A++, S, 4, b, M, v, X, 1), G(e, p, A++, S, 5, b, M, I, T, 1) }b = M, y = B, u = L, g = P, w = R, v = X, I = T } a.push(p) } for (let h = 0, d = e.readInt(!0); h < d; h++) { let f = e.readInt(!0), m = t.pathConstraints[f]; for (let x = 0, p = e.readInt(!0); x < p; x++)switch (e.readByte()) { case os: a.push(Ve(e, new at(e.readInt(!0), e.readInt(!0), f), m.positionMode == de.Fixed ? i : 1)); break; case hs: a.push(Ve(e, new nt(e.readInt(!0), e.readInt(!0), f), m.spacingMode == ee.Length || m.spacingMode == ee.Fixed ? i : 1)); break; case cs: let b = new lt(e.readInt(!0), e.readInt(!0), f), y = e.readFloat(), u = e.readFloat(), g = e.readFloat(), w = e.readFloat(); for (let v = 0, I = 0, S = b.getFrameCount() - 1; b.setFrame(v, y, u, g, w), v != S; v++) { let A = e.readFloat(), M = e.readFloat(), B = e.readFloat(), L = e.readFloat(); switch (e.readByte()) { case Ie: b.setStepped(v); break; case Se: G(e, b, I++, v, 0, y, A, u, M, 1), G(e, b, I++, v, 1, y, A, g, B, 1), G(e, b, I++, v, 2, y, A, w, L, 1) }y = A, u = M, g = B, w = L } a.push(b) } } for (let h = 0, d = e.readInt(!0); h < d; h++) { let f = t.skins[e.readInt(!0)]; for (let m = 0, x = e.readInt(!0); m < x; m++) { let p = e.readInt(!0); for (let b = 0, y = e.readInt(!0); b < y; b++) { let u = e.readStringRef(); if (!u) throw new Error("attachmentName must not be null."); let g = f.getAttachment(p, u), w = e.readByte(), v = e.readInt(!0), I = v - 1; switch (w) { case ns: { let S = g, A = S.bones, M = S.vertices, B = A ? M.length / 3 * 2 : M.length, L = e.readInt(!0), P = new rt(v, L, p, S), R = e.readFloat(); for (let X = 0, T = 0; ; X++) { let q, H = e.readInt(!0); if (H == 0) q = A ? V.newFloatArray(B) : M; else { q = V.newFloatArray(B); let _ = e.readInt(!0); if (H += _, i == 1) for (let W = _; W < H; W++)q[W] = e.readFloat(); else for (let W = _; W < H; W++)q[W] = e.readFloat() * i; if (!A) for (let W = 0, J = q.length; W < J; W++)q[W] += M[W] } if (P.setFrame(X, R, q), X == I) break; let O = e.readFloat(); switch (e.readByte()) { case Ie: P.setStepped(X); break; case Se: G(e, P, T++, X, 0, R, O, 0, 1, 1) }R = O } a.push(P); break } case ls: { let S = new ye(v, p, g); for (let A = 0; A < v; A++) { let M = e.readFloat(), B = e.readInt32(); S.setFrame(A, M, sr[B & 15], B >> 4, e.readFloat()) } a.push(S); break } } } } } let s = e.readInt(!0); if (s > 0) { let h = new fe(s), d = t.slots.length; for (let f = 0; f < s; f++) { let m = e.readFloat(), x = e.readInt(!0), p = V.newArray(d, 0); for (let g = d - 1; g >= 0; g--)p[g] = -1; let b = V.newArray(d - x, 0), y = 0, u = 0; for (let g = 0; g < x; g++) { let w = e.readInt(!0); for (; y != w;)b[u++] = y++; p[y + e.readInt(!0)] = y++ } for (; y < d;)b[u++] = y++; for (let g = d - 1; g >= 0; g--)p[g] == -1 && (p[g] = b[--u]); h.setFrame(f, m, p) } a.push(h) } let l = e.readInt(!0); if (l > 0) { let h = new ve(l); for (let d = 0; d < l; d++) { let f = e.readFloat(), m = t.events[e.readInt(!0)], x = new mt(f, m); x.intValue = e.readInt(!1), x.floatValue = e.readFloat(), x.stringValue = e.readBoolean() ? e.readString() : m.stringValue, x.data.audioPath && (x.volume = e.readFloat(), x.balance = e.readFloat()), h.setFrame(d, x) } a.push(h) } let n = 0; for (let h = 0, d = a.length; h < d; h++)n = Math.max(n, a[h].getDuration()); return new Ce(r, a, n) } }; F(fr, "SkeletonBinary"); var jt = class { strings; index; buffer; constructor(e, r = new Array, t = 0, a = new DataView(e.buffer)) { this.strings = r, this.index = t, this.buffer = a } readByte () { return this.buffer.getInt8(this.index++) } readUnsignedByte () { return this.buffer.getUint8(this.index++) } readShort () { let e = this.buffer.getInt16(this.index); return this.index += 2, e } readInt32 () { let e = this.buffer.getInt32(this.index); return this.index += 4, e } readInt (e) { let r = this.readByte(), t = r & 127; return r & 128 && (r = this.readByte(), t |= (r & 127) << 7, r & 128 && (r = this.readByte(), t |= (r & 127) << 14, r & 128 && (r = this.readByte(), t |= (r & 127) << 21, r & 128 && (r = this.readByte(), t |= (r & 127) << 28)))), e ? t : t >>> 1 ^ -(t & 1) } readStringRef () { let e = this.readInt(!0); return e == 0 ? null : this.strings[e - 1] } readString () { let e = this.readInt(!0); switch (e) { case 0: return null; case 1: return "" }e--; let r = "", t = 0; for (let a = 0; a < e;) { let i = this.readUnsignedByte(); switch (i >> 4) { case 12: case 13: r += String.fromCharCode((i & 31) << 6 | this.readByte() & 63), a += 2; break; case 14: r += String.fromCharCode((i & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63), a += 3; break; default: r += String.fromCharCode(i), a++ } } return r } readFloat () { let e = this.buffer.getFloat32(this.index); return this.index += 4, e } readBoolean () { return this.readByte() != 0 } }; F(jt, "BinaryInput"); var mr = class { parent; skin; slotIndex; mesh; inheritTimeline; constructor(e, r, t, a, i) { this.mesh = e, this.skin = r, this.slotIndex = t, this.parent = a, this.inheritTimeline = i } }; F(mr, "LinkedMesh"); var ur = class { bones; vertices; constructor(e = null, r = null) { this.bones = e, this.vertices = r } }; F(ur, "Vertices"); var Le; (function (Y) { Y[Y.Region = 0] = "Region", Y[Y.BoundingBox = 1] = "BoundingBox", Y[Y.Mesh = 2] = "Mesh", Y[Y.LinkedMesh = 3] = "LinkedMesh", Y[Y.Path = 4] = "Path", Y[Y.Point = 5] = "Point", Y[Y.Clipping = 6] = "Clipping" })(Le || (Le = {})); function Ve (Y, e, r) { let t = Y.readFloat(), a = Y.readFloat() * r; for (let i = 0, c = 0, o = e.getFrameCount() - 1; e.setFrame(i, t, a), i != o; i++) { let s = Y.readFloat(), l = Y.readFloat() * r; switch (Y.readByte()) { case Ie: e.setStepped(i); break; case Se: G(Y, e, c++, i, 0, t, s, a, l, r) }t = s, a = l } return e } F(Ve, "readTimeline1"); function Xr (Y, e, r) { let t = Y.readFloat(), a = Y.readFloat() * r, i = Y.readFloat() * r; for (let c = 0, o = 0, s = e.getFrameCount() - 1; e.setFrame(c, t, a, i), c != s; c++) { let l = Y.readFloat(), n = Y.readFloat() * r, h = Y.readFloat() * r; switch (Y.readByte()) { case Ie: e.setStepped(c); break; case Se: G(Y, e, o++, c, 0, t, l, a, n, r), G(Y, e, o++, c, 1, t, l, i, h, r) }t = l, a = n, i = h } return e } F(Xr, "readTimeline2"); function G (Y, e, r, t, a, i, c, o, s, l) { e.setBezier(r, t, a, i, o, Y.readFloat(), Y.readFloat() * l, Y.readFloat(), Y.readFloat() * l, c, s) } F(G, "setBezier"); var zr = 0, $r = 1, Hr = 2, _r = 3, Gr = 4, jr = 5, Jr = 6, Kr = 7, Qr = 8, Zr = 9, es = 0, ts = 1, rs = 2, ss = 3, is = 4, as = 5, ns = 0, ls = 1, os = 0, hs = 1, cs = 2; var Ie = 1, Se = 2; var gr = class { minX = 0; minY = 0; maxX = 0; maxY = 0; boundingBoxes = new Array; polygons = new Array; polygonPool = new be(() => V.newFloatArray(16)); update (e, r) { if (!e) throw new Error("skeleton cannot be null."); let t = this.boundingBoxes, a = this.polygons, i = this.polygonPool, c = e.slots, o = c.length; t.length = 0, i.freeAll(a), a.length = 0; for (let s = 0; s < o; s++) { let l = c[s]; if (!l.bone.active) continue; let n = l.getAttachment(); if (n instanceof Ae) { let h = n; t.push(h); let d = i.obtain(); d.length != h.worldVerticesLength && (d = V.newFloatArray(h.worldVerticesLength)), a.push(d), h.computeWorldVertices(l, 0, h.worldVerticesLength, d, 0, 2) } } r ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY) } aabbCompute () { let e = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY, t = Number.NEGATIVE_INFINITY, a = Number.NEGATIVE_INFINITY, i = this.polygons; for (let c = 0, o = i.length; c < o; c++) { let s = i[c], l = s; for (let n = 0, h = s.length; n < h; n += 2) { let d = l[n], f = l[n + 1]; e = Math.min(e, d), r = Math.min(r, f), t = Math.max(t, d), a = Math.max(a, f) } } this.minX = e, this.minY = r, this.maxX = t, this.maxY = a } aabbContainsPoint (e, r) { return e >= this.minX && e <= this.maxX && r >= this.minY && r <= this.maxY } aabbIntersectsSegment (e, r, t, a) { let i = this.minX, c = this.minY, o = this.maxX, s = this.maxY; if (e <= i && t <= i || r <= c && a <= c || e >= o && t >= o || r >= s && a >= s) return !1; let l = (a - r) / (t - e), n = l * (i - e) + r; if (n > c && n < s || (n = l * (o - e) + r, n > c && n < s)) return !0; let h = (c - r) / l + e; return h > i && h < o || (h = (s - r) / l + e, h > i && h < o) } aabbIntersectsSkeleton (e) { return this.minX < e.maxX && this.maxX > e.minX && this.minY < e.maxY && this.maxY > e.minY } containsPoint (e, r) { let t = this.polygons; for (let a = 0, i = t.length; a < i; a++)if (this.containsPointPolygon(t[a], e, r)) return this.boundingBoxes[a]; return null } containsPointPolygon (e, r, t) { let a = e, i = e.length, c = i - 2, o = !1; for (let s = 0; s < i; s += 2) { let l = a[s + 1], n = a[c + 1]; if (l < t && n >= t || n < t && l >= t) { let h = a[s]; h + (t - l) / (n - l) * (a[c] - h) < r && (o = !o) } c = s } return o } intersectsSegment (e, r, t, a) { let i = this.polygons; for (let c = 0, o = i.length; c < o; c++)if (this.intersectsSegmentPolygon(i[c], e, r, t, a)) return this.boundingBoxes[c]; return null } intersectsSegmentPolygon (e, r, t, a, i) { let c = e, o = e.length, s = r - a, l = t - i, n = r * i - t * a, h = c[o - 2], d = c[o - 1]; for (let f = 0; f < o; f += 2) { let m = c[f], x = c[f + 1], p = h * x - d * m, b = h - m, y = d - x, u = s * y - l * b, g = (n * b - s * p) / u; if ((g >= h && g <= m || g >= m && g <= h) && (g >= r && g <= a || g >= a && g <= r)) { let w = (n * y - l * p) / u; if ((w >= d && w <= x || w >= x && w <= d) && (w >= t && w <= i || w >= i && w <= t)) return !0 } h = m, d = x } return !1 } getPolygon (e) { if (!e) throw new Error("boundingBox cannot be null."); let r = this.boundingBoxes.indexOf(e); return r == -1 ? null : this.polygons[r] } getWidth () { return this.maxX - this.minX } getHeight () { return this.maxY - this.minY } }; F(gr, "SkeletonBounds"); var se = class { convexPolygons = new Array; convexPolygonsIndices = new Array; indicesArray = new Array; isConcaveArray = new Array; triangles = new Array; polygonPool = new be(() => new Array); polygonIndicesPool = new be(() => new Array); triangulate (e) { let r = e, t = e.length >> 1, a = this.indicesArray; a.length = 0; for (let o = 0; o < t; o++)a[o] = o; let i = this.isConcaveArray; i.length = 0; for (let o = 0, s = t; o < s; ++o)i[o] = se.isConcave(o, t, r, a); let c = this.triangles; for (c.length = 0; t > 3;) { let o = t - 1, s = 0, l = 1; for (; ;) { e: if (!i[s]) { let d = a[o] << 1, f = a[s] << 1, m = a[l] << 1, x = r[d], p = r[d + 1], b = r[f], y = r[f + 1], u = r[m], g = r[m + 1]; for (let w = (l + 1) % t; w != o; w = (w + 1) % t) { if (!i[w]) continue; let v = a[w] << 1, I = r[v], S = r[v + 1]; if (se.positiveArea(u, g, x, p, I, S) && se.positiveArea(x, p, b, y, I, S) && se.positiveArea(b, y, u, g, I, S)) break e } break } if (l == 0) { do { if (!i[s]) break; s-- } while (s > 0); break } o = s, s = l, l = (l + 1) % t } c.push(a[(t + s - 1) % t]), c.push(a[s]), c.push(a[(s + 1) % t]), a.splice(s, 1), i.splice(s, 1), t--; let n = (t + s - 1) % t, h = s == t ? 0 : s; i[n] = se.isConcave(n, t, r, a), i[h] = se.isConcave(h, t, r, a) } return t == 3 && (c.push(a[2]), c.push(a[0]), c.push(a[1])), c } decompose (e, r) { let t = e, a = this.convexPolygons; this.polygonPool.freeAll(a), a.length = 0; let i = this.convexPolygonsIndices; this.polygonIndicesPool.freeAll(i), i.length = 0; let c = this.polygonIndicesPool.obtain(); c.length = 0; let o = this.polygonPool.obtain(); o.length = 0; let s = -1, l = 0; for (let n = 0, h = r.length; n < h; n += 3) { let d = r[n] << 1, f = r[n + 1] << 1, m = r[n + 2] << 1, x = t[d], p = t[d + 1], b = t[f], y = t[f + 1], u = t[m], g = t[m + 1], w = !1; if (s == d) { let v = o.length - 4, I = se.winding(o[v], o[v + 1], o[v + 2], o[v + 3], u, g), S = se.winding(u, g, o[0], o[1], o[2], o[3]); I == l && S == l && (o.push(u), o.push(g), c.push(m), w = !0) } w || (o.length > 0 ? (a.push(o), i.push(c)) : (this.polygonPool.free(o), this.polygonIndicesPool.free(c)), o = this.polygonPool.obtain(), o.length = 0, o.push(x), o.push(p), o.push(b), o.push(y), o.push(u), o.push(g), c = this.polygonIndicesPool.obtain(), c.length = 0, c.push(d), c.push(f), c.push(m), l = se.winding(x, p, b, y, u, g), s = d) } o.length > 0 && (a.push(o), i.push(c)); for (let n = 0, h = a.length; n < h; n++) { if (c = i[n], c.length == 0) continue; let d = c[0], f = c[c.length - 1]; o = a[n]; let m = o.length - 4, x = o[m], p = o[m + 1], b = o[m + 2], y = o[m + 3], u = o[0], g = o[1], w = o[2], v = o[3], I = se.winding(x, p, b, y, u, g); for (let S = 0; S < h; S++) { if (S == n) continue; let A = i[S]; if (A.length != 3) continue; let M = A[0], B = A[1], L = A[2], P = a[S], R = P[P.length - 2], X = P[P.length - 1]; if (M != d || B != f) continue; let T = se.winding(x, p, b, y, R, X), q = se.winding(R, X, u, g, w, v); T == I && q == I && (P.length = 0, A.length = 0, o.push(R), o.push(X), c.push(L), x = b, p = y, b = R, y = X, S = 0) } } for (let n = a.length - 1; n >= 0; n--)o = a[n], o.length == 0 && (a.splice(n, 1), this.polygonPool.free(o), c = i[n], i.splice(n, 1), this.polygonIndicesPool.free(c)); return a } static isConcave (e, r, t, a) { let i = a[(r + e - 1) % r] << 1, c = a[e] << 1, o = a[(e + 1) % r] << 1; return !this.positiveArea(t[i], t[i + 1], t[c], t[c + 1], t[o], t[o + 1]) } static positiveArea (e, r, t, a, i, c) { return e * (c - a) + t * (r - c) + i * (a - r) >= 0 } static winding (e, r, t, a, i, c) { let o = t - e, s = a - r; return i * s - c * o + o * r - e * s >= 0 ? 1 : -1 } }; F(se, "Triangulator"); var kt = class { triangulator = new se; clippingPolygon = new Array; clipOutput = new Array; clippedVertices = new Array; clippedTriangles = new Array; scratch = new Array; clipAttachment = null; clippingPolygons = null; clipStart (e, r) { if (this.clipAttachment) return 0; this.clipAttachment = r; let t = r.worldVerticesLength, a = V.setArraySize(this.clippingPolygon, t); r.computeWorldVertices(e, 0, t, a, 0, 2); let i = this.clippingPolygon; kt.makeClockwise(i); let c = this.clippingPolygons = this.triangulator.decompose(i, this.triangulator.triangulate(i)); for (let o = 0, s = c.length; o < s; o++) { let l = c[o]; kt.makeClockwise(l), l.push(l[0]), l.push(l[1]) } return c.length } clipEndWithSlot (e) { this.clipAttachment && this.clipAttachment.endSlot == e.data && this.clipEnd() } clipEnd () { this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0) } isClipping () { return this.clipAttachment != null } clipTriangles (e, r, t, a, i, c, o, s) { let l = this.clipOutput, n = this.clippedVertices, h = this.clippedTriangles, d = this.clippingPolygons, f = d.length, m = s ? 12 : 8, x = 0; n.length = 0, h.length = 0; e: for (let p = 0; p < a; p += 3) { let b = t[p] << 1, y = e[b], u = e[b + 1], g = i[b], w = i[b + 1]; b = t[p + 1] << 1; let v = e[b], I = e[b + 1], S = i[b], A = i[b + 1]; b = t[p + 2] << 1; let M = e[b], B = e[b + 1], L = i[b], P = i[b + 1]; for (let R = 0; R < f; R++) { let X = n.length; if (this.clip(y, u, v, I, M, B, d[R], l)) { let T = l.length; if (T == 0) continue; let q = I - B, H = M - v, O = y - M, _ = B - u, W = 1 / (q * O + H * (u - B)), J = T >> 1, z = this.clipOutput, U = V.setArraySize(n, X + J * m); for (let le = 0; le < T; le += 2) { let we = z[le], ae = z[le + 1]; U[X] = we, U[X + 1] = ae, U[X + 2] = c.r, U[X + 3] = c.g, U[X + 4] = c.b, U[X + 5] = c.a; let xe = we - M, pe = ae - B, Ne = (q * xe + H * pe) * W, Ct = (_ * xe + O * pe) * W, Vt = 1 - Ne - Ct; U[X + 6] = g * Ne + S * Ct + L * Vt, U[X + 7] = w * Ne + A * Ct + P * Vt, s && (U[X + 8] = o.r, U[X + 9] = o.g, U[X + 10] = o.b, U[X + 11] = o.a), X += m } X = h.length; let Q = V.setArraySize(h, X + 3 * (J - 2)); J--; for (let le = 1; le < J; le++)Q[X] = x, Q[X + 1] = x + le, Q[X + 2] = x + le + 1, X += 3; x += J + 1 } else { let T = V.setArraySize(n, X + 3 * m); T[X] = y, T[X + 1] = u, T[X + 2] = c.r, T[X + 3] = c.g, T[X + 4] = c.b, T[X + 5] = c.a, s ? (T[X + 6] = g, T[X + 7] = w, T[X + 8] = o.r, T[X + 9] = o.g, T[X + 10] = o.b, T[X + 11] = o.a, T[X + 12] = v, T[X + 13] = I, T[X + 14] = c.r, T[X + 15] = c.g, T[X + 16] = c.b, T[X + 17] = c.a, T[X + 18] = S, T[X + 19] = A, T[X + 20] = o.r, T[X + 21] = o.g, T[X + 22] = o.b, T[X + 23] = o.a, T[X + 24] = M, T[X + 25] = B, T[X + 26] = c.r, T[X + 27] = c.g, T[X + 28] = c.b, T[X + 29] = c.a, T[X + 30] = L, T[X + 31] = P, T[X + 32] = o.r, T[X + 33] = o.g, T[X + 34] = o.b, T[X + 35] = o.a) : (T[X + 6] = g, T[X + 7] = w, T[X + 8] = v, T[X + 9] = I, T[X + 10] = c.r, T[X + 11] = c.g, T[X + 12] = c.b, T[X + 13] = c.a, T[X + 14] = S, T[X + 15] = A, T[X + 16] = M, T[X + 17] = B, T[X + 18] = c.r, T[X + 19] = c.g, T[X + 20] = c.b, T[X + 21] = c.a, T[X + 22] = L, T[X + 23] = P), X = h.length; let q = V.setArraySize(h, X + 3); q[X] = x, q[X + 1] = x + 1, q[X + 2] = x + 2, x += 3; continue e } } } } clip (e, r, t, a, i, c, o, s) { let l = s, n = !1, h; o.length % 4 >= 2 ? (h = s, s = this.scratch) : h = this.scratch, h.length = 0, h.push(e), h.push(r), h.push(t), h.push(a), h.push(i), h.push(c), h.push(e), h.push(r), s.length = 0; let d = o, f = o.length - 4; for (let m = 0; ; m += 2) { let x = d[m], p = d[m + 1], b = d[m + 2], y = d[m + 3], u = x - b, g = p - y, w = h, v = h.length - 2, I = s.length; for (let A = 0; A < v; A += 2) { let M = w[A], B = w[A + 1], L = w[A + 2], P = w[A + 3], R = u * (P - y) - g * (L - b) > 0; if (u * (B - y) - g * (M - b) > 0) { if (R) { s.push(L), s.push(P); continue } let X = P - B, T = L - M, q = X * (b - x) - T * (y - p); if (Math.abs(q) > 1e-6) { let H = (T * (p - B) - X * (x - M)) / q; s.push(x + (b - x) * H), s.push(p + (y - p) * H) } else s.push(x), s.push(p) } else if (R) { let X = P - B, T = L - M, q = X * (b - x) - T * (y - p); if (Math.abs(q) > 1e-6) { let H = (T * (p - B) - X * (x - M)) / q; s.push(x + (b - x) * H), s.push(p + (y - p) * H) } else s.push(x), s.push(p); s.push(L), s.push(P) } n = !0 } if (I == s.length) return l.length = 0, !0; if (s.push(s[0]), s.push(s[1]), m == f) break; let S = s; s = h, s.length = 0, h = S } if (l != s) { l.length = 0; for (let m = 0, x = s.length - 2; m < x; m++)l[m] = s[m] } else l.length = l.length - 2; return n } static makeClockwise (e) { let r = e, t = e.length, a = r[t - 2] * r[1] - r[0] * r[t - 1], i = 0, c = 0, o = 0, s = 0; for (let l = 0, n = t - 3; l < n; l += 2)i = r[l], c = r[l + 1], o = r[l + 2], s = r[l + 3], a += i * s - o * c; if (!(a < 0)) for (let l = 0, n = t - 2, h = t >> 1; l < h; l += 2) { let d = r[l], f = r[l + 1], m = n - l; r[l] = r[m], r[l + 1] = r[m + 1], r[m] = d, r[m + 1] = f } } }; F(kt, "SkeletonClipping"); var xr = class { attachmentLoader; scale = 1; linkedMeshes = new Array; constructor(e) { this.attachmentLoader = e } readSkeletonData (e) { let r = this.scale, t = new pt, a = typeof e == "string" ? JSON.parse(e) : e, i = a.skeleton; if (i && (t.hash = i.hash, t.version = i.spine, t.x = i.x, t.y = i.y, t.width = i.width, t.height = i.height, t.fps = i.fps, t.imagesPath = i.images), a.bones) for (let c = 0; c < a.bones.length; c++) { let o = a.bones[c], s = null, l = k(o, "parent", null); l && (s = t.findBone(l)); let n = new ft(t.bones.length, o.name, s); n.length = k(o, "length", 0) * r, n.x = k(o, "x", 0) * r, n.y = k(o, "y", 0) * r, n.rotation = k(o, "rotation", 0), n.scaleX = k(o, "scaleX", 1), n.scaleY = k(o, "scaleY", 1), n.shearX = k(o, "shearX", 0), n.shearY = k(o, "shearY", 0), n.transformMode = V.enumValue(ie, k(o, "transform", "Normal")), n.skinRequired = k(o, "skin", !1); let h = k(o, "color", null); h && n.color.setFromString(h), t.bones.push(n) } if (a.slots) for (let c = 0; c < a.slots.length; c++) { let o = a.slots[c], s = t.findBone(o.bone); if (!s) throw new Error(`Couldn't find bone ${o.bone} for slot ${o.name}`); let l = new wt(t.slots.length, o.name, s), n = k(o, "color", null); n && l.color.setFromString(n); let h = k(o, "dark", null); h && (l.darkColor = D.fromString(h)), l.attachmentName = k(o, "attachment", null), l.blendMode = V.enumValue(Pt, k(o, "blend", "normal")), t.slots.push(l) } if (a.ik) for (let c = 0; c < a.ik.length; c++) { let o = a.ik[c], s = new gt(o.name); s.order = k(o, "order", 0), s.skinRequired = k(o, "skin", !1); for (let n = 0; n < o.bones.length; n++) { let h = t.findBone(o.bones[n]); if (!h) throw new Error(`Couldn't find bone ${o.bones[n]} for IK constraint ${o.name}.`); s.bones.push(h) } let l = t.findBone(o.target); if (!l) throw new Error(`Couldn't find target bone ${o.target} for IK constraint ${o.name}.`); s.target = l, s.mix = k(o, "mix", 1), s.softness = k(o, "softness", 0) * r, s.bendDirection = k(o, "bendPositive", !0) ? 1 : -1, s.compress = k(o, "compress", !1), s.stretch = k(o, "stretch", !1), s.uniform = k(o, "uniform", !1), t.ikConstraints.push(s) } if (a.transform) for (let c = 0; c < a.transform.length; c++) { let o = a.transform[c], s = new bt(o.name); s.order = k(o, "order", 0), s.skinRequired = k(o, "skin", !1); for (let h = 0; h < o.bones.length; h++) { let d = o.bones[h], f = t.findBone(d); if (!f) throw new Error(`Couldn't find bone ${d} for transform constraint ${o.name}.`); s.bones.push(f) } let l = o.target, n = t.findBone(l); if (!n) throw new Error(`Couldn't find target bone ${l} for transform constraint ${o.name}.`); s.target = n, s.local = k(o, "local", !1), s.relative = k(o, "relative", !1), s.offsetRotation = k(o, "rotation", 0), s.offsetX = k(o, "x", 0) * r, s.offsetY = k(o, "y", 0) * r, s.offsetScaleX = k(o, "scaleX", 0), s.offsetScaleY = k(o, "scaleY", 0), s.offsetShearY = k(o, "shearY", 0), s.mixRotate = k(o, "mixRotate", 1), s.mixX = k(o, "mixX", 1), s.mixY = k(o, "mixY", s.mixX), s.mixScaleX = k(o, "mixScaleX", 1), s.mixScaleY = k(o, "mixScaleY", s.mixScaleX), s.mixShearY = k(o, "mixShearY", 1), t.transformConstraints.push(s) } if (a.path) for (let c = 0; c < a.path.length; c++) { let o = a.path[c], s = new xt(o.name); s.order = k(o, "order", 0), s.skinRequired = k(o, "skin", !1); for (let h = 0; h < o.bones.length; h++) { let d = o.bones[h], f = t.findBone(d); if (!f) throw new Error(`Couldn't find bone ${d} for path constraint ${o.name}.`); s.bones.push(f) } let l = o.target, n = t.findSlot(l); if (!n) throw new Error(`Couldn't find target slot ${l} for path constraint ${o.name}.`); s.target = n, s.positionMode = V.enumValue(de, k(o, "positionMode", "Percent")), s.spacingMode = V.enumValue(ee, k(o, "spacingMode", "Length")), s.rotateMode = V.enumValue(Fe, k(o, "rotateMode", "Tangent")), s.offsetRotation = k(o, "rotation", 0), s.position = k(o, "position", 0), s.positionMode == de.Fixed && (s.position *= r), s.spacing = k(o, "spacing", 0), (s.spacingMode == ee.Length || s.spacingMode == ee.Fixed) && (s.spacing *= r), s.mixRotate = k(o, "mixRotate", 1), s.mixX = k(o, "mixX", 1), s.mixY = k(o, "mixY", s.mixX), t.pathConstraints.push(s) } if (a.skins) for (let c = 0; c < a.skins.length; c++) { let o = a.skins[c], s = new Pe(o.name); if (o.bones) for (let l = 0; l < o.bones.length; l++) { let n = o.bones[l], h = t.findBone(n); if (!h) throw new Error(`Couldn't find bone ${n} for skin ${o.name}.`); s.bones.push(h) } if (o.ik) for (let l = 0; l < o.ik.length; l++) { let n = o.ik[l], h = t.findIkConstraint(n); if (!h) throw new Error(`Couldn't find IK constraint ${n} for skin ${o.name}.`); s.constraints.push(h) } if (o.transform) for (let l = 0; l < o.transform.length; l++) { let n = o.transform[l], h = t.findTransformConstraint(n); if (!h) throw new Error(`Couldn't find transform constraint ${n} for skin ${o.name}.`); s.constraints.push(h) } if (o.path) for (let l = 0; l < o.path.length; l++) { let n = o.path[l], h = t.findPathConstraint(n); if (!h) throw new Error(`Couldn't find path constraint ${n} for skin ${o.name}.`); s.constraints.push(h) } for (let l in o.attachments) { let n = t.findSlot(l); if (!n) throw new Error(`Couldn't find slot ${l} for skin ${o.name}.`); let h = o.attachments[l]; for (let d in h) { let f = this.readAttachment(h[d], s, n.index, d, t); f && s.setAttachment(n.index, d, f) } } t.skins.push(s), s.name == "default" && (t.defaultSkin = s) } for (let c = 0, o = this.linkedMeshes.length; c < o; c++) { let s = this.linkedMeshes[c], l = s.skin ? t.findSkin(s.skin) : t.defaultSkin; if (!l) throw new Error(`Skin not found: ${s.skin}`); let n = l.getAttachment(s.slotIndex, s.parent); if (!n) throw new Error(`Parent mesh not found: ${s.parent}`); s.mesh.timelineAttachment = s.inheritTimeline ? n : s.mesh, s.mesh.setParentMesh(n), s.mesh.region != null && s.mesh.updateRegion() } if (this.linkedMeshes.length = 0, a.events) for (let c in a.events) { let o = a.events[c], s = new ut(c); s.intValue = k(o, "int", 0), s.floatValue = k(o, "float", 0), s.stringValue = k(o, "string", ""), s.audioPath = k(o, "audio", null), s.audioPath && (s.volume = k(o, "volume", 1), s.balance = k(o, "balance", 0)), t.events.push(s) } if (a.animations) for (let c in a.animations) { let o = a.animations[c]; this.readAnimation(o, c, t) } return t } readAttachment (e, r, t, a, i) { let c = this.scale; switch (a = k(e, "name", a), k(e, "type", "region")) { case "region": { let o = k(e, "path", a), s = this.readSequence(k(e, "sequence", null)), l = this.attachmentLoader.newRegionAttachment(r, a, o, s); if (!l) return null; l.path = o, l.x = k(e, "x", 0) * c, l.y = k(e, "y", 0) * c, l.scaleX = k(e, "scaleX", 1), l.scaleY = k(e, "scaleY", 1), l.rotation = k(e, "rotation", 0), l.width = e.width * c, l.height = e.height * c, l.sequence = s; let n = k(e, "color", null); return n && l.color.setFromString(n), l.region != null && l.updateRegion(), l } case "boundingbox": { let o = this.attachmentLoader.newBoundingBoxAttachment(r, a); if (!o) return null; this.readVertices(e, o, e.vertexCount << 1); let s = k(e, "color", null); return s && o.color.setFromString(s), o } case "mesh": case "linkedmesh": { let o = k(e, "path", a), s = this.readSequence(k(e, "sequence", null)), l = this.attachmentLoader.newMeshAttachment(r, a, o, s); if (!l) return null; l.path = o; let n = k(e, "color", null); n && l.color.setFromString(n), l.width = k(e, "width", 0) * c, l.height = k(e, "height", 0) * c, l.sequence = s; let h = k(e, "parent", null); if (h) return this.linkedMeshes.push(new pr(l, k(e, "skin", null), t, h, k(e, "timelines", !0))), l; let d = e.uvs; return this.readVertices(e, l, d.length), l.triangles = e.triangles, l.regionUVs = d, l.region != null && l.updateRegion(), l.edges = k(e, "edges", null), l.hullLength = k(e, "hull", 0) * 2, l } case "path": { let o = this.attachmentLoader.newPathAttachment(r, a); if (!o) return null; o.closed = k(e, "closed", !1), o.constantSpeed = k(e, "constantSpeed", !0); let s = e.vertexCount; this.readVertices(e, o, s << 1); let l = V.newArray(s / 3, 0); for (let h = 0; h < e.lengths.length; h++)l[h] = e.lengths[h] * c; o.lengths = l; let n = k(e, "color", null); return n && o.color.setFromString(n), o } case "point": { let o = this.attachmentLoader.newPointAttachment(r, a); if (!o) return null; o.x = k(e, "x", 0) * c, o.y = k(e, "y", 0) * c, o.rotation = k(e, "rotation", 0); let s = k(e, "color", null); return s && o.color.setFromString(s), o } case "clipping": { let o = this.attachmentLoader.newClippingAttachment(r, a); if (!o) return null; let s = k(e, "end", null); s && (o.endSlot = i.findSlot(s)); let l = e.vertexCount; this.readVertices(e, o, l << 1); let n = k(e, "color", null); return n && o.color.setFromString(n), o } }return null } readSequence (e) { if (e == null) return null; let r = new Oe(k(e, "count", 0)); return r.start = k(e, "start", 1), r.digits = k(e, "digits", 0), r.setupIndex = k(e, "setup", 0), r } readVertices (e, r, t) { let a = this.scale; r.worldVerticesLength = t; let i = e.vertices; if (t == i.length) { let s = V.toFloatArray(i); if (a != 1) for (let l = 0, n = i.length; l < n; l++)s[l] *= a; r.vertices = s; return } let c = new Array, o = new Array; for (let s = 0, l = i.length; s < l;) { let n = i[s++]; o.push(n); for (let h = s + n * 4; s < h; s += 4)o.push(i[s]), c.push(i[s + 1] * a), c.push(i[s + 2] * a), c.push(i[s + 3]) } r.bones = o, r.vertices = V.toFloatArray(c) } readAnimation (e, r, t) { let a = this.scale, i = new Array; if (e.slots) for (let o in e.slots) { let s = e.slots[o], l = t.findSlot(o); if (!l) throw new Error("Slot not found: " + o); let n = l.index; for (let h in s) { let d = s[h]; if (!d) continue; let f = d.length; if (h == "attachment") { let m = new me(f, n); for (let x = 0; x < f; x++) { let p = d[x]; m.setFrame(x, k(p, "time", 0), k(p, "name", null)) } i.push(m) } else if (h == "rgba") { let m = new Ke(f, f << 2, n), x = d[0], p = k(x, "time", 0), b = D.fromString(x.color); for (let y = 0, u = 0; ; y++) { m.setFrame(y, p, b.r, b.g, b.b, b.a); let g = d[y + 1]; if (!g) { m.shrink(u); break } let w = k(g, "time", 0), v = D.fromString(g.color), I = x.curve; I && (u = j(I, m, u, y, 0, p, w, b.r, v.r, 1), u = j(I, m, u, y, 1, p, w, b.g, v.g, 1), u = j(I, m, u, y, 2, p, w, b.b, v.b, 1), u = j(I, m, u, y, 3, p, w, b.a, v.a, 1)), p = w, b = v, x = g } i.push(m) } else if (h == "rgb") { let m = new Qe(f, f * 3, n), x = d[0], p = k(x, "time", 0), b = D.fromString(x.color); for (let y = 0, u = 0; ; y++) { m.setFrame(y, p, b.r, b.g, b.b); let g = d[y + 1]; if (!g) { m.shrink(u); break } let w = k(g, "time", 0), v = D.fromString(g.color), I = x.curve; I && (u = j(I, m, u, y, 0, p, w, b.r, v.r, 1), u = j(I, m, u, y, 1, p, w, b.g, v.g, 1), u = j(I, m, u, y, 2, p, w, b.b, v.b, 1)), p = w, b = v, x = g } i.push(m) } else if (h == "alpha") i.push(Te(d, new Ze(f, f, n), 0, 1)); else if (h == "rgba2") { let m = new et(f, f * 7, n), x = d[0], p = k(x, "time", 0), b = D.fromString(x.light), y = D.fromString(x.dark); for (let u = 0, g = 0; ; u++) { m.setFrame(u, p, b.r, b.g, b.b, b.a, y.r, y.g, y.b); let w = d[u + 1]; if (!w) { m.shrink(g); break } let v = k(w, "time", 0), I = D.fromString(w.light), S = D.fromString(w.dark), A = x.curve; A && (g = j(A, m, g, u, 0, p, v, b.r, I.r, 1), g = j(A, m, g, u, 1, p, v, b.g, I.g, 1), g = j(A, m, g, u, 2, p, v, b.b, I.b, 1), g = j(A, m, g, u, 3, p, v, b.a, I.a, 1), g = j(A, m, g, u, 4, p, v, y.r, S.r, 1), g = j(A, m, g, u, 5, p, v, y.g, S.g, 1), g = j(A, m, g, u, 6, p, v, y.b, S.b, 1)), p = v, b = I, y = S, x = w } i.push(m) } else if (h == "rgb2") { let m = new tt(f, f * 6, n), x = d[0], p = k(x, "time", 0), b = D.fromString(x.light), y = D.fromString(x.dark); for (let u = 0, g = 0; ; u++) { m.setFrame(u, p, b.r, b.g, b.b, y.r, y.g, y.b); let w = d[u + 1]; if (!w) { m.shrink(g); break } let v = k(w, "time", 0), I = D.fromString(w.light), S = D.fromString(w.dark), A = x.curve; A && (g = j(A, m, g, u, 0, p, v, b.r, I.r, 1), g = j(A, m, g, u, 1, p, v, b.g, I.g, 1), g = j(A, m, g, u, 2, p, v, b.b, I.b, 1), g = j(A, m, g, u, 3, p, v, y.r, S.r, 1), g = j(A, m, g, u, 4, p, v, y.g, S.g, 1), g = j(A, m, g, u, 5, p, v, y.b, S.b, 1)), p = v, b = I, y = S, x = w } i.push(m) } } } if (e.bones) for (let o in e.bones) { let s = e.bones[o], l = t.findBone(o); if (!l) throw new Error("Bone not found: " + o); let n = l.index; for (let h in s) { let d = s[h], f = d.length; if (f != 0) { if (h === "rotate") i.push(Te(d, new Ye(f, f, n), 0, 1)); else if (h === "translate") { let m = new Ue(f, f << 1, n); i.push(Fr(d, m, "x", "y", 0, a)) } else if (h === "translatex") { let m = new We(f, f, n); i.push(Te(d, m, 0, a)) } else if (h === "translatey") { let m = new ze(f, f, n); i.push(Te(d, m, 0, a)) } else if (h === "scale") { let m = new $e(f, f << 1, n); i.push(Fr(d, m, "x", "y", 1, 1)) } else if (h === "scalex") { let m = new He(f, f, n); i.push(Te(d, m, 1, 1)) } else if (h === "scaley") { let m = new _e(f, f, n); i.push(Te(d, m, 1, 1)) } else if (h === "shear") { let m = new Ge(f, f << 1, n); i.push(Fr(d, m, "x", "y", 0, 1)) } else if (h === "shearx") { let m = new je(f, f, n); i.push(Te(d, m, 0, 1)) } else if (h === "sheary") { let m = new Je(f, f, n); i.push(Te(d, m, 0, 1)) } } } } if (e.ik) for (let o in e.ik) { let s = e.ik[o], l = s[0]; if (!l) continue; let n = t.findIkConstraint(o); if (!n) throw new Error("IK Constraint not found: " + o); let h = t.ikConstraints.indexOf(n), d = new st(s.length, s.length << 1, h), f = k(l, "time", 0), m = k(l, "mix", 1), x = k(l, "softness", 0) * a; for (let p = 0, b = 0; ; p++) { d.setFrame(p, f, m, x, k(l, "bendPositive", !0) ? 1 : -1, k(l, "compress", !1), k(l, "stretch", !1)); let y = s[p + 1]; if (!y) { d.shrink(b); break } let u = k(y, "time", 0), g = k(y, "mix", 1), w = k(y, "softness", 0) * a, v = l.curve; v && (b = j(v, d, b, p, 0, f, u, m, g, 1), b = j(v, d, b, p, 1, f, u, x, w, a)), f = u, m = g, x = w, l = y } i.push(d) } if (e.transform) for (let o in e.transform) { let s = e.transform[o], l = s[0]; if (!l) continue; let n = t.findTransformConstraint(o); if (!n) throw new Error("Transform constraint not found: " + o); let h = t.transformConstraints.indexOf(n), d = new it(s.length, s.length * 6, h), f = k(l, "time", 0), m = k(l, "mixRotate", 1), x = k(l, "mixX", 1), p = k(l, "mixY", x), b = k(l, "mixScaleX", 1), y = k(l, "mixScaleY", b), u = k(l, "mixShearY", 1); for (let g = 0, w = 0; ; g++) { d.setFrame(g, f, m, x, p, b, y, u); let v = s[g + 1]; if (!v) { d.shrink(w); break } let I = k(v, "time", 0), S = k(v, "mixRotate", 1), A = k(v, "mixX", 1), M = k(v, "mixY", A), B = k(v, "mixScaleX", 1), L = k(v, "mixScaleY", B), P = k(v, "mixShearY", 1), R = l.curve; R && (w = j(R, d, w, g, 0, f, I, m, S, 1), w = j(R, d, w, g, 1, f, I, x, A, 1), w = j(R, d, w, g, 2, f, I, p, M, 1), w = j(R, d, w, g, 3, f, I, b, B, 1), w = j(R, d, w, g, 4, f, I, y, L, 1), w = j(R, d, w, g, 5, f, I, u, P, 1)), f = I, m = S, x = A, p = M, b = B, y = L, b = B, l = v } i.push(d) } if (e.path) for (let o in e.path) { let s = e.path[o], l = t.findPathConstraint(o); if (!l) throw new Error("Path constraint not found: " + o); let n = t.pathConstraints.indexOf(l); for (let h in s) { let d = s[h], f = d[0]; if (!f) continue; let m = d.length; if (h === "position") { let x = new at(m, m, n); i.push(Te(d, x, 0, l.positionMode == de.Fixed ? a : 1)) } else if (h === "spacing") { let x = new nt(m, m, n); i.push(Te(d, x, 0, l.spacingMode == ee.Length || l.spacingMode == ee.Fixed ? a : 1)) } else if (h === "mix") { let x = new lt(m, m * 3, n), p = k(f, "time", 0), b = k(f, "mixRotate", 1), y = k(f, "mixX", 1), u = k(f, "mixY", y); for (let g = 0, w = 0; ; g++) { x.setFrame(g, p, b, y, u); let v = d[g + 1]; if (!v) { x.shrink(w); break } let I = k(v, "time", 0), S = k(v, "mixRotate", 1), A = k(v, "mixX", 1), M = k(v, "mixY", A), B = f.curve; B && (w = j(B, x, w, g, 0, p, I, b, S, 1), w = j(B, x, w, g, 1, p, I, y, A, 1), w = j(B, x, w, g, 2, p, I, u, M, 1)), p = I, b = S, y = A, u = M, f = v } i.push(x) } } } if (e.attachments) for (let o in e.attachments) { let s = e.attachments[o], l = t.findSkin(o); if (!l) throw new Error("Skin not found: " + o); for (let n in s) { let h = s[n], d = t.findSlot(n); if (!d) throw new Error("Slot not found: " + n); let f = d.index; for (let m in h) { let x = h[m], p = l.getAttachment(f, m); for (let b in x) { let y = x[b], u = y[0]; if (u) { if (b == "deform") { let g = p.bones, w = p.vertices, v = g ? w.length / 3 * 2 : w.length, I = new rt(y.length, y.length, f, p), S = k(u, "time", 0); for (let A = 0, M = 0; ; A++) { let B, L = k(u, "vertices", null); if (!L) B = g ? V.newFloatArray(v) : w; else { B = V.newFloatArray(v); let T = k(u, "offset", 0); if (V.arrayCopy(L, 0, B, T, L.length), a != 1) for (let q = T, H = q + L.length; q < H; q++)B[q] *= a; if (!g) for (let q = 0; q < v; q++)B[q] += w[q] } I.setFrame(A, S, B); let P = y[A + 1]; if (!P) { I.shrink(M); break } let R = k(P, "time", 0), X = u.curve; X && (M = j(X, I, M, A, 0, S, R, 0, 1, 1)), S = R, u = P } i.push(I) } else if (b == "sequence") { let g = new ye(y.length, f, p), w = 0; for (let v = 0; v < y.length; v++) { let I = k(u, "delay", w), S = k(u, "time", 0), A = re[k(u, "mode", "hold")], M = k(u, "index", 0); g.setFrame(v, S, A, M, I), w = I, u = y[v + 1] } i.push(g) } } } } } } if (e.drawOrder) { let o = new fe(e.drawOrder.length), s = t.slots.length, l = 0; for (let n = 0; n < e.drawOrder.length; n++, l++) { let h = e.drawOrder[n], d = null, f = k(h, "offsets", null); if (f) { d = V.newArray(s, -1); let m = V.newArray(s - f.length, 0), x = 0, p = 0; for (let b = 0; b < f.length; b++) { let y = f[b], u = t.findSlot(y.slot); if (!u) throw new Error("Slot not found: " + u); let g = u.index; for (; x != g;)m[p++] = x++; d[x + y.offset] = x++ } for (; x < s;)m[p++] = x++; for (let b = s - 1; b >= 0; b--)d[b] == -1 && (d[b] = m[--p]) } o.setFrame(l, k(h, "time", 0), d) } i.push(o) } if (e.events) { let o = new ve(e.events.length), s = 0; for (let l = 0; l < e.events.length; l++, s++) { let n = e.events[l], h = t.findEvent(n.name); if (!h) throw new Error("Event not found: " + n.name); let d = new mt(V.toSinglePrecision(k(n, "time", 0)), h); d.intValue = k(n, "int", h.intValue), d.floatValue = k(n, "float", h.floatValue), d.stringValue = k(n, "string", h.stringValue), d.data.audioPath && (d.volume = k(n, "volume", 1), d.balance = k(n, "balance", 0)), o.setFrame(s, d) } i.push(o) } let c = 0; for (let o = 0, s = i.length; o < s; o++)c = Math.max(c, i[o].getDuration()); t.animations.push(new Ce(r, i, c)) } }; F(xr, "SkeletonJson"); var pr = class { parent; skin; slotIndex; mesh; inheritTimeline; constructor(e, r, t, a, i) { this.mesh = e, this.skin = r, this.slotIndex = t, this.parent = a, this.inheritTimeline = i } }; F(pr, "LinkedMesh"); function Te (Y, e, r, t) { let a = Y[0], i = k(a, "time", 0), c = k(a, "value", r) * t, o = 0; for (let s = 0; ; s++) { e.setFrame(s, i, c); let l = Y[s + 1]; if (!l) return e.shrink(o), e; let n = k(l, "time", 0), h = k(l, "value", r) * t; a.curve && (o = j(a.curve, e, o, s, 0, i, n, c, h, t)), i = n, c = h, a = l } } F(Te, "readTimeline1"); function Fr (Y, e, r, t, a, i) { let c = Y[0], o = k(c, "time", 0), s = k(c, r, a) * i, l = k(c, t, a) * i, n = 0; for (let h = 0; ; h++) { e.setFrame(h, o, s, l); let d = Y[h + 1]; if (!d) return e.shrink(n), e; let f = k(d, "time", 0), m = k(d, r, a) * i, x = k(d, t, a) * i, p = c.curve; p && (n = j(p, e, n, h, 0, o, f, s, m, i), n = j(p, e, n, h, 1, o, f, l, x, i)), o = f, s = m, l = x, c = d } } F(Fr, "readTimeline2"); function j (Y, e, r, t, a, i, c, o, s, l) { if (Y == "stepped") return e.setStepped(t), r; let n = a << 2, h = Y[n], d = Y[n + 1] * l, f = Y[n + 2], m = Y[n + 3] * l; return e.setBezier(r, t, a, i, o, h, d, f, m, c, s), r + 1 } F(j, "readCurve"); function k (Y, e, r) { return Y[e] !== void 0 ? Y[e] : r } F(k, "getValue"); typeof Math.fround > "u" && (Math.fround = function (Y) { return function (e) { return Y[0] = e, Y[0] } }(new Float32Array(1))); return Wr(ds);
      })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/eventemitter3?_v=5.0.1&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/eventemitter3?_v=5.0.1&_env=prod'] = (window) => {
      "use strict"; var __dependency__ = (() => { var b = Object.defineProperty; var a = (s, e) => b(s, "name", { value: e, configurable: !0 }); var m = (s, e) => () => (e || s((e = { exports: {} }).exports, e), e.exports); var O = m((A, x) => { var E = Object.prototype.hasOwnProperty, c = "~"; function y () { } a(y, "Events"); Object.create && (y.prototype = Object.create(null), new y().__proto__ || (c = !1)); function L (s, e, n) { this.fn = s, this.context = e, this.once = n || !1 } a(L, "EE"); function d (s, e, n, r, l) { if (typeof n != "function") throw new TypeError("The listener must be a function"); var f = new L(n, r || s, l), o = c ? c + e : e; return s._events[o] ? s._events[o].fn ? s._events[o] = [s._events[o], f] : s._events[o].push(f) : (s._events[o] = f, s._eventsCount++), s } a(d, "addListener"); function w (s, e) { --s._eventsCount === 0 ? s._events = new y : delete s._events[e] } a(w, "clearEvent"); function u () { this._events = new y, this._eventsCount = 0 } a(u, "EventEmitter"); u.prototype.eventNames = a(function () { var e = [], n, r; if (this._eventsCount === 0) return e; for (r in n = this._events) E.call(n, r) && e.push(c ? r.slice(1) : r); return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(n)) : e }, "eventNames"); u.prototype.listeners = a(function (e) { var n = c ? c + e : e, r = this._events[n]; if (!r) return []; if (r.fn) return [r.fn]; for (var l = 0, f = r.length, o = new Array(f); l < f; l++)o[l] = r[l].fn; return o }, "listeners"); u.prototype.listenerCount = a(function (e) { var n = c ? c + e : e, r = this._events[n]; return r ? r.fn ? 1 : r.length : 0 }, "listenerCount"); u.prototype.emit = a(function (e, n, r, l, f, o) { var h = c ? c + e : e; if (!this._events[h]) return !1; var t = this._events[h], p = arguments.length, v, i; if (t.fn) { switch (t.once && this.removeListener(e, t.fn, void 0, !0), p) { case 1: return t.fn.call(t.context), !0; case 2: return t.fn.call(t.context, n), !0; case 3: return t.fn.call(t.context, n, r), !0; case 4: return t.fn.call(t.context, n, r, l), !0; case 5: return t.fn.call(t.context, n, r, l, f), !0; case 6: return t.fn.call(t.context, n, r, l, f, o), !0 }for (i = 1, v = new Array(p - 1); i < p; i++)v[i - 1] = arguments[i]; t.fn.apply(t.context, v) } else { var g = t.length, _; for (i = 0; i < g; i++)switch (t[i].once && this.removeListener(e, t[i].fn, void 0, !0), p) { case 1: t[i].fn.call(t[i].context); break; case 2: t[i].fn.call(t[i].context, n); break; case 3: t[i].fn.call(t[i].context, n, r); break; case 4: t[i].fn.call(t[i].context, n, r, l); break; default: if (!v) for (_ = 1, v = new Array(p - 1); _ < p; _++)v[_ - 1] = arguments[_]; t[i].fn.apply(t[i].context, v) } } return !0 }, "emit"); u.prototype.on = a(function (e, n, r) { return d(this, e, n, r, !1) }, "on"); u.prototype.once = a(function (e, n, r) { return d(this, e, n, r, !0) }, "once"); u.prototype.removeListener = a(function (e, n, r, l) { var f = c ? c + e : e; if (!this._events[f]) return this; if (!n) return w(this, f), this; var o = this._events[f]; if (o.fn) o.fn === n && (!l || o.once) && (!r || o.context === r) && w(this, f); else { for (var h = 0, t = [], p = o.length; h < p; h++)(o[h].fn !== n || l && !o[h].once || r && o[h].context !== r) && t.push(o[h]); t.length ? this._events[f] = t.length === 1 ? t[0] : t : w(this, f) } return this }, "removeListener"); u.prototype.removeAllListeners = a(function (e) { var n; return e ? (n = c ? c + e : e, this._events[n] && w(this, n)) : (this._events = new y, this._eventsCount = 0), this }, "removeAllListeners"); u.prototype.off = u.prototype.removeListener; u.prototype.addListener = u.prototype.on; u.prefixed = c; u.EventEmitter = u; typeof x < "u" && (x.exports = u) }); return O(); })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/earcut?_v=2.2.4&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/earcut?_v=2.2.4&_env=prod'] = (window) => {
      "use strict"; var __dependency__ = (() => { var U = Object.defineProperty; var l = (e, r) => U(e, "name", { value: r, configurable: !0 }); var W = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports); var te = W((ue, T) => { T.exports = C; T.exports.default = C; function C (e, r, n) { n = n || 2; var t = r && r.length, x = t ? r[0] * n : e.length, u = K(e, 0, x, n, !0), f = []; if (!u || u.next === u.prev) return f; var i, o, v, Z, p, y, g; if (t && (u = X(e, r, u, n)), e.length > 80 * n) { i = v = e[0], o = Z = e[1]; for (var c = n; c < x; c += n)p = e[c], y = e[c + 1], p < i && (i = p), y < o && (o = y), p > v && (v = p), y > Z && (Z = y); g = Math.max(v - i, Z - o), g = g !== 0 ? 32767 / g : 0 } return H(u, f, n, i, o, g, 0), f } l(C, "earcut"); function K (e, r, n, t, x) { var u, f; if (x === R(e, r, n, t) > 0) for (u = r; u < n; u += t)f = J(u, e[u], e[u + 1], f); else for (u = n - t; u >= r; u -= t)f = J(u, e[u], e[u + 1], f); return f && B(f, f.next) && (A(f), f = f.next), f } l(K, "linkedList"); function F (e, r) { if (!e) return e; r || (r = e); var n = e, t; do if (t = !1, !n.steiner && (B(n, n.next) || w(n.prev, n, n.next) === 0)) { if (A(n), n = r = n.prev, n === n.next) break; t = !0 } else n = n.next; while (t || n !== r); return r } l(F, "filterPoints"); function H (e, r, n, t, x, u, f) { if (e) { !f && u && m(e, t, x, u); for (var i = e, o, v; e.prev !== e.next;) { if (o = e.prev, v = e.next, u ? $(e, t, x, u) : _(e)) { r.push(o.i / n | 0), r.push(e.i / n | 0), r.push(v.i / n | 0), A(e), e = v.next, i = v.next; continue } if (e = v, e === i) { f ? f === 1 ? (e = I(F(e), r, n), H(e, r, n, t, x, u, 2)) : f === 2 && S(e, r, n, t, x, u) : H(F(e), r, n, t, x, u, 1); break } } } } l(H, "earcutLinked"); function _ (e) { var r = e.prev, n = e, t = e.next; if (w(r, n, t) >= 0) return !1; for (var x = r.x, u = n.x, f = t.x, i = r.y, o = n.y, v = t.y, Z = x < u ? x < f ? x : f : u < f ? u : f, p = i < o ? i < v ? i : v : o < v ? o : v, y = x > u ? x > f ? x : f : u > f ? u : f, g = i > o ? i > v ? i : v : o > v ? o : v, c = t.next; c !== r;) { if (c.x >= Z && c.x <= y && c.y >= p && c.y <= g && M(x, i, u, o, f, v, c.x, c.y) && w(c.prev, c, c.next) >= 0) return !1; c = c.next } return !0 } l(_, "isEar"); function $ (e, r, n, t) { var x = e.prev, u = e, f = e.next; if (w(x, u, f) >= 0) return !1; for (var i = x.x, o = u.x, v = f.x, Z = x.y, p = u.y, y = f.y, g = i < o ? i < v ? i : v : o < v ? o : v, c = Z < p ? Z < y ? Z : y : p < y ? p : y, L = i > o ? i > v ? i : v : o > v ? o : v, k = Z > p ? Z > y ? Z : y : p > y ? p : y, V = D(g, c, r, n, t), G = D(L, k, r, n, t), h = e.prevZ, s = e.nextZ; h && h.z >= V && s && s.z <= G;) { if (h.x >= g && h.x <= L && h.y >= c && h.y <= k && h !== x && h !== f && M(i, Z, o, p, v, y, h.x, h.y) && w(h.prev, h, h.next) >= 0 || (h = h.prevZ, s.x >= g && s.x <= L && s.y >= c && s.y <= k && s !== x && s !== f && M(i, Z, o, p, v, y, s.x, s.y) && w(s.prev, s, s.next) >= 0)) return !1; s = s.nextZ } for (; h && h.z >= V;) { if (h.x >= g && h.x <= L && h.y >= c && h.y <= k && h !== x && h !== f && M(i, Z, o, p, v, y, h.x, h.y) && w(h.prev, h, h.next) >= 0) return !1; h = h.prevZ } for (; s && s.z <= G;) { if (s.x >= g && s.x <= L && s.y >= c && s.y <= k && s !== x && s !== f && M(i, Z, o, p, v, y, s.x, s.y) && w(s.prev, s, s.next) >= 0) return !1; s = s.nextZ } return !0 } l($, "isEarHashed"); function I (e, r, n) { var t = e; do { var x = t.prev, u = t.next.next; !B(x, u) && N(x, t, t.next, u) && z(x, u) && z(u, x) && (r.push(x.i / n | 0), r.push(t.i / n | 0), r.push(u.i / n | 0), A(t), A(t.next), t = e = u), t = t.next } while (t !== e); return F(t) } l(I, "cureLocalIntersections"); function S (e, r, n, t, x, u) { var f = e; do { for (var i = f.next.next; i !== f.prev;) { if (f.i !== i.i && ee(f, i)) { var o = Q(f, i); f = F(f, f.next), o = F(o, o.next), H(f, r, n, t, x, u, 0), H(o, r, n, t, x, u, 0); return } i = i.next } f = f.next } while (f !== e) } l(S, "splitEarcut"); function X (e, r, n, t) { var x = [], u, f, i, o, v; for (u = 0, f = r.length; u < f; u++)i = r[u] * t, o = u < f - 1 ? r[u + 1] * t : e.length, v = K(e, i, o, t, !1), v === v.next && (v.steiner = !0), x.push(d(v)); for (x.sort(j), u = 0; u < x.length; u++)n = Y(x[u], n); return n } l(X, "eliminateHoles"); function j (e, r) { return e.x - r.x } l(j, "compareX"); function Y (e, r) { var n = q(e, r); if (!n) return r; var t = Q(n, e); return F(t, t.next), F(n, n.next) } l(Y, "eliminateHole"); function q (e, r) { var n = r, t = e.x, x = e.y, u = -1 / 0, f; do { if (x <= n.y && x >= n.next.y && n.next.y !== n.y) { var i = n.x + (x - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (i <= t && i > u && (u = i, f = n.x < n.next.x ? n : n.next, i === t)) return f } n = n.next } while (n !== r); if (!f) return null; var o = f, v = f.x, Z = f.y, p = 1 / 0, y; n = f; do t >= n.x && n.x >= v && t !== n.x && M(x < Z ? t : u, x, v, Z, x < Z ? u : t, x, n.x, n.y) && (y = Math.abs(x - n.y) / (t - n.x), z(n, e) && (y < p || y === p && (n.x > f.x || n.x === f.x && b(f, n))) && (f = n, p = y)), n = n.next; while (n !== o); return f } l(q, "findHoleBridge"); function b (e, r) { return w(e.prev, e, r.prev) < 0 && w(r.next, e, e.next) < 0 } l(b, "sectorContainsSector"); function m (e, r, n, t) { var x = e; do x.z === 0 && (x.z = D(x.x, x.y, r, n, t)), x.prevZ = x.prev, x.nextZ = x.next, x = x.next; while (x !== e); x.prevZ.nextZ = null, x.prevZ = null, a(x) } l(m, "indexCurve"); function a (e) { var r, n, t, x, u, f, i, o, v = 1; do { for (n = e, e = null, u = null, f = 0; n;) { for (f++, t = n, i = 0, r = 0; r < v && (i++, t = t.nextZ, !!t); r++); for (o = v; i > 0 || o > 0 && t;)i !== 0 && (o === 0 || !t || n.z <= t.z) ? (x = n, n = n.nextZ, i--) : (x = t, t = t.nextZ, o--), u ? u.nextZ = x : e = x, x.prevZ = u, u = x; n = t } u.nextZ = null, v *= 2 } while (f > 1); return e } l(a, "sortLinked"); function D (e, r, n, t, x) { return e = (e - n) * x | 0, r = (r - t) * x | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e | r << 1 } l(D, "zOrder"); function d (e) { var r = e, n = e; do (r.x < n.x || r.x === n.x && r.y < n.y) && (n = r), r = r.next; while (r !== e); return n } l(d, "getLeftmost"); function M (e, r, n, t, x, u, f, i) { return (x - f) * (r - i) >= (e - f) * (u - i) && (e - f) * (t - i) >= (n - f) * (r - i) && (n - f) * (u - i) >= (x - f) * (t - i) } l(M, "pointInTriangle"); function ee (e, r) { return e.next.i !== r.i && e.prev.i !== r.i && !ne(e, r) && (z(e, r) && z(r, e) && re(e, r) && (w(e.prev, e, r.prev) || w(e, r.prev, r)) || B(e, r) && w(e.prev, e, e.next) > 0 && w(r.prev, r, r.next) > 0) } l(ee, "isValidDiagonal"); function w (e, r, n) { return (r.y - e.y) * (n.x - r.x) - (r.x - e.x) * (n.y - r.y) } l(w, "area"); function B (e, r) { return e.x === r.x && e.y === r.y } l(B, "equals"); function N (e, r, n, t) { var x = P(w(e, r, n)), u = P(w(e, r, t)), f = P(w(n, t, e)), i = P(w(n, t, r)); return !!(x !== u && f !== i || x === 0 && E(e, n, r) || u === 0 && E(e, t, r) || f === 0 && E(n, e, t) || i === 0 && E(n, r, t)) } l(N, "intersects"); function E (e, r, n) { return r.x <= Math.max(e.x, n.x) && r.x >= Math.min(e.x, n.x) && r.y <= Math.max(e.y, n.y) && r.y >= Math.min(e.y, n.y) } l(E, "onSegment"); function P (e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } l(P, "sign"); function ne (e, r) { var n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== r.i && n.next.i !== r.i && N(n, n.next, e, r)) return !0; n = n.next } while (n !== e); return !1 } l(ne, "intersectsPolygon"); function z (e, r) { return w(e.prev, e, e.next) < 0 ? w(e, r, e.next) >= 0 && w(e, e.prev, r) >= 0 : w(e, r, e.prev) < 0 || w(e, e.next, r) < 0 } l(z, "locallyInside"); function re (e, r) { var n = e, t = !1, x = (e.x + r.x) / 2, u = (e.y + r.y) / 2; do n.y > u != n.next.y > u && n.next.y !== n.y && x < (n.next.x - n.x) * (u - n.y) / (n.next.y - n.y) + n.x && (t = !t), n = n.next; while (n !== e); return t } l(re, "middleInside"); function Q (e, r) { var n = new O(e.i, e.x, e.y), t = new O(r.i, r.x, r.y), x = e.next, u = r.prev; return e.next = r, r.prev = e, n.next = x, x.prev = n, t.next = n, n.prev = t, u.next = t, t.prev = u, t } l(Q, "splitPolygon"); function J (e, r, n, t) { var x = new O(e, r, n); return t ? (x.next = t.next, x.prev = t, t.next.prev = x, t.next = x) : (x.prev = x, x.next = x), x } l(J, "insertNode"); function A (e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } l(A, "removeNode"); function O (e, r, n) { this.i = e, this.x = r, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } l(O, "Node"); C.deviation = function (e, r, n, t) { var x = r && r.length, u = x ? r[0] * n : e.length, f = Math.abs(R(e, 0, u, n)); if (x) for (var i = 0, o = r.length; i < o; i++) { var v = r[i] * n, Z = i < o - 1 ? r[i + 1] * n : e.length; f -= Math.abs(R(e, v, Z, n)) } var p = 0; for (i = 0; i < t.length; i += 3) { var y = t[i] * n, g = t[i + 1] * n, c = t[i + 2] * n; p += Math.abs((e[y] - e[c]) * (e[g + 1] - e[y + 1]) - (e[y] - e[g]) * (e[c + 1] - e[y + 1])) } return f === 0 && p === 0 ? 0 : Math.abs((p - f) / f) }; function R (e, r, n, t) { for (var x = 0, u = r, f = n - t; u < n; u += t)x += (e[f] - e[u]) * (e[u + 1] + e[f + 1]), f = u; return x } l(R, "signedArea"); C.flatten = function (e) { for (var r = e[0][0].length, n = { vertices: [], holes: [], dimensions: r }, t = 0, x = 0; x < e.length; x++) { for (var u = 0; u < e[x].length; u++)for (var f = 0; f < r; f++)n.vertices.push(e[x][u][f]); x > 0 && (t += e[x - 1].length, n.holes.push(t)) } return n } }); return te(); })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/parse-svg-path?_v=0.1.2&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/parse-svg-path?_v=0.1.2&_env=prod'] = (window) => {
      var __dependency__ = (() => { var p = Object.defineProperty; var n = (r, e) => p(r, "name", { value: e, configurable: !0 }); var a = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports); var o = a((m, i) => { i.exports = v; var u = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, c = /([astvzqmhlc])([^astvzqmhlc]*)/ig; function v (r) { var e = []; return r.replace(c, function (w, h, t) { var l = h.toLowerCase(); for (t = s(t), l == "m" && t.length > 2 && (e.push([h].concat(t.splice(0, 2))), l = "l", h = h == "m" ? "l" : "L"); ;) { if (t.length == u[l]) return t.unshift(h), e.push(t); if (t.length < u[l]) throw new Error("malformed path data"); e.push([h].concat(t.splice(0, u[l]))) } }), e } n(v, "parse"); var f = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig; function s (r) { var e = r.match(f); return e ? e.map(Number) : [] } n(s, "parseValues") }); return o(); })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/@pixi/colord?_v=2.9.6&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/@pixi/colord?_v=2.9.6&_env=prod'] = (window) => {
      var __dependency__ = (() => { var l = Object.defineProperty; var C = Object.getOwnPropertyDescriptor; var D = Object.getOwnPropertyNames; var L = Object.prototype.hasOwnProperty; var o = (n, t) => l(n, "name", { value: t, configurable: !0 }); var O = (n, t) => { for (var r in t) l(n, r, { get: t[r], enumerable: !0 }) }, P = (n, t, r, e) => { if (t && typeof t == "object" || typeof t == "function") for (let u of D(t)) !L.call(n, u) && u !== r && l(n, u, { get: () => t[u], enumerable: !(e = C(t, u)) || e.enumerable }); return n }; var V = n => P(l({}, "__esModule", { value: !0 }), n); var W = {}; O(W, { Colord: () => c, colord: () => d, extend: () => T, getFormat: () => Q, random: () => U }); var z = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) }, g = o(function (n) { return typeof n == "string" ? n.length > 0 : typeof n == "number" }, "t"), s = o(function (n, t, r) { return t === void 0 && (t = 0), r === void 0 && (r = Math.pow(10, t)), Math.round(r * n) / r + 0 }, "n"), b = o(function (n, t, r) { return t === void 0 && (t = 0), r === void 0 && (r = 1), n > r ? r : n > t ? n : t }, "e"), E = o(function (n) { return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360 }, "u"), M = o(function (n) { return { r: b(n.r, 0, 255), g: b(n.g, 0, 255), b: b(n.b, 0, 255), a: b(n.a) } }, "a"), y = o(function (n) { return { r: s(n.r), g: s(n.g), b: s(n.b), a: s(n.a, 3) } }, "o"), A = /^#([0-9a-f]{3,8})$/i, p = o(function (n) { var t = n.toString(16); return t.length < 2 ? "0" + t : t }, "s"), F = o(function (n) { var t = n.r, r = n.g, e = n.b, u = n.a, a = Math.max(t, r, e), i = a - Math.min(t, r, e), h = i ? a === t ? (r - e) / i : a === r ? 2 + (e - t) / i : 4 + (t - r) / i : 0; return { h: 60 * (h < 0 ? h + 6 : h), s: a ? i / a * 100 : 0, v: a / 255 * 100, a: u } }, "h"), R = o(function (n) { var t = n.h, r = n.s, e = n.v, u = n.a; t = t / 360 * 6, r /= 100, e /= 100; var a = Math.floor(t), i = e * (1 - r), h = e * (1 - (t - a) * r), v = e * (1 - (1 - t + a) * r), m = a % 6; return { r: 255 * [e, h, i, i, v, e][m], g: 255 * [v, e, e, h, i, i][m], b: 255 * [i, i, v, e, e, h][m], a: u } }, "b"), H = o(function (n) { return { h: E(n.h), s: b(n.s, 0, 100), l: b(n.l, 0, 100), a: b(n.a) } }, "g"), $ = o(function (n) { return { h: s(n.h), s: s(n.s), l: s(n.l), a: s(n.a, 3) } }, "d"), j = o(function (n) { return R((r = (t = n).s, { h: t.h, s: (r *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * r / (e + r) * 100 : 0, v: e + r, a: t.a })); var t, r, e }, "f"), f = o(function (n) { return { h: (t = F(n)).h, s: (u = (200 - (r = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? r * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0, l: u / 2, a: t.a }; var t, r, e, u }, "c"), B = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, G = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, J = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, K = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, I = { string: [[function (n) { var t = A.exec(n); return t ? (n = t[1]).length <= 4 ? { r: parseInt(n[0] + n[0], 16), g: parseInt(n[1] + n[1], 16), b: parseInt(n[2] + n[2], 16), a: n.length === 4 ? s(parseInt(n[3] + n[3], 16) / 255, 2) : 1 } : n.length === 6 || n.length === 8 ? { r: parseInt(n.substr(0, 2), 16), g: parseInt(n.substr(2, 2), 16), b: parseInt(n.substr(4, 2), 16), a: n.length === 8 ? s(parseInt(n.substr(6, 2), 16) / 255, 2) : 1 } : null : null }, "hex"], [function (n) { var t = J.exec(n) || K.exec(n); return t ? t[2] !== t[4] || t[4] !== t[6] ? null : M({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null }, "rgb"], [function (n) { var t = B.exec(n) || G.exec(n); if (!t) return null; var r, e, u = H({ h: (r = t[1], e = t[2], e === void 0 && (e = "deg"), Number(r) * (z[e] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) }); return j(u) }, "hsl"]], object: [[function (n) { var t = n.r, r = n.g, e = n.b, u = n.a, a = u === void 0 ? 1 : u; return g(t) && g(r) && g(e) ? M({ r: Number(t), g: Number(r), b: Number(e), a: Number(a) }) : null }, "rgb"], [function (n) { var t = n.h, r = n.s, e = n.l, u = n.a, a = u === void 0 ? 1 : u; if (!g(t) || !g(r) || !g(e)) return null; var i = H({ h: Number(t), s: Number(r), l: Number(e), a: Number(a) }); return j(i) }, "hsl"], [function (n) { var t = n.h, r = n.s, e = n.v, u = n.a, a = u === void 0 ? 1 : u; if (!g(t) || !g(r) || !g(e)) return null; var i = function (h) { return { h: E(h.h), s: b(h.s, 0, 100), v: b(h.v, 0, 100), a: b(h.a) } }({ h: Number(t), s: Number(r), v: Number(e), a: Number(a) }); return R(i) }, "hsv"]] }, w = o(function (n, t) { for (var r = 0; r < t.length; r++) { var e = t[r][0](n); if (e) return [e, t[r][1]] } return [null, void 0] }, "N"), q = o(function (n) { return typeof n == "string" ? w(n.trim(), I.string) : typeof n == "object" && n !== null ? w(n, I.object) : [null, void 0] }, "x"), Q = o(function (n) { return q(n)[1] }, "I"), N = o(function (n, t) { var r = f(n); return { h: r.h, s: b(r.s + 100 * t, 0, 100), l: r.l, a: r.a } }, "M"), x = o(function (n) { return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255 }, "H"), S = o(function (n, t) { var r = f(n); return { h: r.h, s: r.s, l: b(r.l + 100 * t, 0, 100), a: r.a } }, "$"), c = function () { function n (t) { this.parsed = q(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 } } return o(n, "r"), n.prototype.isValid = function () { return this.parsed !== null }, n.prototype.brightness = function () { return s(x(this.rgba), 2) }, n.prototype.isDark = function () { return x(this.rgba) < .5 }, n.prototype.isLight = function () { return x(this.rgba) >= .5 }, n.prototype.toHex = function () { return t = y(this.rgba), r = t.r, e = t.g, u = t.b, i = (a = t.a) < 1 ? p(s(255 * a)) : "", "#" + p(r) + p(e) + p(u) + i; var t, r, e, u, a, i }, n.prototype.toRgb = function () { return y(this.rgba) }, n.prototype.toRgbString = function () { return t = y(this.rgba), r = t.r, e = t.g, u = t.b, (a = t.a) < 1 ? "rgba(" + r + ", " + e + ", " + u + ", " + a + ")" : "rgb(" + r + ", " + e + ", " + u + ")"; var t, r, e, u, a }, n.prototype.toHsl = function () { return $(f(this.rgba)) }, n.prototype.toHslString = function () { return t = $(f(this.rgba)), r = t.h, e = t.s, u = t.l, (a = t.a) < 1 ? "hsla(" + r + ", " + e + "%, " + u + "%, " + a + ")" : "hsl(" + r + ", " + e + "%, " + u + "%)"; var t, r, e, u, a }, n.prototype.toHsv = function () { return t = F(this.rgba), { h: s(t.h), s: s(t.s), v: s(t.v), a: s(t.a, 3) }; var t }, n.prototype.invert = function () { return d({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a }); var t }, n.prototype.saturate = function (t) { return t === void 0 && (t = .1), d(N(this.rgba, t)) }, n.prototype.desaturate = function (t) { return t === void 0 && (t = .1), d(N(this.rgba, -t)) }, n.prototype.grayscale = function () { return d(N(this.rgba, -1)) }, n.prototype.lighten = function (t) { return t === void 0 && (t = .1), d(S(this.rgba, t)) }, n.prototype.darken = function (t) { return t === void 0 && (t = .1), d(S(this.rgba, -t)) }, n.prototype.rotate = function (t) { return t === void 0 && (t = 15), this.hue(this.hue() + t) }, n.prototype.alpha = function (t) { return typeof t == "number" ? d({ r: (r = this.rgba).r, g: r.g, b: r.b, a: t }) : s(this.rgba.a, 3); var r }, n.prototype.hue = function (t) { var r = f(this.rgba); return typeof t == "number" ? d({ h: t, s: r.s, l: r.l, a: r.a }) : s(r.h) }, n.prototype.isEqual = function (t) { return this.toHex() === d(t).toHex() }, n }(), d = o(function (n) { return n instanceof c ? n : new c(n) }, "w"), k = [], T = o(function (n) { n.forEach(function (t) { k.indexOf(t) < 0 && (t(c, I), k.push(t)) }) }, "k"), U = o(function () { return new c({ r: 255 * Math.random(), g: 255 * Math.random(), b: 255 * Math.random() }) }, "E"); return V(W); })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/ismobilejs?_v=1.1.1&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/ismobilejs?_v=1.1.1&_env=prod'] = (window) => {
      var __dependency__ = (() => { var d = Object.defineProperty; var M = Object.getOwnPropertyDescriptor; var B = Object.getOwnPropertyNames; var k = Object.prototype.hasOwnProperty; var p = (o, i) => d(o, "name", { value: i, configurable: !0 }); var S = (o, i) => { for (var r in i) d(o, r, { get: i[r], enumerable: !0 }) }, O = (o, i, r, a) => { if (i && typeof i == "object" || typeof i == "function") for (let e of B(i)) !k.call(o, e) && e !== r && d(o, e, { get: () => i[e], enumerable: !(a = M(i, e)) || a.enumerable }); return o }; var I = o => O(d({}, "__esModule", { value: !0 }), o); var C = {}; S(C, { default: () => h }); var f = /iPhone/i, u = /iPod/i, v = /iPad/i, c = /\biOS-universal(?:.+)Mac\b/i, b = /\bAndroid(?:.+)Mobile\b/i, m = /Android/i, l = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, s = /Silk/i, n = /Windows Phone/i, w = /\bWindows(?:.+)ARM\b/i, y = /BlackBerry/i, A = /BB10/i, P = /Opera Mini/i, x = /\b(CriOS|Chrome)(?:.+)Mobile/i, T = /Mobile(?:.+)Firefox\b/i, g = p(function (o) { return typeof o < "u" && o.platform === "MacIntel" && typeof o.maxTouchPoints == "number" && o.maxTouchPoints > 1 && typeof MSStream > "u" }, "isAppleTabletOnIos13"); function z (o) { return function (i) { return i.test(o) } } p(z, "createMatch"); function h (o) { var i = { userAgent: "", platform: "", maxTouchPoints: 0 }; !o && typeof navigator < "u" ? i = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 } : typeof o == "string" ? i.userAgent = o : o && o.userAgent && (i = { userAgent: o.userAgent, platform: o.platform, maxTouchPoints: o.maxTouchPoints || 0 }); var r = i.userAgent, a = r.split("[FBAN"); typeof a[1] < "u" && (r = a[0]), a = r.split("Twitter"), typeof a[1] < "u" && (r = a[0]); var e = z(r), t = { apple: { phone: e(f) && !e(n), ipod: e(u), tablet: !e(f) && (e(v) || g(i)) && !e(n), universal: e(c), device: (e(f) || e(u) || e(v) || e(c) || g(i)) && !e(n) }, amazon: { phone: e(l), tablet: !e(l) && e(s), device: e(l) || e(s) }, android: { phone: !e(n) && e(l) || !e(n) && e(b), tablet: !e(n) && !e(l) && !e(b) && (e(s) || e(m)), device: !e(n) && (e(l) || e(s) || e(b) || e(m)) || e(/\bokhttp\b/i) }, windows: { phone: e(n), tablet: e(w), device: e(n) || e(w) }, other: { blackberry: e(y), blackberry10: e(A), opera: e(P), firefox: e(T), chrome: e(x), device: e(y) || e(A) || e(P) || e(T) || e(x) }, any: !1, phone: !1, tablet: !1 }; return t.any = t.apple.device || t.android.device || t.windows.device || t.other.device, t.phone = t.apple.phone || t.android.phone || t.windows.phone, t.tablet = t.apple.tablet || t.android.tablet || t.windows.tablet, t } p(h, "isMobile"); return I(C); })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/@pixi/colord/plugins/names?_v=2.9.6&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/@pixi/colord/plugins/names?_v=2.9.6&_env=prod'] = (window) => {
      var __dependency__ = (() => { var k = (d, a) => () => (a || d((a = { exports: {} }).exports, a), a.exports); var p = k((w, h) => { h.exports = function (d, a) { var r = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, o = {}; for (var n in r) o[r[n]] = n; var i = {}; d.prototype.toName = function (l) { if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent"; var e, f, t = o[this.toHex()]; if (t) return t; if (l?.closest) { var m = this.toRgb(), b = 1 / 0, c = "black"; if (!i.length) for (var g in r) i[g] = new d(r[g]).toRgb(); for (var s in r) { var u = (e = m, f = i[s], Math.pow(e.r - f.r, 2) + Math.pow(e.g - f.g, 2) + Math.pow(e.b - f.b, 2)); u < b && (b = u, c = s) } return c } }, a.string.push([function (l) { var e = l.toLowerCase(), f = e === "transparent" ? "#0000" : r[e]; return f ? new d(f).toRgb() : null }, "name"]) } }); return p(); })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/@xmldom/xmldom?_v=0.8.10&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/@xmldom/xmldom?_v=0.8.10&_env=prod'] = (window) => {
      var __dependency__ = (() => {
        var Me = Object.defineProperty; var a = (u, e) => Me(u, "name", { value: e, configurable: !0 }); var V = (u, e) => () => (e || u((e = { exports: {} }).exports, e), e.exports); var J = V(G => { "use strict"; function Ue (u, e, r) { if (r === void 0 && (r = Array.prototype), u && typeof r.find == "function") return r.find.call(u, e); for (var t = 0; t < u.length; t++)if (Object.prototype.hasOwnProperty.call(u, t)) { var n = u[t]; if (e.call(void 0, n, t, u)) return n } } a(Ue, "find"); function wu (u, e) { return e === void 0 && (e = Object), e && typeof e.freeze == "function" ? e.freeze(u) : u } a(wu, "freeze"); function Pe (u, e) { if (u === null || typeof u != "object") throw new TypeError("target is not an object"); for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (u[r] = e[r]); return u } a(Pe, "assign"); var Gu = wu({ HTML: "text/html", isHTML: function (u) { return u === Gu.HTML }, XML_APPLICATION: "application/xml", XML_TEXT: "text/xml", XML_XHTML_APPLICATION: "application/xhtml+xml", XML_SVG_IMAGE: "image/svg+xml" }), zu = wu({ HTML: "http://www.w3.org/1999/xhtml", isHTML: function (u) { return u === zu.HTML }, SVG: "http://www.w3.org/2000/svg", XML: "http://www.w3.org/XML/1998/namespace", XMLNS: "http://www.w3.org/2000/xmlns/" }); G.assign = Pe; G.find = Ue; G.freeze = wu; G.MIME_TYPE = Gu; G.NAMESPACE = zu }); var _u = V(M => { var Qu = J(), O = Qu.find, K = Qu.NAMESPACE; function Ve (u) { return u !== "" } a(Ve, "notEmptyString"); function Ge (u) { return u ? u.split(/[\t\n\f\r ]+/).filter(Ve) : [] } a(Ge, "splitOnASCIIWhitespace"); function ze (u, e) { return u.hasOwnProperty(e) || (u[e] = !0), u } a(ze, "orderedSetReducer"); function Hu (u) { if (!u) return []; var e = Ge(u); return Object.keys(e.reduce(ze, {})) } a(Hu, "toOrderedSet"); function He (u) { return function (e) { return u && u.indexOf(e) !== -1 } } a(He, "arrayIncludes"); function eu (u, e) { for (var r in u) Object.prototype.hasOwnProperty.call(u, r) && (e[r] = u[r]) } a(eu, "copy"); function T (u, e) { var r = u.prototype; if (!(r instanceof e)) { let n = function () { }; var t = n; a(n, "t"), n.prototype = e.prototype, n = new n, eu(r, n), u.prototype = r = n } r.constructor != u && (typeof u != "function" && console.error("unknown Class:" + u), r.constructor = u) } a(T, "_extends"); var F = {}, R = F.ELEMENT_NODE = 1, H = F.ATTRIBUTE_NODE = 2, cu = F.TEXT_NODE = 3, Ju = F.CDATA_SECTION_NODE = 4, Ku = F.ENTITY_REFERENCE_NODE = 5, je = F.ENTITY_NODE = 6, ue = F.PROCESSING_INSTRUCTION_NODE = 7, ee = F.COMMENT_NODE = 8, re = F.DOCUMENT_NODE = 9, te = F.DOCUMENT_TYPE_NODE = 10, L = F.DOCUMENT_FRAGMENT_NODE = 11, Xe = F.NOTATION_NODE = 12, w = {}, b = {}, mr = w.INDEX_SIZE_ERR = (b[1] = "Index size error", 1), Er = w.DOMSTRING_SIZE_ERR = (b[2] = "DOMString size error", 2), y = w.HIERARCHY_REQUEST_ERR = (b[3] = "Hierarchy request error", 3), gr = w.WRONG_DOCUMENT_ERR = (b[4] = "Wrong document", 4), dr = w.INVALID_CHARACTER_ERR = (b[5] = "Invalid character", 5), Cr = w.NO_DATA_ALLOWED_ERR = (b[6] = "No data allowed", 6), vr = w.NO_MODIFICATION_ALLOWED_ERR = (b[7] = "No modification allowed", 7), ne = w.NOT_FOUND_ERR = (b[8] = "Not found", 8), br = w.NOT_SUPPORTED_ERR = (b[9] = "Not supported", 9), ju = w.INUSE_ATTRIBUTE_ERR = (b[10] = "Attribute in use", 10), wr = w.INVALID_STATE_ERR = (b[11] = "Invalid state", 11), Nr = w.SYNTAX_ERR = (b[12] = "Syntax error", 12), Br = w.INVALID_MODIFICATION_ERR = (b[13] = "Invalid modification", 13), yr = w.NAMESPACE_ERR = (b[14] = "Invalid namespace", 14), Tr = w.INVALID_ACCESS_ERR = (b[15] = "Invalid access", 15); function d (u, e) { if (e instanceof Error) var r = e; else r = this, Error.call(this, b[u]), this.message = b[u], Error.captureStackTrace && Error.captureStackTrace(this, d); return r.code = u, e && (this.message = this.message + ": " + e), r } a(d, "DOMException"); d.prototype = Error.prototype; eu(w, d); function I () { } a(I, "NodeList"); I.prototype = { length: 0, item: function (u) { return u >= 0 && u < this.length ? this[u] : null }, toString: function (u, e) { for (var r = [], t = 0; t < this.length; t++)z(this[t], r, u, e); return r.join("") }, filter: function (u) { return Array.prototype.filter.call(this, u) }, indexOf: function (u) { return Array.prototype.indexOf.call(this, u) } }; function j (u, e) { this._node = u, this._refresh = e, yu(this) } a(j, "LiveNodeList"); function yu (u) { var e = u._node._inc || u._node.ownerDocument._inc; if (u._inc !== e) { var r = u._refresh(u._node); if (me(u, "length", r.length), !u.$$length || r.length < u.$$length) for (var t = r.length; t in u; t++)Object.prototype.hasOwnProperty.call(u, t) && delete u[t]; eu(r, u), u._inc = e } } a(yu, "_updateLiveList"); j.prototype.item = function (u) { return yu(this), this[u] || null }; T(j, I); function pu () { } a(pu, "NamedNodeMap"); function ae (u, e) { for (var r = u.length; r--;)if (u[r] === e) return r } a(ae, "_findNodeIndex"); function Xu (u, e, r, t) { if (t ? e[ae(e, t)] = r : e[e.length++] = r, u) { r.ownerElement = u; var n = u.ownerDocument; n && (t && se(n, u, t), Ye(n, u, r)) } } a(Xu, "_addNamedNode"); function Yu (u, e, r) { var t = ae(e, r); if (t >= 0) { for (var n = e.length - 1; t < n;)e[t] = e[++t]; if (e.length = n, u) { var i = u.ownerDocument; i && (se(i, u, r), r.ownerElement = null) } } else throw new d(ne, new Error(u.tagName + "@" + r)) } a(Yu, "_removeNamedNode"); pu.prototype = { length: 0, item: I.prototype.item, getNamedItem: function (u) { for (var e = this.length; e--;) { var r = this[e]; if (r.nodeName == u) return r } }, setNamedItem: function (u) { var e = u.ownerElement; if (e && e != this._ownerElement) throw new d(ju); var r = this.getNamedItem(u.nodeName); return Xu(this._ownerElement, this, u, r), r }, setNamedItemNS: function (u) { var e = u.ownerElement, r; if (e && e != this._ownerElement) throw new d(ju); return r = this.getNamedItemNS(u.namespaceURI, u.localName), Xu(this._ownerElement, this, u, r), r }, removeNamedItem: function (u) { var e = this.getNamedItem(u); return Yu(this._ownerElement, this, e), e }, removeNamedItemNS: function (u, e) { var r = this.getNamedItemNS(u, e); return Yu(this._ownerElement, this, r), r }, getNamedItemNS: function (u, e) { for (var r = this.length; r--;) { var t = this[r]; if (t.localName == e && t.namespaceURI == u) return t } return null } }; function ie () { } a(ie, "DOMImplementation"); ie.prototype = { hasFeature: function (u, e) { return !0 }, createDocument: function (u, e, r) { var t = new ru; if (t.implementation = this, t.childNodes = new I, t.doctype = r || null, r && t.appendChild(r), e) { var n = t.createElementNS(u, e); t.appendChild(n) } return t }, createDocumentType: function (u, e, r) { var t = new Au; return t.name = u, t.nodeName = u, t.publicId = e || "", t.systemId = r || "", t } }; function D () { } a(D, "Node"); D.prototype = { firstChild: null, lastChild: null, previousSibling: null, nextSibling: null, attributes: null, parentNode: null, childNodes: null, ownerDocument: null, nodeValue: null, namespaceURI: null, prefix: null, localName: null, insertBefore: function (u, e) { return Du(this, u, e) }, replaceChild: function (u, e) { Du(this, u, e, ce), e && this.removeChild(e) }, removeChild: function (u) { return le(this, u) }, appendChild: function (u) { return this.insertBefore(u, null) }, hasChildNodes: function () { return this.firstChild != null }, cloneNode: function (u) { return Bu(this.ownerDocument || this, this, u) }, normalize: function () { for (var u = this.firstChild; u;) { var e = u.nextSibling; e && e.nodeType == cu && u.nodeType == cu ? (this.removeChild(e), u.appendData(e.data)) : (u.normalize(), u = e) } }, isSupported: function (u, e) { return this.ownerDocument.implementation.hasFeature(u, e) }, hasAttributes: function () { return this.attributes.length > 0 }, lookupPrefix: function (u) { for (var e = this; e;) { var r = e._nsMap; if (r) { for (var t in r) if (Object.prototype.hasOwnProperty.call(r, t) && r[t] === u) return t } e = e.nodeType == H ? e.ownerDocument : e.parentNode } return null }, lookupNamespaceURI: function (u) { for (var e = this; e;) { var r = e._nsMap; if (r && Object.prototype.hasOwnProperty.call(r, u)) return r[u]; e = e.nodeType == H ? e.ownerDocument : e.parentNode } return null }, isDefaultNamespace: function (u) { var e = this.lookupPrefix(u); return e == null } }; function oe (u) { return u == "<" && "&lt;" || u == ">" && "&gt;" || u == "&" && "&amp;" || u == '"' && "&quot;" || "&#" + u.charCodeAt() + ";" } a(oe, "_xmlEncoder"); eu(F, D); eu(F, D.prototype); function uu (u, e) { if (e(u)) return !0; if (u = u.firstChild) do if (uu(u, e)) return !0; while (u = u.nextSibling) } a(uu, "_visitNode"); function ru () { this.ownerDocument = this } a(ru, "Document"); function Ye (u, e, r) { u && u._inc++; var t = r.namespaceURI; t === K.XMLNS && (e._nsMap[r.prefix ? r.localName : ""] = r.value) } a(Ye, "_onAddAttribute"); function se (u, e, r, t) { u && u._inc++; var n = r.namespaceURI; n === K.XMLNS && delete e._nsMap[r.prefix ? r.localName : ""] } a(se, "_onRemoveAttribute"); function Tu (u, e, r) { if (u && u._inc) { u._inc++; var t = e.childNodes; if (r) t[t.length++] = r; else { for (var n = e.firstChild, i = 0; n;)t[i++] = n, n = n.nextSibling; t.length = i, delete t[t.length] } } } a(Tu, "_onUpdateChild"); function le (u, e) { var r = e.previousSibling, t = e.nextSibling; return r ? r.nextSibling = t : u.firstChild = t, t ? t.previousSibling = r : u.lastChild = r, e.parentNode = null, e.previousSibling = null, e.nextSibling = null, Tu(u.ownerDocument, u), e } a(le, "_removeChild"); function $e (u) { return u && (u.nodeType === D.DOCUMENT_NODE || u.nodeType === D.DOCUMENT_FRAGMENT_NODE || u.nodeType === D.ELEMENT_NODE) } a($e, "hasValidParentNodeType"); function Ze (u) { return u && (_(u) || Fu(u) || k(u) || u.nodeType === D.DOCUMENT_FRAGMENT_NODE || u.nodeType === D.COMMENT_NODE || u.nodeType === D.PROCESSING_INSTRUCTION_NODE) } a(Ze, "hasInsertableNodeType"); function k (u) { return u && u.nodeType === D.DOCUMENT_TYPE_NODE } a(k, "isDocTypeNode"); function _ (u) { return u && u.nodeType === D.ELEMENT_NODE } a(_, "isElementNode"); function Fu (u) { return u && u.nodeType === D.TEXT_NODE } a(Fu, "isTextNode"); function $u (u, e) { var r = u.childNodes || []; if (O(r, _) || k(e)) return !1; var t = O(r, k); return !(e && t && r.indexOf(t) > r.indexOf(e)) } a($u, "isElementInsertionPossible"); function Zu (u, e) { var r = u.childNodes || []; function t (i) { return _(i) && i !== e } if (a(t, "hasElementChildThatIsNotChild"), O(r, t)) return !1; var n = O(r, k); return !(e && n && r.indexOf(n) > r.indexOf(e)) } a(Zu, "isElementReplacementPossible"); function We (u, e, r) { if (!$e(u)) throw new d(y, "Unexpected parent node type " + u.nodeType); if (r && r.parentNode !== u) throw new d(ne, "child not in parent"); if (!Ze(e) || k(e) && u.nodeType !== D.DOCUMENT_NODE) throw new d(y, "Unexpected node type " + e.nodeType + " for parent node type " + u.nodeType) } a(We, "assertPreInsertionValidity1to5"); function Qe (u, e, r) { var t = u.childNodes || [], n = e.childNodes || []; if (e.nodeType === D.DOCUMENT_FRAGMENT_NODE) { var i = n.filter(_); if (i.length > 1 || O(n, Fu)) throw new d(y, "More than one element or text in fragment"); if (i.length === 1 && !$u(u, r)) throw new d(y, "Element in fragment can not be inserted before doctype") } if (_(e) && !$u(u, r)) throw new d(y, "Only one element can be added and only after doctype"); if (k(e)) { if (O(t, k)) throw new d(y, "Only one doctype is allowed"); var o = O(t, _); if (r && t.indexOf(o) < t.indexOf(r)) throw new d(y, "Doctype can only be inserted before an element"); if (!r && o) throw new d(y, "Doctype can not be appended since element is present") } } a(Qe, "assertPreInsertionValidityInDocument"); function ce (u, e, r) { var t = u.childNodes || [], n = e.childNodes || []; if (e.nodeType === D.DOCUMENT_FRAGMENT_NODE) { var i = n.filter(_); if (i.length > 1 || O(n, Fu)) throw new d(y, "More than one element or text in fragment"); if (i.length === 1 && !Zu(u, r)) throw new d(y, "Element in fragment can not be inserted before doctype") } if (_(e) && !Zu(u, r)) throw new d(y, "Only one element can be added and only after doctype"); if (k(e)) { let s = function (c) { return k(c) && c !== r }; var l = s; if (a(s, "hasDoctypeChildThatIsNotChild"), O(t, s)) throw new d(y, "Only one doctype is allowed"); var o = O(t, _); if (r && t.indexOf(o) < t.indexOf(r)) throw new d(y, "Doctype can only be inserted before an element") } } a(ce, "assertPreReplacementValidityInDocument"); function Du (u, e, r, t) { We(u, e, r), u.nodeType === D.DOCUMENT_NODE && (t || Qe)(u, e, r); var n = e.parentNode; if (n && n.removeChild(e), e.nodeType === L) { var i = e.firstChild; if (i == null) return e; var o = e.lastChild } else i = o = e; var l = r ? r.previousSibling : u.lastChild; i.previousSibling = l, o.nextSibling = r, l ? l.nextSibling = i : u.firstChild = i, r == null ? u.lastChild = o : r.previousSibling = o; do i.parentNode = u; while (i !== o && (i = i.nextSibling)); return Tu(u.ownerDocument || u, u), e.nodeType == L && (e.firstChild = e.lastChild = null), e } a(Du, "_insertBefore"); function Je (u, e) { return e.parentNode && e.parentNode.removeChild(e), e.parentNode = u, e.previousSibling = u.lastChild, e.nextSibling = null, e.previousSibling ? e.previousSibling.nextSibling = e : u.firstChild = e, u.lastChild = e, Tu(u.ownerDocument, u, e), e } a(Je, "_appendSingleChild"); ru.prototype = { nodeName: "#document", nodeType: re, doctype: null, documentElement: null, _inc: 1, insertBefore: function (u, e) { if (u.nodeType == L) { for (var r = u.firstChild; r;) { var t = r.nextSibling; this.insertBefore(r, e), r = t } return u } return Du(this, u, e), u.ownerDocument = this, this.documentElement === null && u.nodeType === R && (this.documentElement = u), u }, removeChild: function (u) { return this.documentElement == u && (this.documentElement = null), le(this, u) }, replaceChild: function (u, e) { Du(this, u, e, ce), u.ownerDocument = this, e && this.removeChild(e), _(u) && (this.documentElement = u) }, importNode: function (u, e) { return he(this, u, e) }, getElementById: function (u) { var e = null; return uu(this.documentElement, function (r) { if (r.nodeType == R && r.getAttribute("id") == u) return e = r, !0 }), e }, getElementsByClassName: function (u) { var e = Hu(u); return new j(this, function (r) { var t = []; return e.length > 0 && uu(r.documentElement, function (n) { if (n !== r && n.nodeType === R) { var i = n.getAttribute("class"); if (i) { var o = u === i; if (!o) { var l = Hu(i); o = e.every(He(l)) } o && t.push(n) } } }), t }) }, createElement: function (u) { var e = new P; e.ownerDocument = this, e.nodeName = u, e.tagName = u, e.localName = u, e.childNodes = new I; var r = e.attributes = new pu; return r._ownerElement = e, e }, createDocumentFragment: function () { var u = new hu; return u.ownerDocument = this, u.childNodes = new I, u }, createTextNode: function (u) { var e = new Su; return e.ownerDocument = this, e.appendData(u), e }, createComment: function (u) { var e = new qu; return e.ownerDocument = this, e.appendData(u), e }, createCDATASection: function (u) { var e = new xu; return e.ownerDocument = this, e.appendData(u), e }, createProcessingInstruction: function (u, e) { var r = new Ou; return r.ownerDocument = this, r.tagName = r.nodeName = r.target = u, r.nodeValue = r.data = e, r }, createAttribute: function (u) { var e = new fu; return e.ownerDocument = this, e.name = u, e.nodeName = u, e.localName = u, e.specified = !0, e }, createEntityReference: function (u) { var e = new Ru; return e.ownerDocument = this, e.nodeName = u, e }, createElementNS: function (u, e) { var r = new P, t = e.split(":"), n = r.attributes = new pu; return r.childNodes = new I, r.ownerDocument = this, r.nodeName = e, r.tagName = e, r.namespaceURI = u, t.length == 2 ? (r.prefix = t[0], r.localName = t[1]) : r.localName = e, n._ownerElement = r, r }, createAttributeNS: function (u, e) { var r = new fu, t = e.split(":"); return r.ownerDocument = this, r.nodeName = e, r.name = e, r.namespaceURI = u, r.specified = !0, t.length == 2 ? (r.prefix = t[0], r.localName = t[1]) : r.localName = e, r } }; T(ru, D); function P () { this._nsMap = {} } a(P, "Element"); P.prototype = { nodeType: R, hasAttribute: function (u) { return this.getAttributeNode(u) != null }, getAttribute: function (u) { var e = this.getAttributeNode(u); return e && e.value || "" }, getAttributeNode: function (u) { return this.attributes.getNamedItem(u) }, setAttribute: function (u, e) { var r = this.ownerDocument.createAttribute(u); r.value = r.nodeValue = "" + e, this.setAttributeNode(r) }, removeAttribute: function (u) { var e = this.getAttributeNode(u); e && this.removeAttributeNode(e) }, appendChild: function (u) { return u.nodeType === L ? this.insertBefore(u, null) : Je(this, u) }, setAttributeNode: function (u) { return this.attributes.setNamedItem(u) }, setAttributeNodeNS: function (u) { return this.attributes.setNamedItemNS(u) }, removeAttributeNode: function (u) { return this.attributes.removeNamedItem(u.nodeName) }, removeAttributeNS: function (u, e) { var r = this.getAttributeNodeNS(u, e); r && this.removeAttributeNode(r) }, hasAttributeNS: function (u, e) { return this.getAttributeNodeNS(u, e) != null }, getAttributeNS: function (u, e) { var r = this.getAttributeNodeNS(u, e); return r && r.value || "" }, setAttributeNS: function (u, e, r) { var t = this.ownerDocument.createAttributeNS(u, e); t.value = t.nodeValue = "" + r, this.setAttributeNode(t) }, getAttributeNodeNS: function (u, e) { return this.attributes.getNamedItemNS(u, e) }, getElementsByTagName: function (u) { return new j(this, function (e) { var r = []; return uu(e, function (t) { t !== e && t.nodeType == R && (u === "*" || t.tagName == u) && r.push(t) }), r }) }, getElementsByTagNameNS: function (u, e) { return new j(this, function (r) { var t = []; return uu(r, function (n) { n !== r && n.nodeType === R && (u === "*" || n.namespaceURI === u) && (e === "*" || n.localName == e) && t.push(n) }), t }) } }; ru.prototype.getElementsByTagName = P.prototype.getElementsByTagName; ru.prototype.getElementsByTagNameNS = P.prototype.getElementsByTagNameNS; T(P, D); function fu () { } a(fu, "Attr"); fu.prototype.nodeType = H; T(fu, D); function tu () { } a(tu, "CharacterData"); tu.prototype = { data: "", substringData: function (u, e) { return this.data.substring(u, u + e) }, appendData: function (u) { u = this.data + u, this.nodeValue = this.data = u, this.length = u.length }, insertData: function (u, e) { this.replaceData(u, 0, e) }, appendChild: function (u) { throw new Error(b[y]) }, deleteData: function (u, e) { this.replaceData(u, e, "") }, replaceData: function (u, e, r) { var t = this.data.substring(0, u), n = this.data.substring(u + e); r = t + r + n, this.nodeValue = this.data = r, this.length = r.length } }; T(tu, D); function Su () { } a(Su, "Text"); Su.prototype = { nodeName: "#text", nodeType: cu, splitText: function (u) { var e = this.data, r = e.substring(u); e = e.substring(0, u), this.data = this.nodeValue = e, this.length = e.length; var t = this.ownerDocument.createTextNode(r); return this.parentNode && this.parentNode.insertBefore(t, this.nextSibling), t } }; T(Su, tu); function qu () { } a(qu, "Comment"); qu.prototype = { nodeName: "#comment", nodeType: ee }; T(qu, tu); function xu () { } a(xu, "CDATASection"); xu.prototype = { nodeName: "#cdata-section", nodeType: Ju }; T(xu, tu); function Au () { } a(Au, "DocumentType"); Au.prototype.nodeType = te; T(Au, D); function pe () { } a(pe, "Notation"); pe.prototype.nodeType = Xe; T(pe, D); function De () { } a(De, "Entity"); De.prototype.nodeType = je; T(De, D); function Ru () { } a(Ru, "EntityReference"); Ru.prototype.nodeType = Ku; T(Ru, D); function hu () { } a(hu, "DocumentFragment"); hu.prototype.nodeName = "#document-fragment"; hu.prototype.nodeType = L; T(hu, D); function Ou () { } a(Ou, "ProcessingInstruction"); Ou.prototype.nodeType = ue; T(Ou, D); function fe () { } a(fe, "XMLSerializer"); fe.prototype.serializeToString = function (u, e, r) { return Ae.call(u, e, r) }; D.prototype.toString = Ae; function Ae (u, e) { var r = [], t = this.nodeType == 9 && this.documentElement || this, n = t.prefix, i = t.namespaceURI; if (i && n == null) { var n = t.lookupPrefix(i); if (n == null) var o = [{ namespace: i, prefix: null }] } return z(this, r, u, e, o), r.join("") } a(Ae, "nodeSerializeToString"); function Wu (u, e, r) { var t = u.prefix || "", n = u.namespaceURI; if (!n || t === "xml" && n === K.XML || n === K.XMLNS) return !1; for (var i = r.length; i--;) { var o = r[i]; if (o.prefix === t) return o.namespace !== n } return !0 } a(Wu, "needNamespaceDefine"); function Nu (u, e, r) { u.push(" ", e, '="', r.replace(/[<>&"\t\n\r]/g, oe), '"') } a(Nu, "addSerializedAttribute"); function z (u, e, r, t, n) { if (n || (n = []), t) if (u = t(u), u) { if (typeof u == "string") { e.push(u); return } } else return; switch (u.nodeType) { case R: var i = u.attributes, o = i.length, C = u.firstChild, l = u.tagName; r = K.isHTML(u.namespaceURI) || r; var s = l; if (!r && !u.prefix && u.namespaceURI) { for (var c, p = 0; p < i.length; p++)if (i.item(p).name === "xmlns") { c = i.item(p).value; break } if (!c) for (var A = n.length - 1; A >= 0; A--) { var f = n[A]; if (f.prefix === "" && f.namespace === u.namespaceURI) { c = f.namespace; break } } if (c !== u.namespaceURI) for (var A = n.length - 1; A >= 0; A--) { var f = n[A]; if (f.namespace === u.namespaceURI) { f.prefix && (s = f.prefix + ":" + l); break } } } e.push("<", s); for (var E = 0; E < o; E++) { var B = i.item(E); B.prefix == "xmlns" ? n.push({ prefix: B.localName, namespace: B.value }) : B.nodeName == "xmlns" && n.push({ prefix: "", namespace: B.value }) } for (var E = 0; E < o; E++) { var B = i.item(E); if (Wu(B, r, n)) { var h = B.prefix || "", m = B.namespaceURI; Nu(e, h ? "xmlns:" + h : "xmlns", m), n.push({ prefix: h, namespace: m }) } z(B, e, r, t, n) } if (l === s && Wu(u, r, n)) { var h = u.prefix || "", m = u.namespaceURI; Nu(e, h ? "xmlns:" + h : "xmlns", m), n.push({ prefix: h, namespace: m }) } if (C || r && !/^(?:meta|link|img|br|hr|input)$/i.test(l)) { if (e.push(">"), r && /^script$/i.test(l)) for (; C;)C.data ? e.push(C.data) : z(C, e, r, t, n.slice()), C = C.nextSibling; else for (; C;)z(C, e, r, t, n.slice()), C = C.nextSibling; e.push("</", s, ">") } else e.push("/>"); return; case re: case L: for (var C = u.firstChild; C;)z(C, e, r, t, n.slice()), C = C.nextSibling; return; case H: return Nu(e, u.name, u.value); case cu: return e.push(u.data.replace(/[<&>]/g, oe)); case Ju: return e.push("<![CDATA[", u.data, "]]>"); case ee: return e.push("<\!--", u.data, "-->"); case te: var Q = u.publicId, v = u.systemId; if (e.push("<!DOCTYPE ", u.name), Q) e.push(" PUBLIC ", Q), v && v != "." && e.push(" ", v), e.push(">"); else if (v && v != ".") e.push(" SYSTEM ", v, ">"); else { var q = u.internalSubset; q && e.push(" [", q, "]"), e.push(">") } return; case ue: return e.push("<?", u.target, " ", u.data, "?>"); case Ku: return e.push("&", u.nodeName, ";"); default: e.push("??", u.nodeName) } } a(z, "serializeToString"); function he (u, e, r) { var t; switch (e.nodeType) { case R: t = e.cloneNode(!1), t.ownerDocument = u; case L: break; case H: r = !0; break }if (t || (t = e.cloneNode(!1)), t.ownerDocument = u, t.parentNode = null, r) for (var n = e.firstChild; n;)t.appendChild(he(u, n, r)), n = n.nextSibling; return t } a(he, "importNode"); function Bu (u, e, r) { var t = new e.constructor; for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) { var i = e[n]; typeof i != "object" && i != t[n] && (t[n] = i) } switch (e.childNodes && (t.childNodes = new I), t.ownerDocument = u, t.nodeType) { case R: var o = e.attributes, l = t.attributes = new pu, s = o.length; l._ownerElement = t; for (var c = 0; c < s; c++)t.setAttributeNode(Bu(u, o.item(c), !0)); break; case H: r = !0 }if (r) for (var p = e.firstChild; p;)t.appendChild(Bu(u, p, r)), p = p.nextSibling; return t } a(Bu, "cloneNode"); function me (u, e, r) { u[e] = r } a(me, "__set__"); try { if (Object.defineProperty) { let u = function (e) { switch (e.nodeType) { case R: case L: var r = []; for (e = e.firstChild; e;)e.nodeType !== 7 && e.nodeType !== 8 && r.push(u(e)), e = e.nextSibling; return r.join(""); default: return e.nodeValue } }; Fr = u, a(u, "getTextContent"), Object.defineProperty(j.prototype, "length", { get: function () { return yu(this), this.$$length } }), Object.defineProperty(D.prototype, "textContent", { get: function () { return u(this) }, set: function (e) { switch (this.nodeType) { case R: case L: for (; this.firstChild;)this.removeChild(this.firstChild); (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e)); break; default: this.data = e, this.value = e, this.nodeValue = e } } }), me = a(function (e, r, t) { e["$$" + r] = t }, "__set__") } } catch { } var Fr; M.DocumentType = Au; M.DOMException = d; M.DOMImplementation = ie; M.Element = P; M.Node = D; M.NodeList = I; M.XMLSerializer = fe }); var ge = V(nu => {
          "use strict"; var Ee = J().freeze; nu.XML_ENTITIES = Ee({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' }); nu.HTML_ENTITIES = Ee({
            Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", Gt: "\u226B", GT: ">", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", Lt: "\u226A", LT: "<", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C"
          }); nu.entityMap = nu.HTML_ENTITIES
        }); var ye = V(Lu => { var su = J().NAMESPACE, Iu = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, de = new RegExp("[\\-\\.0-9" + Iu.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), Ce = new RegExp("^" + Iu.source + de.source + "*(?::" + Iu.source + de.source + "*)?$"), au = 0, U = 1, X = 2, iu = 3, Y = 4, $ = 5, ou = 6, mu = 7; function Z (u, e) { this.message = u, this.locator = e, Error.captureStackTrace && Error.captureStackTrace(this, Z) } a(Z, "ParseError"); Z.prototype = new Error; Z.prototype.name = Z.name; function we () { } a(we, "XMLReader"); we.prototype = { parse: function (u, e, r) { var t = this.domBuilder; t.startDocument(), Ne(e, e = {}), Ke(u, e, r, t, this.errorHandler), t.endDocument() } }; function Ke (u, e, r, t, n) { function i (g) { if (g > 65535) { g -= 65536; var x = 55296 + (g >> 10), ke = 56320 + (g & 1023); return String.fromCharCode(x, ke) } else return String.fromCharCode(g) } a(i, "fixedFromCharCode"); function o (g) { var x = g.slice(1, -1); return Object.hasOwnProperty.call(r, x) ? r[x] : x.charAt(0) === "#" ? i(parseInt(x.substr(1).replace("x", "0x"))) : (n.error("entity not found:" + g), g) } a(o, "entityReplacer"); function l (g) { if (g > h) { var x = u.substring(h, g).replace(/&#?\w+;/g, o); f && s(h), t.characters(x, 0, g - h), h = g } } a(l, "appendText"); function s (g, x) { for (; g >= p && (x = A.exec(u));)c = x.index, p = c + x[0].length, f.lineNumber++; f.columnNumber = g - c + 1 } a(s, "position"); for (var c = 0, p = 0, A = /.*(?:\r\n?|\n)|.*$/g, f = t.locator, E = [{ currentNSMap: e }], B = {}, h = 0; ;) { try { var m = u.indexOf("<", h); if (m < 0) { if (!u.substr(h).match(/^\s*$/)) { var C = t.doc, Q = C.createTextNode(u.substr(h)); C.appendChild(Q), t.currentElement = Q } return } switch (m > h && l(m), u.charAt(m + 1)) { case "/": var N = u.indexOf(">", m + 3), v = u.substring(m + 2, N).replace(/[ \t\n\r]+$/g, ""), q = E.pop(); N < 0 ? (v = u.substring(m + 2).replace(/[\s<].*/, ""), n.error("end tag name: " + v + " is not complete:" + q.tagName), N = m + 1 + v.length) : v.match(/\s</) && (v = v.replace(/[\s<].*/, ""), n.error("end tag name: " + v + " maybe not complete"), N = m + 1 + v.length); var Cu = q.localNSMap, Mu = q.tagName == v, Ie = Mu || q.tagName && q.tagName.toLowerCase() == v.toLowerCase(); if (Ie) { if (t.endElement(q.uri, q.localName, v), Cu) for (var Uu in Cu) Object.prototype.hasOwnProperty.call(Cu, Uu) && t.endPrefixMapping(Uu); Mu || n.fatalError("end tag name: " + v + " is not match the current start tagName:" + q.tagName) } else E.push(q); N++; break; case "?": f && s(m), N = nr(u, m, t); break; case "!": f && s(m), N = tr(u, m, t, n); break; default: f && s(m); var S = new Be, vu = E[E.length - 1].currentNSMap, N = ur(u, m, S, vu, o, n), Pu = S.length; if (!S.closed && rr(u, N, S.tagName, B) && (S.closed = !0, r.nbsp || n.warning("unclosed xml attribute")), f && Pu) { for (var Le = ve(f, {}), bu = 0; bu < Pu; bu++) { var Vu = S[bu]; s(Vu.offset), Vu.locator = ve(f, {}) } t.locator = Le, be(S, t, vu) && E.push(S), t.locator = f } else be(S, t, vu) && E.push(S); su.isHTML(S.uri) && !S.closed ? N = er(u, N, S.tagName, o, t) : N++ } } catch (g) { if (g instanceof Z) throw g; n.error("element parse error: " + g), N = -1 } N > h ? h = N : l(Math.max(m, h) + 1) } } a(Ke, "parse"); function ve (u, e) { return e.lineNumber = u.lineNumber, e.columnNumber = u.columnNumber, e } a(ve, "copyLocator"); function ur (u, e, r, t, n, i) { function o (E, B, h) { r.attributeNames.hasOwnProperty(E) && i.fatalError("Attribute " + E + " redefined"), r.addValue(E, B.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, n), h) } a(o, "addAttribute"); for (var l, s, c = ++e, p = au; ;) { var A = u.charAt(c); switch (A) { case "=": if (p === U) l = u.slice(e, c), p = iu; else if (p === X) p = iu; else throw new Error("attribute equal must after attrName"); break; case "'": case '"': if (p === iu || p === U) if (p === U && (i.warning('attribute value must after "="'), l = u.slice(e, c)), e = c + 1, c = u.indexOf(A, e), c > 0) s = u.slice(e, c), o(l, s, e - 1), p = $; else throw new Error("attribute value no end '" + A + "' match"); else if (p == Y) s = u.slice(e, c), o(l, s, e), i.warning('attribute "' + l + '" missed start quot(' + A + ")!!"), e = c + 1, p = $; else throw new Error('attribute value must after "="'); break; case "/": switch (p) { case au: r.setTagName(u.slice(e, c)); case $: case ou: case mu: p = mu, r.closed = !0; case Y: case U: break; case X: r.closed = !0; break; default: throw new Error("attribute invalid close char('/')") }break; case "": return i.error("unexpected end of input"), p == au && r.setTagName(u.slice(e, c)), c; case ">": switch (p) { case au: r.setTagName(u.slice(e, c)); case $: case ou: case mu: break; case Y: case U: s = u.slice(e, c), s.slice(-1) === "/" && (r.closed = !0, s = s.slice(0, -1)); case X: p === X && (s = l), p == Y ? (i.warning('attribute "' + s + '" missed quot(")!'), o(l, s, e)) : ((!su.isHTML(t[""]) || !s.match(/^(?:disabled|checked|selected)$/i)) && i.warning('attribute "' + s + '" missed value!! "' + s + '" instead!!'), o(s, s, e)); break; case iu: throw new Error("attribute value missed!!") }return c; case "\x80": A = " "; default: if (A <= " ") switch (p) { case au: r.setTagName(u.slice(e, c)), p = ou; break; case U: l = u.slice(e, c), p = X; break; case Y: var s = u.slice(e, c); i.warning('attribute "' + s + '" missed quot(")!!'), o(l, s, e); case $: p = ou; break } else switch (p) { case X: var f = r.tagName; (!su.isHTML(t[""]) || !l.match(/^(?:disabled|checked|selected)$/i)) && i.warning('attribute "' + l + '" missed value!! "' + l + '" instead2!!'), o(l, l, e), e = c, p = U; break; case $: i.warning('attribute space is required"' + l + '"!!'); case ou: p = U, e = c; break; case iu: p = Y, e = c; break; case mu: throw new Error("elements closed character '/' and '>' must be connected to") } }c++ } } a(ur, "parseElementStartPart"); function be (u, e, r) { for (var t = u.tagName, n = null, A = u.length; A--;) { var i = u[A], o = i.qName, l = i.value, f = o.indexOf(":"); if (f > 0) var s = i.prefix = o.slice(0, f), c = o.slice(f + 1), p = s === "xmlns" && c; else c = o, s = null, p = o === "xmlns" && ""; i.localName = c, p !== !1 && (n == null && (n = {}, Ne(r, r = {})), r[p] = n[p] = l, i.uri = su.XMLNS, e.startPrefixMapping(p, l)) } for (var A = u.length; A--;) { i = u[A]; var s = i.prefix; s && (s === "xml" && (i.uri = su.XML), s !== "xmlns" && (i.uri = r[s || ""])) } var f = t.indexOf(":"); f > 0 ? (s = u.prefix = t.slice(0, f), c = u.localName = t.slice(f + 1)) : (s = null, c = u.localName = t); var E = u.uri = r[s || ""]; if (e.startElement(E, c, t, u), u.closed) { if (e.endElement(E, c, t), n) for (s in n) Object.prototype.hasOwnProperty.call(n, s) && e.endPrefixMapping(s) } else return u.currentNSMap = r, u.localNSMap = n, !0 } a(be, "appendElement"); function er (u, e, r, t, n) { if (/^(?:script|textarea)$/i.test(r)) { var i = u.indexOf("</" + r + ">", e), o = u.substring(e + 1, i); if (/[&<]/.test(o)) return /^script$/i.test(r) ? (n.characters(o, 0, o.length), i) : (o = o.replace(/&#?\w+;/g, t), n.characters(o, 0, o.length), i) } return e + 1 } a(er, "parseHtmlSpecialContent"); function rr (u, e, r, t) { var n = t[r]; return n == null && (n = u.lastIndexOf("</" + r + ">"), n < e && (n = u.lastIndexOf("</" + r)), t[r] = n), n < e } a(rr, "fixSelfClosed"); function Ne (u, e) { for (var r in u) Object.prototype.hasOwnProperty.call(u, r) && (e[r] = u[r]) } a(Ne, "_copy"); function tr (u, e, r, t) { var n = u.charAt(e + 2); switch (n) { case "-": if (u.charAt(e + 3) === "-") { var i = u.indexOf("-->", e + 4); return i > e ? (r.comment(u, e + 4, i - e - 4), i + 3) : (t.error("Unclosed comment"), -1) } else return -1; default: if (u.substr(e + 3, 6) == "CDATA[") { var i = u.indexOf("]]>", e + 9); return r.startCDATA(), r.characters(u, e + 9, i - e - 9), r.endCDATA(), i + 3 } var o = ar(u, e), l = o.length; if (l > 1 && /!doctype/i.test(o[0][0])) { var s = o[1][0], c = !1, p = !1; l > 3 && (/^public$/i.test(o[2][0]) ? (c = o[3][0], p = l > 4 && o[4][0]) : /^system$/i.test(o[2][0]) && (p = o[3][0])); var A = o[l - 1]; return r.startDTD(s, c, p), r.endDTD(), A.index + A[0].length } }return -1 } a(tr, "parseDCC"); function nr (u, e, r) { var t = u.indexOf("?>", e); if (t) { var n = u.substring(e, t).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/); if (n) { var i = n[0].length; return r.processingInstruction(n[1], n[2]), t + 2 } else return -1 } return -1 } a(nr, "parseInstruction"); function Be () { this.attributeNames = {} } a(Be, "ElementAttributes"); Be.prototype = { setTagName: function (u) { if (!Ce.test(u)) throw new Error("invalid tagName:" + u); this.tagName = u }, addValue: function (u, e, r) { if (!Ce.test(u)) throw new Error("invalid attribute:" + u); this.attributeNames[u] = this.length, this[this.length++] = { qName: u, value: e, offset: r } }, length: 0, getLocalName: function (u) { return this[u].localName }, getLocator: function (u) { return this[u].locator }, getQName: function (u) { return this[u].qName }, getURI: function (u) { return this[u].uri }, getValue: function (u) { return this[u].value } }; function ar (u, e) { var r, t = [], n = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g; for (n.lastIndex = e, n.exec(u); r = n.exec(u);)if (t.push(r), r[1]) return t } a(ar, "split"); Lu.XMLReader = we; Lu.ParseError = Z }); var Oe = V(gu => {
          var ir = J(), or = _u(), Te = ge(), qe = ye(), sr = or.DOMImplementation, Fe = ir.NAMESPACE, lr = qe.ParseError, cr = qe.XMLReader; function xe (u) {
            return u.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`)
          } a(xe, "normalizeLineEndings"); function Re (u) { this.options = u || { locator: {} } } a(Re, "DOMParser"); Re.prototype.parseFromString = function (u, e) { var r = this.options, t = new cr, n = r.domBuilder || new lu, i = r.errorHandler, o = r.locator, l = r.xmlns || {}, s = /\/x?html?$/.test(e), c = s ? Te.HTML_ENTITIES : Te.XML_ENTITIES; o && n.setDocumentLocator(o), t.errorHandler = pr(i, n, o), t.domBuilder = r.domBuilder || n, s && (l[""] = Fe.HTML), l.xml = l.xml || Fe.XML; var p = r.normalizeLineEndings || xe; return u && typeof u == "string" ? t.parse(p(u), l, c) : t.errorHandler.error("invalid doc source"), n.doc }; function pr (u, e, r) { if (!u) { if (e instanceof lu) return e; u = e } var t = {}, n = u instanceof Function; r = r || {}; function i (o) { var l = u[o]; !l && n && (l = u.length == 2 ? function (s) { u(o, s) } : u), t[o] = l && function (s) { l("[xmldom " + o + "]	" + s + ku(r)) } || function () { } } return a(i, "build"), i("warning"), i("error"), i("fatalError"), t } a(pr, "buildErrorHandler"); function lu () { this.cdata = !1 } a(lu, "DOMHandler"); function W (u, e) { e.lineNumber = u.lineNumber, e.columnNumber = u.columnNumber } a(W, "position"); lu.prototype = { startDocument: function () { this.doc = new sr().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId) }, startElement: function (u, e, r, t) { var n = this.doc, i = n.createElementNS(u, r || e), o = t.length; Eu(this, i), this.currentElement = i, this.locator && W(this.locator, i); for (var l = 0; l < o; l++) { var u = t.getURI(l), s = t.getValue(l), r = t.getQName(l), c = n.createAttributeNS(u, r); this.locator && W(t.getLocator(l), c), c.value = c.nodeValue = s, i.setAttributeNode(c) } }, endElement: function (u, e, r) { var t = this.currentElement, n = t.tagName; this.currentElement = t.parentNode }, startPrefixMapping: function (u, e) { }, endPrefixMapping: function (u) { }, processingInstruction: function (u, e) { var r = this.doc.createProcessingInstruction(u, e); this.locator && W(this.locator, r), Eu(this, r) }, ignorableWhitespace: function (u, e, r) { }, characters: function (u, e, r) { if (u = Se.apply(this, arguments), u) { if (this.cdata) var t = this.doc.createCDATASection(u); else var t = this.doc.createTextNode(u); this.currentElement ? this.currentElement.appendChild(t) : /^\s*$/.test(u) && this.doc.appendChild(t), this.locator && W(this.locator, t) } }, skippedEntity: function (u) { }, endDocument: function () { this.doc.normalize() }, setDocumentLocator: function (u) { (this.locator = u) && (u.lineNumber = 0) }, comment: function (u, e, r) { u = Se.apply(this, arguments); var t = this.doc.createComment(u); this.locator && W(this.locator, t), Eu(this, t) }, startCDATA: function () { this.cdata = !0 }, endCDATA: function () { this.cdata = !1 }, startDTD: function (u, e, r) { var t = this.doc.implementation; if (t && t.createDocumentType) { var n = t.createDocumentType(u, e, r); this.locator && W(this.locator, n), Eu(this, n), this.doc.doctype = n } }, warning: function (u) { console.warn("[xmldom warning]	" + u, ku(this.locator)) }, error: function (u) { console.error("[xmldom error]	" + u, ku(this.locator)) }, fatalError: function (u) { throw new lr(u, this.locator) } }; function ku (u) {
            if (u) return `
@`+ (u.systemId || "") + "#[line:" + u.lineNumber + ",col:" + u.columnNumber + "]"
          } a(ku, "_locator"); function Se (u, e, r) { return typeof u == "string" ? u.substr(e, r) : u.length >= e + r || e ? new java.lang.String(u, e, r) + "" : u } a(Se, "_toString"); "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (u) { lu.prototype[u] = function () { return null } }); function Eu (u, e) { u.currentElement ? u.currentElement.appendChild(e) : u.doc.appendChild(e) } a(Eu, "appendElement"); gu.__DOMHandler = lu; gu.normalizeLineEndings = xe; gu.DOMParser = Re
        }); var Dr = V(du => { var _e = _u(); du.DOMImplementation = _e.DOMImplementation; du.XMLSerializer = _e.XMLSerializer; du.DOMParser = Oe().DOMParser }); return Dr();
      })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/pixi.js?_v=8.1.1&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/pixi.js?_v=8.1.1&_env=prod'] = (window) => {
      var __dependency__ = (() => {
        var K0 = Object.create; var Dc = Object.defineProperty; var q0 = Object.getOwnPropertyDescriptor; var Z0 = Object.getOwnPropertyNames; var Q0 = Object.getPrototypeOf, J0 = Object.prototype.hasOwnProperty; var c = (r, t) => Dc(r, "name", { value: t, configurable: !0 }), Tt = (r => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(r, { get: (t, e) => (typeof require < "u" ? require : t)[e] }) : r)(function (r) { if (typeof require < "u") return require.apply(this, arguments); throw new Error('Dynamic require of "' + r + '" is not supported') }); var m = (r, t) => () => (r && (t = r(r = 0)), t); var c_ = (r, t) => { for (var e in t) Dc(r, e, { get: t[e], enumerable: !0 }) }, by = (r, t, e, s) => { if (t && typeof t == "object" || typeof t == "function") for (let o of Z0(t)) !J0.call(r, o) && o !== e && Dc(r, o, { get: () => t[o], enumerable: !(s = q0(t, o)) || s.enumerable }); return r }; var Ct = (r, t, e) => (e = r != null ? K0(Q0(r)) : {}, by(t || !r || !r.__esModule ? Dc(e, "default", { value: r, enumerable: !0 }) : e, r)), tS = r => by(Dc({}, "__esModule", { value: !0 }), r); var x, l_, xi, I, S = m(() => { "use strict"; x = (r => (r.Application = "application", r.WebGLPipes = "webgl-pipes", r.WebGLPipesAdaptor = "webgl-pipes-adaptor", r.WebGLSystem = "webgl-system", r.WebGPUPipes = "webgpu-pipes", r.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", r.WebGPUSystem = "webgpu-system", r.CanvasSystem = "canvas-system", r.CanvasPipesAdaptor = "canvas-pipes-adaptor", r.CanvasPipes = "canvas-pipes", r.Asset = "asset", r.LoadParser = "load-parser", r.ResolveParser = "resolve-parser", r.CacheParser = "cache-parser", r.DetectionParser = "detection-parser", r.MaskEffect = "mask-effect", r.BlendMode = "blend-mode", r.TextureSource = "texture-source", r.Environment = "environment", r))(x || {}), l_ = c(r => { if (typeof r == "function" || typeof r == "object" && r.extension) { if (!r.extension) throw new Error("Extension class must have an extension object"); r = { ...typeof r.extension != "object" ? { type: r.extension } : r.extension, ref: r } } if (typeof r == "object") r = { ...r }; else throw new Error("Invalid extension type"); return typeof r.type == "string" && (r.type = [r.type]), r }, "normalizeExtension"), xi = c((r, t) => l_(r).priority ?? t, "normalizeExtensionPriority"), I = { _addHandlers: {}, _removeHandlers: {}, _queue: {}, remove (...r) { return r.map(l_).forEach(t => { t.type.forEach(e => this._removeHandlers[e]?.(t)) }), this }, add (...r) { return r.map(l_).forEach(t => { t.type.forEach(e => { let s = this._addHandlers, o = this._queue; s[e] ? s[e]?.(t) : (o[e] = o[e] || [], o[e]?.push(t)) }) }), this }, handle (r, t, e) { let s = this._addHandlers, o = this._removeHandlers; if (s[r] || o[r]) throw new Error(`Extension type ${r} already has a handler`); s[r] = t, o[r] = e; let i = this._queue; return i[r] && (i[r]?.forEach(n => t(n)), delete i[r]), this }, handleByMap (r, t) { return this.handle(r, e => { e.name && (t[e.name] = e.ref) }, e => { e.name && delete t[e.name] }) }, handleByNamedList (r, t, e = -1) { return this.handle(r, s => { t.findIndex(i => i.name === s.name) >= 0 || (t.push({ name: s.name, value: s.ref }), t.sort((i, n) => xi(n.value, e) - xi(i.value, e))) }, s => { let o = t.findIndex(i => i.name === s.name); o !== -1 && t.splice(o, 1) }) }, handleByList (r, t, e = -1) { return this.handle(r, s => { t.includes(s.ref) || (t.push(s.ref), t.sort((o, i) => xi(i, e) - xi(o, e))) }, s => { let o = t.indexOf(s.ref); o !== -1 && t.splice(o, 1) }) } } }); var xf, yy, na, j, $t = m(() => { xf = Tt("/node_modules/@pixi/colord?_v=2.9.6&_env=prod"), yy = Ct(Tt("/node_modules/@pixi/colord/plugins/names?_v=2.9.6&_env=prod"), 1); (0, xf.extend)([yy.default]); na = c(class Lc { constructor(t = 16777215) { this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t } get red () { return this._components[0] } get green () { return this._components[1] } get blue () { return this._components[2] } get alpha () { return this._components[3] } setValue (t) { return this.value = t, this } set value (t) { if (t instanceof Lc) this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components); else { if (t === null) throw new Error("Cannot set Color#value to null"); (this._value === null || !this._isSourceEqual(this._value, t)) && (this._normalize(t), this._value = this._cloneSource(t)) } } get value () { return this._value } _cloneSource (t) { return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? { ...t } : t } _isSourceEqual (t, e) { let s = typeof t; if (s !== typeof e) return !1; if (s === "number" || s === "string" || t instanceof Number) return t === e; if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) return t.length !== e.length ? !1 : t.every((i, n) => i === e[n]); if (t !== null && e !== null) { let i = Object.keys(t), n = Object.keys(e); return i.length !== n.length ? !1 : i.every(a => t[a] === e[a]) } return t === e } toRgba () { let [t, e, s, o] = this._components; return { r: t, g: e, b: s, a: o } } toRgb () { let [t, e, s] = this._components; return { r: t, g: e, b: s } } toRgbaString () { let [t, e, s] = this.toUint8RgbArray(); return `rgba(${t},${e},${s},${this.alpha})` } toUint8RgbArray (t) { let [e, s, o] = this._components; return this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb, t[0] = Math.round(e * 255), t[1] = Math.round(s * 255), t[2] = Math.round(o * 255), t } toArray (t) { this._arrayRgba || (this._arrayRgba = []), t = t || this._arrayRgba; let [e, s, o, i] = this._components; return t[0] = e, t[1] = s, t[2] = o, t[3] = i, t } toRgbArray (t) { this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb; let [e, s, o] = this._components; return t[0] = e, t[1] = s, t[2] = o, t } toNumber () { return this._int } toBgrNumber () { let [t, e, s] = this.toUint8RgbArray(); return (s << 16) + (e << 8) + t } toLittleEndianNumber () { let t = this._int; return (t >> 16) + (t & 65280) + ((t & 255) << 16) } multiply (t) { let [e, s, o, i] = Lc._temp.setValue(t)._components; return this._components[0] *= e, this._components[1] *= s, this._components[2] *= o, this._components[3] *= i, this._refreshInt(), this._value = null, this } premultiply (t, e = !0) { return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this } toPremultiplied (t, e = !0) { if (t === 1) return (255 << 24) + this._int; if (t === 0) return e ? 0 : this._int; let s = this._int >> 16 & 255, o = this._int >> 8 & 255, i = this._int & 255; return e && (s = s * t + .5 | 0, o = o * t + .5 | 0, i = i * t + .5 | 0), (t * 255 << 24) + (s << 16) + (o << 8) + i } toHex () { let t = this._int.toString(16); return `#${"000000".substring(0, 6 - t.length) + t}` } toHexa () { let e = Math.round(this._components[3] * 255).toString(16); return this.toHex() + "00".substring(0, 2 - e.length) + e } setAlpha (t) { return this._components[3] = this._clamp(t), this } _normalize (t) { let e, s, o, i; if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) { let n = t; e = (n >> 16 & 255) / 255, s = (n >> 8 & 255) / 255, o = (n & 255) / 255, i = 1 } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4) t = this._clamp(t), [e, s, o, i = 1] = t; else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4) t = this._clamp(t, 0, 255), [e, s, o, i = 255] = t, e /= 255, s /= 255, o /= 255, i /= 255; else if (typeof t == "string" || typeof t == "object") { if (typeof t == "string") { let a = Lc.HEX_PATTERN.exec(t); a && (t = `#${a[2]}`) } let n = (0, xf.colord)(t); n.isValid() && ({ r: e, g: s, b: o, a: i } = n.rgba, e /= 255, s /= 255, o /= 255) } if (e !== void 0) this._components[0] = e, this._components[1] = s, this._components[2] = o, this._components[3] = i, this._refreshInt(); else throw new Error(`Unable to convert color ${t}`) } _refreshInt () { this._clamp(this._components); let [t, e, s] = this._components; this._int = (t * 255 << 16) + (e * 255 << 8) + (s * 255 | 0) } _clamp (t, e = 0, s = 1) { return typeof t == "number" ? Math.min(Math.max(t, e), s) : (t.forEach((o, i) => { t[i] = Math.min(Math.max(o, e), s) }), t) } static isColorLike (t) { return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof Lc || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0 } }, "_Color"); na.shared = new na; na._temp = new na; na.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i; j = na }); var Hc, gf = m(() => { "use strict"; Hc = { cullArea: null, cullable: !1, cullableChildren: !0 } }); var Nc, Wc, Xc, zc = m(() => { "use strict"; Nc = Math.PI * 2, Wc = 180 / Math.PI, Xc = Math.PI / 180 }); var V, u_, ce = m(() => { "use strict"; V = class { constructor(t = 0, e = 0) { this.x = 0, this.y = 0, this.x = t, this.y = e } clone () { return new V(this.x, this.y) } copyFrom (t) { return this.set(t.x, t.y), this } copyTo (t) { return t.set(this.x, this.y), t } equals (t) { return t.x === this.x && t.y === this.y } set (t = 0, e = t) { return this.x = t, this.y = e, this } toString () { return `[pixi.js/math:Point x=${this.x} y=${this.y}]` } static get shared () { return u_.x = 0, u_.y = 0, u_ } }; c(V, "Point"); u_ = new V }); var B, eS, rS, ot = m(() => { zc(); ce(); B = class { constructor(t = 1, e = 0, s = 0, o = 1, i = 0, n = 0) { this.array = null, this.a = t, this.b = e, this.c = s, this.d = o, this.tx = i, this.ty = n } fromArray (t) { this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5] } set (t, e, s, o, i, n) { return this.a = t, this.b = e, this.c = s, this.d = o, this.tx = i, this.ty = n, this } toArray (t, e) { this.array || (this.array = new Float32Array(9)); let s = e || this.array; return t ? (s[0] = this.a, s[1] = this.b, s[2] = 0, s[3] = this.c, s[4] = this.d, s[5] = 0, s[6] = this.tx, s[7] = this.ty, s[8] = 1) : (s[0] = this.a, s[1] = this.c, s[2] = this.tx, s[3] = this.b, s[4] = this.d, s[5] = this.ty, s[6] = 0, s[7] = 0, s[8] = 1), s } apply (t, e) { e = e || new V; let s = t.x, o = t.y; return e.x = this.a * s + this.c * o + this.tx, e.y = this.b * s + this.d * o + this.ty, e } applyInverse (t, e) { e = e || new V; let s = this.a, o = this.b, i = this.c, n = this.d, a = this.tx, l = this.ty, h = 1 / (s * n + i * -o), u = t.x, d = t.y; return e.x = n * h * u + -i * h * d + (l * i - a * n) * h, e.y = s * h * d + -o * h * u + (-l * s + a * o) * h, e } translate (t, e) { return this.tx += t, this.ty += e, this } scale (t, e) { return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this } rotate (t) { let e = Math.cos(t), s = Math.sin(t), o = this.a, i = this.c, n = this.tx; return this.a = o * e - this.b * s, this.b = o * s + this.b * e, this.c = i * e - this.d * s, this.d = i * s + this.d * e, this.tx = n * e - this.ty * s, this.ty = n * s + this.ty * e, this } append (t) { let e = this.a, s = this.b, o = this.c, i = this.d; return this.a = t.a * e + t.b * o, this.b = t.a * s + t.b * i, this.c = t.c * e + t.d * o, this.d = t.c * s + t.d * i, this.tx = t.tx * e + t.ty * o + this.tx, this.ty = t.tx * s + t.ty * i + this.ty, this } appendFrom (t, e) { let s = t.a, o = t.b, i = t.c, n = t.d, a = t.tx, l = t.ty, h = e.a, u = e.b, d = e.c, f = e.d; return this.a = s * h + o * d, this.b = s * u + o * f, this.c = i * h + n * d, this.d = i * u + n * f, this.tx = a * h + l * d + e.tx, this.ty = a * u + l * f + e.ty, this } setTransform (t, e, s, o, i, n, a, l, h) { return this.a = Math.cos(a + h) * i, this.b = Math.sin(a + h) * i, this.c = -Math.sin(a - l) * n, this.d = Math.cos(a - l) * n, this.tx = t - (s * this.a + o * this.c), this.ty = e - (s * this.b + o * this.d), this } prepend (t) { let e = this.tx; if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) { let s = this.a, o = this.c; this.a = s * t.a + this.b * t.c, this.b = s * t.b + this.b * t.d, this.c = o * t.a + this.d * t.c, this.d = o * t.b + this.d * t.d } return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this } decompose (t) { let e = this.a, s = this.b, o = this.c, i = this.d, n = t.pivot, a = -Math.atan2(-o, i), l = Math.atan2(s, e), h = Math.abs(a + l); return h < 1e-5 || Math.abs(Nc - h) < 1e-5 ? (t.rotation = l, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = l), t.scale.x = Math.sqrt(e * e + s * s), t.scale.y = Math.sqrt(o * o + i * i), t.position.x = this.tx + (n.x * e + n.y * o), t.position.y = this.ty + (n.x * s + n.y * i), t } invert () { let t = this.a, e = this.b, s = this.c, o = this.d, i = this.tx, n = t * o - e * s; return this.a = o / n, this.b = -e / n, this.c = -s / n, this.d = t / n, this.tx = (s * this.ty - o * i) / n, this.ty = -(t * this.ty - e * i) / n, this } isIdentity () { return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0 } identity () { return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this } clone () { let t = new B; return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t } copyTo (t) { return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t } copyFrom (t) { return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this } equals (t) { return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty } toString () { return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]` } static get IDENTITY () { return rS.identity() } static get shared () { return eS.identity() } }; c(B, "Matrix"); eS = new B, rS = new B }); var at, bo = m(() => { "use strict"; at = class { constructor(t, e, s) { this._x = e || 0, this._y = s || 0, this._observer = t } clone (t) { return new at(t ?? this._observer, this._x, this._y) } set (t = 0, e = t) { return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this } copyFrom (t) { return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this } copyTo (t) { return t.set(this._x, this._y), t } equals (t) { return t.x === this._x && t.y === this._y } toString () { return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]` } get x () { return this._x } set x (t) { this._x !== t && (this._x = t, this._observer._onUpdate(this)) } get y () { return this._y } set y (t) { this._y !== t && (this._y = t, this._observer._onUpdate(this)) } }; c(at, "ObservablePoint") }); function Z (r = "default") { return Vc[r] === void 0 && (Vc[r] = -1), ++Vc[r] } function h_ () { for (let r in Vc) delete Vc[r] } var Vc, Wt = m(() => { "use strict"; Vc = { default: -1 }; c(Z, "uid"); c(h_, "resetUids") }); function w (r, t, e = 3) {
          if (vy[t]) return; let s = new Error().stack; typeof s > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${r}`) : (s = s.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${r}`), console.warn(s), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${r}`), console.warn(s))), vy[t] = !0
        } var vy, G, lt = m(() => { "use strict"; vy = {}, G = "8.0.0"; c(w, "deprecation") }); function gi (r, t, e) { let s = r.length, o; if (t >= s || e === 0) return; e = t + e > s ? s - t : e; let i = s - e; for (o = t; o < i; ++o)r[o] = r[o + e]; r.length = i } var Yc = m(() => { "use strict"; c(gi, "removeItems") }); var $c, _f = m(() => { Yc(); lt(); $c = { allowChildren: !0, removeChildren (r = 0, t) { let e = t ?? this.children.length, s = e - r, o = []; if (s > 0 && s <= e) { for (let i = e - 1; i >= r; i--) { let n = this.children[i]; n && (this.renderGroup && this.renderGroup.removeChild(n), o.push(n), n.parent = null) } gi(this.children, r, e); for (let i = 0; i < o.length; ++i)this.emit("childRemoved", o[i], this, i), o[i].emit("removed", this); return o } else if (s === 0 && this.children.length === 0) return o; throw new RangeError("removeChildren: numeric values are outside the acceptable range.") }, removeChildAt (r) { let t = this.getChildAt(r); return this.removeChild(t) }, getChildAt (r) { if (r < 0 || r >= this.children.length) throw new Error(`getChildAt: Index (${r}) does not exist.`); return this.children[r] }, setChildIndex (r, t) { if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`); this.getChildIndex(r), this.addChildAt(r, t) }, getChildIndex (r) { let t = this.children.indexOf(r); if (t === -1) throw new Error("The supplied Container must be a child of the caller"); return t }, addChildAt (r, t) { this.allowChildren || w(G, "addChildAt: Only Containers will be allowed to add children in v8.0.0"); let { children: e } = this; if (t < 0 || t > e.length) throw new Error(`${r}addChildAt: The index ${t} supplied is out of bounds ${e.length}`); if (r.parent) { let s = r.parent.children.indexOf(r); if (r.parent === this && s === t) return r; s !== -1 && r.parent.children.splice(s, 1) } return t === e.length ? e.push(r) : e.splice(t, 0, r), r.parent = this, r.didChange = !0, r.didViewUpdate = !1, r._updateFlags = 15, this.renderGroup && this.renderGroup.addChild(r), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", r, this, t), r.emit("added", this), r }, swapChildren (r, t) { if (r === t) return; let e = this.getChildIndex(r), s = this.getChildIndex(t); this.children[e] = t, this.children[s] = r }, removeFromParent () { this.parent?.removeChild(this) } } }); var Ue, aa = m(() => { "use strict"; Ue = class { constructor(t) { this.pipe = "filter", this.priority = 1, this.filters = t?.filters, this.filterArea = t?.filterArea } destroy () { for (let t = 0; t < this.filters.length; t++)this.filters[t].destroy(); this.filters = null, this.filterArea = null } }; c(Ue, "FilterEffect") }); var Ve, jc = m(() => { "use strict"; Ve = class { constructor(t, e) { this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e) } prepopulate (t) { for (let e = 0; e < t; e++)this._pool[this._index++] = new this._classType; this._count += t } get (t) { let e; return this._index > 0 ? e = this._pool[--this._index] : e = new this._classType, e.init?.(t), e } return (t) { t.reset?.(), this._pool[this._index++] = t } get totalSize () { return this._count } get totalFree () { return this._index } get totalUsed () { return this._count - this._index } }; c(Ve, "Pool") }); var _i, Y, Jt = m(() => { jc(); _i = class { constructor() { this._poolsByClass = new Map } prepopulate (t, e) { this.getPool(t).prepopulate(e) } get (t, e) { return this.getPool(t).get(e) } return (t) { this.getPool(t.constructor).return(t) } getPool (t) { return this._poolsByClass.has(t) || this._poolsByClass.set(t, new Ve(t)), this._poolsByClass.get(t) } stats () { let t = {}; return this._poolsByClass.forEach(e => { let s = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name; t[s] = { free: e.totalFree, used: e.totalUsed, size: e.totalSize } }), t } }; c(_i, "PoolGroupClass"); Y = new _i }); var bi, yi, Kc = m(() => { S(); Jt(); bi = class { constructor() { this._effectClasses = [], this._tests = [], this._initialized = !1 } init () { this._initialized || (this._initialized = !0, this._effectClasses.forEach(t => { this.add({ test: t.test, maskClass: t }) })) } add (t) { this._tests.push(t) } getMaskEffect (t) { this._initialized || this.init(); for (let e = 0; e < this._tests.length; e++) { let s = this._tests[e]; if (s.test(t)) return Y.get(s.maskClass, t) } return t } returnMaskEffect (t) { Y.return(t) } }; c(bi, "MaskEffectManagerClass"); yi = new bi; I.handleByList(x.MaskEffect, yi._effectClasses) }); var qc, bf = m(() => { aa(); Kc(); Jt(); qc = { _mask: null, _filters: null, effects: [], addEffect (r) { this.effects.indexOf(r) === -1 && (this.effects.push(r), this.effects.sort((e, s) => e.priority - s.priority), this.renderGroup && (this.renderGroup.structureDidChange = !0), this._updateIsSimple()) }, removeEffect (r) { let t = this.effects.indexOf(r); t !== -1 && (this.effects.splice(t, 1), !this.isRenderGroupRoot && this.renderGroup && (this.renderGroup.structureDidChange = !0), this._updateIsSimple()) }, set mask (r) { if (this._mask || (this._mask = { mask: null, effect: null }), this._mask.mask === r || (this._mask.effect && (this.removeEffect(this._mask.effect), yi.returnMaskEffect(this._mask.effect), this._mask.effect = null), this._mask.mask = r, r == null)) return; let t = yi.getMaskEffect(r); this._mask.effect = t, this.addEffect(t) }, get mask () { return this._mask?.mask }, set filters (r) { !Array.isArray(r) && r && (r = [r]), r = r, this._filters || (this._filters = { filters: null, effect: null, filterArea: null }); let t = r?.length > 0, e = this._filters.effect && !t || !this._filters.effect && t; if (r = Array.isArray(r) ? r.slice(0) : r, this._filters.filters = Object.freeze(r), e) if (t) { let s = Y.get(Ue); this._filters.effect = s, this.addEffect(s) } else { let s = this._filters.effect; this.removeEffect(s), s.filterArea = null, s.filters = null, this._filters.effect = null, Y.return(s) } t && (this._filters.effect.filters = r, this._filters.effect.filterArea = this.filterArea) }, get filters () { return this._filters?.filters }, set filterArea (r) { this._filters || (this._filters = { filters: null, effect: null, filterArea: null }), this._filters.filterArea = r }, get filterArea () { return this._filters?.filterArea } } }); var Zc, yf = m(() => { lt(); Zc = { label: null, get name () { return w(G, "Container.name property has been removed, use Container.label instead"), this.label }, set name (r) { w(G, "Container.name property has been removed, use Container.label instead"), this.label = r }, getChildByName (r, t = !1) { return this.getChildByLabel(r, t) }, getChildByLabel (r, t = !1) { let e = this.children; for (let s = 0; s < e.length; s++) { let o = e[s]; if (o.label === r || r instanceof RegExp && r.test(o.label)) return o } if (t) for (let s = 0; s < e.length; s++) { let i = e[s].getChildByLabel(r, !0); if (i) return i } return null }, getChildrenByLabel (r, t = !1, e = []) { let s = this.children; for (let o = 0; o < s.length; o++) { let i = s[o]; (i.label === r || r instanceof RegExp && r.test(i.label)) && e.push(i) } if (t) for (let o = 0; o < s.length; o++)s[o].getChildrenByLabel(r, !0, e); return e } } }); var vf, H, Gt = m(() => { ce(); vf = [new V, new V, new V, new V], H = class { constructor(t = 0, e = 0, s = 0, o = 0) { this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(s), this.height = Number(o) } get left () { return this.x } get right () { return this.x + this.width } get top () { return this.y } get bottom () { return this.y + this.height } isEmpty () { return this.left === this.right || this.top === this.bottom } static get EMPTY () { return new H(0, 0, 0, 0) } clone () { return new H(this.x, this.y, this.width, this.height) } copyFromBounds (t) { return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this } copyFrom (t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this } copyTo (t) { return t.copyFrom(this), t } contains (t, e) { return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height } strokeContains (t, e, s) { let { width: o, height: i } = this; if (o <= 0 || i <= 0) return !1; let n = this.x, a = this.y, l = n - s / 2, h = n + o + s / 2, u = a - s / 2, d = a + i + s / 2, f = n + s / 2, p = n + o - s / 2, g = a + s / 2, b = a + i - s / 2; return t >= l && t <= h && e >= u && e <= d && !(t > f && t < p && e > g && e < b) } intersects (t, e) { if (!e) { let F = this.x < t.x ? t.x : this.x; if ((this.right > t.right ? t.right : this.right) <= F) return !1; let A = this.y < t.y ? t.y : this.y; return (this.bottom > t.bottom ? t.bottom : this.bottom) > A } let s = this.left, o = this.right, i = this.top, n = this.bottom; if (o <= s || n <= i) return !1; let a = vf[0].set(t.left, t.top), l = vf[1].set(t.left, t.bottom), h = vf[2].set(t.right, t.top), u = vf[3].set(t.right, t.bottom); if (h.x <= a.x || l.y <= a.y) return !1; let d = Math.sign(e.a * e.d - e.b * e.c); if (d === 0 || (e.apply(a, a), e.apply(l, l), e.apply(h, h), e.apply(u, u), Math.max(a.x, l.x, h.x, u.x) <= s || Math.min(a.x, l.x, h.x, u.x) >= o || Math.max(a.y, l.y, h.y, u.y) <= i || Math.min(a.y, l.y, h.y, u.y) >= n)) return !1; let f = d * (l.y - a.y), p = d * (a.x - l.x), g = f * s + p * i, b = f * o + p * i, _ = f * s + p * n, y = f * o + p * n; if (Math.max(g, b, _, y) <= f * a.x + p * a.y || Math.min(g, b, _, y) >= f * u.x + p * u.y) return !1; let v = d * (a.y - h.y), T = d * (h.x - a.x), P = v * s + T * i, M = v * o + T * i, D = v * s + T * n, R = v * o + T * n; return !(Math.max(P, M, D, R) <= v * a.x + T * a.y || Math.min(P, M, D, R) >= v * u.x + T * u.y) } pad (t = 0, e = t) { return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this } fit (t) { let e = Math.max(this.x, t.x), s = Math.min(this.x + this.width, t.x + t.width), o = Math.max(this.y, t.y), i = Math.min(this.y + this.height, t.y + t.height); return this.x = e, this.width = Math.max(s - e, 0), this.y = o, this.height = Math.max(i - o, 0), this } ceil (t = 1, e = .001) { let s = Math.ceil((this.x + this.width - e) * t) / t, o = Math.ceil((this.y + this.height - e) * t) / t; return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = s - this.x, this.height = o - this.y, this } enlarge (t) { let e = Math.min(this.x, t.x), s = Math.max(this.x + this.width, t.x + t.width), o = Math.min(this.y, t.y), i = Math.max(this.y + this.height, t.y + t.height); return this.x = e, this.width = s - e, this.y = o, this.height = i - o, this } getBounds (t) { return t = t || new H, t.copyFrom(this), t } toString () { return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]` } }; c(H, "Rectangle") }); var Sy, it, te = m(() => { ot(); Gt(); Sy = new B, it = class { constructor(t = 1 / 0, e = 1 / 0, s = -1 / 0, o = -1 / 0) { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Sy, this.minX = t, this.minY = e, this.maxX = s, this.maxY = o } isEmpty () { return this.minX > this.maxX || this.minY > this.maxY } get rectangle () { this._rectangle || (this._rectangle = new H); let t = this._rectangle; return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t } clear () { return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Sy, this } set (t, e, s, o) { this.minX = t, this.minY = e, this.maxX = s, this.maxY = o } addFrame (t, e, s, o, i) { i || (i = this.matrix); let n = i.a, a = i.b, l = i.c, h = i.d, u = i.tx, d = i.ty, f = this.minX, p = this.minY, g = this.maxX, b = this.maxY, _ = n * t + l * e + u, y = a * t + h * e + d; _ < f && (f = _), y < p && (p = y), _ > g && (g = _), y > b && (b = y), _ = n * s + l * e + u, y = a * s + h * e + d, _ < f && (f = _), y < p && (p = y), _ > g && (g = _), y > b && (b = y), _ = n * t + l * o + u, y = a * t + h * o + d, _ < f && (f = _), y < p && (p = y), _ > g && (g = _), y > b && (b = y), _ = n * s + l * o + u, y = a * s + h * o + d, _ < f && (f = _), y < p && (p = y), _ > g && (g = _), y > b && (b = y), this.minX = f, this.minY = p, this.maxX = g, this.maxY = b } addRect (t, e) { this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e) } addBounds (t, e) { this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e) } addBoundsMask (t) { this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY } applyMatrix (t) { let e = this.minX, s = this.minY, o = this.maxX, i = this.maxY, { a: n, b: a, c: l, d: h, tx: u, ty: d } = t, f = n * e + l * s + u, p = a * e + h * s + d; this.minX = f, this.minY = p, this.maxX = f, this.maxY = p, f = n * o + l * s + u, p = a * o + h * s + d, this.minX = f < this.minX ? f : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = p > this.maxY ? p : this.maxY, f = n * e + l * i + u, p = a * e + h * i + d, this.minX = f < this.minX ? f : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = p > this.maxY ? p : this.maxY, f = n * o + l * i + u, p = a * o + h * i + d, this.minX = f < this.minX ? f : this.minX, this.minY = p < this.minY ? p : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = p > this.maxY ? p : this.maxY } fit (t) { return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this } fitBounds (t, e, s, o) { return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < s && (this.minY = s), this.maxY > o && (this.maxY = o), this } pad (t, e = t) { return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this } ceil () { return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this } clone () { return new it(this.minX, this.minY, this.maxX, this.maxY) } scale (t, e = t) { return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this } get x () { return this.minX } set x (t) { let e = this.maxX - this.minX; this.minX = t, this.maxX = t + e } get y () { return this.minY } set y (t) { let e = this.maxY - this.minY; this.minY = t, this.maxY = t + e } get width () { return this.maxX - this.minX } set width (t) { this.maxX = this.minX + t } get height () { return this.maxY - this.minY } set height (t) { this.maxY = this.minY + t } get left () { return this.minX } get right () { return this.maxX } get top () { return this.minY } get bottom () { return this.maxY } get isPositive () { return this.maxX - this.minX > 0 && this.maxY - this.minY > 0 } get isValid () { return this.minX + this.minY !== 1 / 0 } addVertexData (t, e, s, o) { let i = this.minX, n = this.minY, a = this.maxX, l = this.maxY; o || (o = this.matrix); let h = o.a, u = o.b, d = o.c, f = o.d, p = o.tx, g = o.ty; for (let b = e; b < s; b += 2) { let _ = t[b], y = t[b + 1], v = h * _ + d * y + p, T = u * _ + f * y + g; i = v < i ? v : i, n = T < n ? T : n, a = v > a ? v : a, l = T > l ? T : l } this.minX = i, this.minY = n, this.maxX = a, this.maxY = l } containsPoint (t, e) { return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e } toString () { return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]` } }; c(it, "Bounds") }); var le, ee, vi = m(() => { ot(); jc(); te(); le = new Ve(B), ee = new Ve(it) }); function Ye (r, t, e) { e.clear(); let s, o; return r.parent ? t ? s = r.parent.worldTransform : (o = le.get().identity(), s = yo(r, o)) : s = B.IDENTITY, Qc(r, e, s, t), o && le.return(o), e.isValid || e.set(0, 0, 0, 0), e } function Qc (r, t, e, s) { if (!r.visible || !r.measurable) return; let o; s ? o = r.worldTransform : (r.updateLocalTransform(), o = le.get(), o.appendFrom(r.localTransform, e)); let i = t, n = !!r.effects.length; if (n && (t = ee.get().clear()), r.boundsArea) t.addRect(r.boundsArea, o); else { r.addBounds && (t.matrix = o, r.addBounds(t)); for (let a = 0; a < r.children.length; a++)Qc(r.children[a], t, o, s) } if (n) { for (let a = 0; a < r.effects.length; a++)r.effects[a].addBounds?.(t); i.addBounds(t, B.IDENTITY), ee.return(t) } s || le.return(o) } function yo (r, t) { let e = r.parent; return e && (yo(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t } var vo = m(() => { ot(); vi(); c(Ye, "getGlobalBounds"); c(Qc, "_getGlobalBounds"); c(yo, "updateTransformBackwards") }); function U (...r) { d_ !== Ty && (d_++, d_ === Ty ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...r)) } var d_, Ty, ut = m(() => { "use strict"; d_ = 0, Ty = 500; c(U, "warn") }); function Dr (r, t, e) { return t.clear(), e || (e = B.IDENTITY), Ey(r, t, e, r, !0), t.isValid || t.set(0, 0, 0, 0), t } function Ey (r, t, e, s, o) { let i; if (o) i = le.get(), i = e.copyTo(i); else { if (!r.visible || !r.measurable) return; r.updateLocalTransform(); let l = r.localTransform; i = le.get(), i.appendFrom(l, e) } let n = t, a = !!r.effects.length; if (a && (t = ee.get().clear()), r.boundsArea) t.addRect(r.boundsArea, i); else { r.renderPipeId && (t.matrix = i, r.addBounds(t)); let l = r.children; for (let h = 0; h < l.length; h++)Ey(l[h], t, i, s, !1) } if (a) { for (let l = 0; l < r.effects.length; l++)r.effects[l].addLocalBounds?.(t, s); n.addBounds(t, B.IDENTITY), ee.return(t) } le.return(i) } function Sf (r, t, e) { let s = r.parent; if (!s) { U("Item is not inside the root container"); return } s !== t && (Sf(s, t, e), s.updateLocalTransform(), e.append(s.localTransform)) } var ca = m(() => { ot(); ut(); vi(); c(Dr, "getLocalBounds"); c(Ey, "_getLocalBounds"); c(Sf, "getParent") }); function la (r, t) { let e = r.children; for (let s = 0; s < e.length; s++) { let o = e[s], i = (o.uid & 255) << 24 | o._didChangeId & 16777215; t.data[t.index] !== i && (t.data[t.index] = i, t.didChange = !0), t.index++, o.children.length && la(o, t) } return t.didChange } var Tf = m(() => { "use strict"; c(la, "checkChildrenDidChange") }); var sS, Jc, Ef = m(() => { ot(); te(); vo(); ca(); Tf(); sS = new B, Jc = { _localBoundsCacheId: -1, _localBoundsCacheData: null, _setWidth (r, t) { let e = Math.sign(this.scale.x) || 1; t !== 0 ? this.scale.x = r / t * e : this.scale.x = e }, _setHeight (r, t) { let e = Math.sign(this.scale.y) || 1; t !== 0 ? this.scale.y = r / t * e : this.scale.y = e }, getLocalBounds () { this._localBoundsCacheData || (this._localBoundsCacheData = { data: [], index: 1, didChange: !1, localBounds: new it }); let r = this._localBoundsCacheData; return r.index = 1, r.didChange = !1, r.data[0] !== this._didChangeId >> 12 && (r.didChange = !0, r.data[0] = this._didChangeId >> 12), la(this, r), r.didChange && Dr(this, r.localBounds, sS), r.localBounds }, getBounds (r, t) { return Ye(this, r, t || new it) } } }); var tl, Pf = m(() => { "use strict"; tl = { _onRender: null, set onRender (r) { let t = this.renderGroup; if (!r) { this._onRender && t?.removeOnRender(this), this._onRender = null; return } this._onRender || t?.addOnRender(this), this._onRender = r }, get onRender () { return this._onRender } } }); function oS (r, t) { return r._zIndex - t._zIndex } var el, Cf = m(() => { "use strict"; el = { _zIndex: 0, sortDirty: !1, sortableChildren: !1, get zIndex () { return this._zIndex }, set zIndex (r) { this._zIndex !== r && (this._zIndex = r, this.depthOfChildModified()) }, depthOfChildModified () { this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.renderGroup && !this.isRenderGroupRoot && (this.renderGroup.structureDidChange = !0) }, sortChildren () { this.sortDirty && (this.sortDirty = !1, this.children.sort(oS)) } }; c(oS, "sortChildren") }); var rl, Bf = m(() => { ot(); ce(); vo(); rl = { getGlobalPosition (r = new V, t = !1) { return this.parent ? this.parent.toGlobal(this._position, r, t) : (r.x = this._position.x, r.y = this._position.y), r }, toGlobal (r, t, e = !1) { if (!e) { this.updateLocalTransform(); let s = yo(this, new B); return s.append(this.localTransform), s.apply(r, t) } return this.worldTransform.apply(r, t) }, toLocal (r, t, e, s) { if (t && (r = t.toGlobal(r, e, s)), !s) { this.updateLocalTransform(); let o = yo(this, new B); return o.append(this.localTransform), o.applyInverse(r, e) } return this.worldTransform.applyInverse(r, e) } } }); var hr, sl = m(() => { Wt(); hr = class { constructor() { this.uid = Z("instructionSet"), this.instructions = [], this.instructionSize = 0 } reset () { this.instructionSize = 0 } add (t) { this.instructions[this.instructionSize++] = t } log () { this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]) } }; c(hr, "InstructionSet") }); var So, Af = m(() => { ot(); sl(); So = class { constructor(t) { this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this._children = [], this.worldTransform = new B, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new hr, this._onRenderContainers = [], this.root = t, this.addChild(t) } get localTransform () { return this.root.localTransform } addRenderGroupChild (t) { t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.onChildUpdate(t.root), this.renderGroupChildren.push(t) } _removeRenderGroupChild (t) { t.root.didChange && this._removeChildFromUpdate(t.root); let e = this.renderGroupChildren.indexOf(t); e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null } addChild (t) { if (this.structureDidChange = !0, t !== this.root && (this._children.push(t), t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1), t.renderGroup) { if (t.renderGroup.root === t) { this.addRenderGroupChild(t.renderGroup); return } } else t.renderGroup = this, t.didChange = !0; t._onRender && (t.isRenderGroupRoot ? t.renderGroup.root === t && this.addOnRender(t) : this.addOnRender(t)); let e = t.children; t.isRenderGroupRoot || this.onChildUpdate(t); for (let s = 0; s < e.length; s++)this.addChild(e[s]) } removeChild (t) { if (this.structureDidChange = !0, t._onRender && (t.isRenderGroupRoot ? t.renderGroup.root === t && this.removeOnRender(t) : this.removeOnRender(t)), t.renderGroup.root !== t) { let s = t.children; for (let o = 0; o < s.length; o++)this.removeChild(s[o]); t.didChange && t.renderGroup._removeChildFromUpdate(t), t.renderGroup = null } else this._removeRenderGroupChild(t.renderGroup); let e = this._children.indexOf(t); e > -1 && this._children.splice(e, 1) } onChildUpdate (t) { let e = this.childrenToUpdate[t.relativeRenderGroupDepth]; e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = { index: 0, list: [] }), e.list[e.index++] = t } updateRenderable (t) { t.globalDisplayStatus < 7 || (t.didViewUpdate = !1, this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t)) } onChildViewUpdate (t) { this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t } _removeChildFromUpdate (t) { let e = this.childrenToUpdate[t.relativeRenderGroupDepth]; if (!e) return; let s = e.list.indexOf(t); s > -1 && e.list.splice(s, 1), e.index-- } get isRenderable () { return this.root.localDisplayStatus === 7 && this.worldAlpha > 0 } addOnRender (t) { this._onRenderContainers.push(t) } removeOnRender (t) { this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1) } runOnRender () { for (let t = 0; t < this._onRenderContainers.length; t++)this._onRenderContainers[t]._onRender() } }; c(So, "RenderGroup") }); function ol (r, t, e = {}) { for (let s in t) !e[s] && t[s] !== void 0 && (r[s] = t[s]) } var wf = m(() => { "use strict"; c(ol, "assignWithIgnore") }); var Py, f_, p_, m_, Si, ua, To, x_, N, It = m(() => { Py = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); $t(); gf(); ot(); zc(); bo(); Wt(); lt(); _f(); bf(); yf(); Ef(); Pf(); Cf(); Bf(); Af(); wf(); f_ = new at(null), p_ = new at(null), m_ = new at(null, 1, 1), Si = 1, ua = 2, To = 4, x_ = 8, N = class extends Py.default { constructor(t = {}) { super(), this.uid = Z("renderable"), this._updateFlags = 15, this.isRenderGroupRoot = !1, this.renderGroup = null, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new B, this.relativeGroupTransform = new B, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new at(this, 0, 0), this._scale = m_, this._pivot = p_, this._skew = f_, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didChangeId = 0, this._didLocalTransformChangeId = -1, ol(this, t, { children: !0, parent: !0, effects: !0 }), t.children?.forEach(e => this.addChild(e)), this.effects = [], t.parent?.addChild(this) } static mixin (t) { Object.defineProperties(N.prototype, Object.getOwnPropertyDescriptors(t)) } addChild (...t) { if (this.allowChildren || w(G, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) { for (let s = 0; s < t.length; s++)this.addChild(t[s]); return t[0] } let e = t[0]; return e.parent === this ? (this.children.splice(this.children.indexOf(e), 1), this.children.push(e), this.renderGroup && !this.isRenderGroupRoot && (this.renderGroup.structureDidChange = !0), e) : (e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = !0), e.parent = this, e.didChange = !0, e.didViewUpdate = !1, e._updateFlags = 15, this.renderGroup && this.renderGroup.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didChangeId += 4096, e._zIndex !== 0 && e.depthOfChildModified(), e) } removeChild (...t) { if (t.length > 1) { for (let o = 0; o < t.length; o++)this.removeChild(t[o]); return t[0] } let e = t[0], s = this.children.indexOf(e); return s > -1 && (this._didChangeId += 4096, this.children.splice(s, 1), this.renderGroup && this.renderGroup.removeChild(e), e.parent = null, this.emit("childRemoved", e, this, s), e.emit("removed", this)), e } _onUpdate (t) { if (t && t === this._skew && this._updateSkew(), this._didChangeId++, !this.didChange) if (this.didChange = !0, this.isRenderGroupRoot) { let e = this.renderGroup.renderGroupParent; e && e.onChildUpdate(this) } else this.renderGroup && this.renderGroup.onChildUpdate(this) } set isRenderGroup (t) { if (this.isRenderGroupRoot && t === !1) throw new Error("[Pixi] cannot undo a render group just yet"); t && this.enableRenderGroup() } get isRenderGroup () { return this.isRenderGroupRoot } enableRenderGroup () { if (this.renderGroup && this.renderGroup.root === this) return; this.isRenderGroupRoot = !0; let t = this.renderGroup; if (t && t.removeChild(this), this.renderGroup = new So(this), t) { for (let e = 0; e < t.renderGroupChildren.length; e++) { let s = t.renderGroupChildren[e], o = s.root; for (; o;) { if (o === this) { this.renderGroup.addRenderGroupChild(s); break } o = o.parent } } t.addRenderGroupChild(this.renderGroup) } this._updateIsSimple(), this.groupTransform = B.IDENTITY } _updateIsSimple () { this.isSimple = !this.isRenderGroupRoot && this.effects.length === 0 } get worldTransform () { return this._worldTransform || (this._worldTransform = new B), this.renderGroup && (this.isRenderGroupRoot ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform)), this._worldTransform } get x () { return this._position.x } set x (t) { this._position.x = t } get y () { return this._position.y } set y (t) { this._position.y = t } get position () { return this._position } set position (t) { this._position.copyFrom(t) } get rotation () { return this._rotation } set rotation (t) { this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew)) } get angle () { return this.rotation * Wc } set angle (t) { this.rotation = t * Xc } get pivot () { return this._pivot === p_ && (this._pivot = new at(this, 0, 0)), this._pivot } set pivot (t) { this._pivot === p_ && (this._pivot = new at(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t) } get skew () { return this._skew === f_ && (this._skew = new at(this, 0, 0)), this._skew } set skew (t) { this._skew === f_ && (this._skew = new at(this, 0, 0)), this._skew.copyFrom(t) } get scale () { return this._scale === m_ && (this._scale = new at(this, 1, 1)), this._scale } set scale (t) { this._scale === m_ && (this._scale = new at(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t) } get width () { return Math.abs(this.scale.x * this.getLocalBounds().width) } set width (t) { let e = this.getLocalBounds().width; this._setWidth(t, e) } get height () { return Math.abs(this.scale.y * this.getLocalBounds().height) } set height (t) { let e = this.getLocalBounds().height; this._setHeight(t, e) } getSize (t) { t || (t = {}); let e = this.getLocalBounds(); return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t } setSize (t, e) { let s = this.getLocalBounds(), o, i; typeof t != "object" ? (o = t, i = e ?? t) : (o = t.width, i = t.height ?? t.width), o !== void 0 && this._setWidth(o, s.width), i !== void 0 && this._setHeight(i, s.height) } _updateSkew () { let t = this._rotation, e = this._skew; this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x) } updateTransform (t) { return this.position.set(typeof t.x == "number" ? t.x : this.position.x, typeof t.y == "number" ? t.y : this.position.y), this.scale.set(typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x, typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(typeof t.skewX == "number" ? t.skewX : this.skew.x, typeof t.skewY == "number" ? t.skewY : this.skew.y), this.pivot.set(typeof t.pivotX == "number" ? t.pivotX : this.pivot.x, typeof t.pivotY == "number" ? t.pivotY : this.pivot.y), this } setFromMatrix (t) { t.decompose(this) } updateLocalTransform () { if ((this._didLocalTransformChangeId & 15) === this._didChangeId) return; this._didLocalTransformChangeId = this._didChangeId; let t = this.localTransform, e = this._scale, s = this._pivot, o = this._position, i = e._x, n = e._y, a = s._x, l = s._y; t.a = this._cx * i, t.b = this._sx * i, t.c = this._cy * n, t.d = this._sy * n, t.tx = o._x - (a * t.a + l * t.c), t.ty = o._y - (a * t.b + l * t.d) } set alpha (t) { t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= Si, this._onUpdate()) } get alpha () { return this.localAlpha } set tint (t) { let s = j.shared.setValue(t ?? 16777215).toBgrNumber(); s !== this.localColor && (this.localColor = s, this._updateFlags |= Si, this._onUpdate()) } get tint () { let t = this.localColor; return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255) } set blendMode (t) { this.localBlendMode !== t && (this.renderGroup && !this.isRenderGroupRoot && (this.renderGroup.structureDidChange = !0), this._updateFlags |= ua, this.localBlendMode = t, this._onUpdate()) } get blendMode () { return this.localBlendMode } get visible () { return !!(this.localDisplayStatus & 2) } set visible (t) { let e = t ? 1 : 0; (this.localDisplayStatus & 2) >> 1 !== e && (this.renderGroup && !this.isRenderGroupRoot && (this.renderGroup.structureDidChange = !0), this._updateFlags |= To, this.localDisplayStatus ^= 2, this._onUpdate()) } get culled () { return !(this.localDisplayStatus & 4) } set culled (t) { let e = t ? 1 : 0; (this.localDisplayStatus & 4) >> 2 !== e && (this.renderGroup && !this.isRenderGroupRoot && (this.renderGroup.structureDidChange = !0), this._updateFlags |= To, this.localDisplayStatus ^= 4, this._onUpdate()) } get renderable () { return !!(this.localDisplayStatus & 1) } set renderable (t) { let e = t ? 1 : 0; (this.localDisplayStatus & 1) !== e && (this._updateFlags |= To, this.localDisplayStatus ^= 1, this.renderGroup && !this.isRenderGroupRoot && (this.renderGroup.structureDidChange = !0), this._onUpdate()) } get isRenderable () { return this.localDisplayStatus === 7 && this.groupAlpha > 0 } destroy (t = !1) { if (this.destroyed) return; this.destroyed = !0, this.removeFromParent(), this.parent = null, this._mask = null, this._filters = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(); let e = typeof t == "boolean" ? t : t?.children, s = this.removeChildren(0, this.children.length); if (e) for (let o = 0; o < s.length; ++o)s[o].destroy(t) } }; c(N, "Container"); N.mixin($c); N.mixin(rl); N.mixin(tl); N.mixin(Jc); N.mixin(qc); N.mixin(Zc); N.mixin(el); N.mixin(Hc) }); var de, ha = m(() => { ce(); de = class { constructor(t) { this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = de.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new V, this.page = new V, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t } get layerX () { return this.layer.x } get layerY () { return this.layer.y } get pageX () { return this.page.x } get pageY () { return this.page.y } get data () { return this } composedPath () { return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path } initEvent (t, e, s) { throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } initUIEvent (t, e, s, o, i) { throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } preventDefault () { this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0 } stopImmediatePropagation () { this.propagationImmediatelyStopped = !0 } stopPropagation () { this.propagationStopped = !0 } }; c(de, "FederatedEvent") }); var g_, iS, il, Rf = m(() => { g_ = Ct(Tt("/node_modules/ismobilejs?_v=1.1.1&_env=prod"), 1), iS = g_.default.default ?? g_.default, il = iS(globalThis.navigator) }); var nS, Mf, aS, cS, Cy, By, lS, uS, hS, Lr, Gf = m(() => { ha(); S(); Rf(); Yc(); nS = 9, Mf = 100, aS = 0, cS = 0, Cy = 2, By = 1, lS = -1e3, uS = -1e3, hS = 2, Lr = class { constructor(t, e = il) { this._mobileInfo = e, this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (e.tablet || e.phone) && this._createTouchHook(); let s = document.createElement("div"); s.style.width = `${Mf}px`, s.style.height = `${Mf}px`, s.style.position = "absolute", s.style.top = `${aS}px`, s.style.left = `${cS}px`, s.style.zIndex = Cy.toString(), this._div = s, this._renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1) } get isActive () { return this._isActive } get isMobileAccessibility () { return this._isMobileAccessibility } get hookDiv () { return this._hookDiv } _createTouchHook () { let t = document.createElement("button"); t.style.width = `${By}px`, t.style.height = `${By}px`, t.style.position = "absolute", t.style.top = `${lS}px`, t.style.left = `${uS}px`, t.style.zIndex = hS.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => { this._isMobileAccessibility = !0, this._activate(), this._destroyTouchHook() }), document.body.appendChild(t), this._hookDiv = t } _destroyTouchHook () { this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null) } _activate () { this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this._renderer.runners.postrender.add(this), this._renderer.view.canvas.parentNode?.appendChild(this._div)) } _deactivate () { !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this._renderer.runners.postrender.remove(this), this._div.parentNode?.removeChild(this._div)) } _updateAccessibleObjects (t) { if (!t.visible || !t.accessibleChildren) return; t.accessible && t.isInteractive() && (t._accessibleActive || this._addChild(t), t._renderId = this._renderId); let e = t.children; if (e) for (let s = 0; s < e.length; s++)this._updateAccessibleObjects(e[s]) } init (t) { this.debug = t?.debug ?? this.debug, this._renderer.runners.postrender.remove(this) } postrender () { let t = performance.now(); if (this._mobileInfo.android.device && t < this._androidUpdateCount || (this._androidUpdateCount = t + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas)) return; this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered); let { x: e, y: s, width: o, height: i } = this._renderer.view.canvas.getBoundingClientRect(), { width: n, height: a, resolution: l } = this._renderer, h = o / n * l, u = i / a * l, d = this._div; d.style.left = `${e}px`, d.style.top = `${s}px`, d.style.width = `${n}px`, d.style.height = `${a}px`; for (let f = 0; f < this._children.length; f++) { let p = this._children[f]; if (p._renderId !== this._renderId) p._accessibleActive = !1, gi(this._children, f, 1), this._div.removeChild(p._accessibleDiv), this._pool.push(p._accessibleDiv), p._accessibleDiv = null, f--; else { d = p._accessibleDiv; let g = p.hitArea, b = p.worldTransform; p.hitArea ? (d.style.left = `${(b.tx + g.x * b.a) * h}px`, d.style.top = `${(b.ty + g.y * b.d) * u}px`, d.style.width = `${g.width * b.a * h}px`, d.style.height = `${g.height * b.d * u}px`) : (g = p.getBounds().rectangle, this._capHitArea(g), d.style.left = `${g.x * h}px`, d.style.top = `${g.y * u}px`, d.style.width = `${g.width * h}px`, d.style.height = `${g.height * u}px`, d.title !== p.accessibleTitle && p.accessibleTitle !== null && (d.title = p.accessibleTitle || ""), d.getAttribute("aria-label") !== p.accessibleHint && p.accessibleHint !== null && d.setAttribute("aria-label", p.accessibleHint || "")), (p.accessibleTitle !== d.title || p.tabIndex !== d.tabIndex) && (d.title = p.accessibleTitle || "", d.tabIndex = p.tabIndex, this.debug && this._updateDebugHTML(d)) } } this._renderId++ } _updateDebugHTML (t) { t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}` } _capHitArea (t) { t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0); let { width: e, height: s } = this._renderer; t.x + t.width > e && (t.width = e - t.x), t.y + t.height > s && (t.height = s - t.y) } _addChild (t) { let e = this._pool.pop(); e || (e = document.createElement("button"), e.style.width = `${Mf}px`, e.style.height = `${Mf}px`, e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = Cy.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = `container ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this._updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.container = t, this._children.push(t), this._div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex } _dispatchEvent (t, e) { let { container: s } = t.target, o = this._renderer.events.rootBoundary, i = Object.assign(new de(o), { target: s }); o.rootTarget = this._renderer.lastObjectRendered, e.forEach(n => o.dispatchEvent(i, n)) } _onClick (t) { this._dispatchEvent(t, ["click", "pointertap", "tap"]) } _onFocus (t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, ["mouseover"]) } _onFocusOut (t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, ["mouseout"]) } _onKeyDown (t) { t.keyCode === nS && this._activate() } _onMouseMove (t) { t.movementX === 0 && t.movementY === 0 || this._deactivate() } destroy () { this._destroyTouchHook(), this._div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this._pool = null, this._children = null, this._renderer = null } }; c(Lr, "AccessibilitySystem"); Lr.extension = { type: [x.WebGLSystem, x.WebGPUSystem], name: "accessibility" } }); var nl, Uf = m(() => { "use strict"; nl = { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: !1, _accessibleDiv: null, accessibleType: "button", accessiblePointerEvents: "auto", accessibleChildren: !0, _renderId: -1 } }); var Ay = m(() => { S(); It(); Gf(); Uf(); I.add(Lr); N.mixin(nl) }); var Hr, Ff = m(() => { S(); Hr = class { static init (t) { Object.defineProperty(this, "resizeTo", { set (e) { globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = e, e && (globalThis.addEventListener("resize", this.queueResize), this.resize()) }, get () { return this._resizeTo } }), this.queueResize = () => { this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize())) }, this._cancelResize = () => { this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null) }, this.resize = () => { if (!this._resizeTo) return; this._cancelResize(); let e, s; if (this._resizeTo === globalThis.window) e = globalThis.innerWidth, s = globalThis.innerHeight; else { let { clientWidth: o, clientHeight: i } = this._resizeTo; e = o, s = i } this.renderer.resize(e, s), this.render() }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null } static destroy () { globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null } }; c(Hr, "ResizePlugin"); Hr.extension = x.Application }); var re, Eo = m(() => { "use strict"; re = (r => (r[r.INTERACTION = 50] = "INTERACTION", r[r.HIGH = 25] = "HIGH", r[r.NORMAL = 0] = "NORMAL", r[r.LOW = -25] = "LOW", r[r.UTILITY = -50] = "UTILITY", r))(re || {}) }); var dr, If = m(() => { "use strict"; dr = class { constructor(t, e = null, s = 0, o = !1) { this.next = null, this.previous = null, this._destroyed = !1, this._fn = t, this._context = e, this.priority = s, this._once = o } match (t, e = null) { return this._fn === t && this._context === e } emit (t) { this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t)); let e = this.next; return this._once && this.destroy(!0), this._destroyed && (this.next = null), e } connect (t) { this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this } destroy (t = !1) { this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous); let e = this.next; return this.next = t ? null : e, this.previous = null, e } }; c(dr, "TickerListener") }); var wy, Bt, Po = m(() => { Eo(); If(); wy = c(class be { constructor() { this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new dr(null, null, 1 / 0), this.deltaMS = 1 / be.targetFPMS, this.elapsedMS = 1 / be.targetFPMS, this._tick = t => { this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick))) } } _requestIfNeeded () { this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick)) } _cancelIfNeeded () { this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null) } _startIfPossible () { this.started ? this._requestIfNeeded() : this.autoStart && this.start() } add (t, e, s = re.NORMAL) { return this._addListener(new dr(t, e, s)) } addOnce (t, e, s = re.NORMAL) { return this._addListener(new dr(t, e, s, !0)) } _addListener (t) { let e = this._head.next, s = this._head; if (!e) t.connect(s); else { for (; e;) { if (t.priority > e.priority) { t.connect(s); break } s = e, e = e.next } t.previous || t.connect(s) } return this._startIfPossible(), this } remove (t, e) { let s = this._head.next; for (; s;)s.match(t, e) ? s = s.destroy() : s = s.next; return this._head.next || this._cancelIfNeeded(), this } get count () { if (!this._head) return 0; let t = 0, e = this._head; for (; e = e.next;)t++; return t } start () { this.started || (this.started = !0, this._requestIfNeeded()) } stop () { this.started && (this.started = !1, this._cancelIfNeeded()) } destroy () { if (!this._protected) { this.stop(); let t = this._head.next; for (; t;)t = t.destroy(!0); this._head.destroy(), this._head = null } } update (t = performance.now()) { let e; if (t > this.lastTime) { if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) { let i = t - this._lastFrame | 0; if (i < this._minElapsedMS) return; this._lastFrame = t - i % this._minElapsedMS } this.deltaMS = e, this.deltaTime = this.deltaMS * be.targetFPMS; let s = this._head, o = s.next; for (; o;)o = o.emit(this); s.next || this._cancelIfNeeded() } else this.deltaTime = this.deltaMS = this.elapsedMS = 0; this.lastTime = t } get FPS () { return 1e3 / this.elapsedMS } get minFPS () { return 1e3 / this._maxElapsedMS } set minFPS (t) { let e = Math.min(this.maxFPS, t), s = Math.min(Math.max(0, e) / 1e3, be.targetFPMS); this._maxElapsedMS = 1 / s } get maxFPS () { return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0 } set maxFPS (t) { if (t === 0) this._minElapsedMS = 0; else { let e = Math.max(this.minFPS, t); this._minElapsedMS = 1 / (e / 1e3) } } static get shared () { if (!be._shared) { let t = be._shared = new be; t.autoStart = !0, t._protected = !0 } return be._shared } static get system () { if (!be._system) { let t = be._system = new be; t.autoStart = !0, t._protected = !0 } return be._system } }, "_Ticker"); wy.targetFPMS = .06; Bt = wy }); var Nr, Of = m(() => { S(); Eo(); Po(); Nr = class { static init (t) { t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t), Object.defineProperty(this, "ticker", { set (e) { this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, re.LOW) }, get () { return this._ticker } }), this.stop = () => { this._ticker.stop() }, this.start = () => { this._ticker.start() }, this._ticker = null, this.ticker = t.sharedTicker ? Bt.shared : new Bt, t.autoStart && this.start() } static destroy () { if (this._ticker) { let t = this._ticker; this.ticker = null, t.destroy() } } }; c(Nr, "TickerPlugin"); Nr.extension = x.Application }); var __ = m(() => { S(); Ff(); Of(); I.add(Hr); I.add(Nr) }); var kf, ye, al = m(() => { Eo(); Po(); kf = class { constructor() { this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0 } init (t) { this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0 } get pauseUpdate () { return this._pauseUpdate } set pauseUpdate (t) { this._pauseUpdate = t } addTickerListener () { this._tickerAdded || !this.domElement || (Bt.system.add(this._tickerUpdate, this, re.INTERACTION), this._tickerAdded = !0) } removeTickerListener () { this._tickerAdded && (Bt.system.remove(this._tickerUpdate, this), this._tickerAdded = !1) } pointerMoved () { this._didMove = !0 } _update () { if (!this.domElement || this._pauseUpdate) return; if (this._didMove) { this._didMove = !1; return } let t = this.events._rootPointerEvent; this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", { clientX: t.clientX, clientY: t.clientY })) } _tickerUpdate (t) { this._deltaTime += t.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update()) } }; c(kf, "EventsTickerClass"); ye = new kf }); var ve, da = m(() => { ce(); ha(); ve = class extends de { constructor() { super(...arguments), this.client = new V, this.movement = new V, this.offset = new V, this.global = new V, this.screen = new V } get clientX () { return this.client.x } get clientY () { return this.client.y } get x () { return this.clientX } get y () { return this.clientY } get movementX () { return this.movement.x } get movementY () { return this.movement.y } get offsetX () { return this.offset.x } get offsetY () { return this.offset.y } get globalX () { return this.global.x } get globalY () { return this.global.y } get screenX () { return this.screen.x } get screenY () { return this.screen.y } getLocalPosition (t, e, s) { return t.worldTransform.applyInverse(s || this.global, e) } getModifierState (t) { return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t) } initMouseEvent (t, e, s, o, i, n, a, l, h, u, d, f, p, g, b) { throw new Error("Method not implemented.") } }; c(ve, "FederatedMouseEvent") }); var kt, cl = m(() => { da(); kt = class extends ve { constructor() { super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1 } getCoalescedEvents () { return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [] } getPredictedEvents () { throw new Error("getPredictedEvents is not supported!") } }; c(kt, "FederatedPointerEvent") }); var fe, ll = m(() => { da(); fe = class extends ve { constructor() { super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2 } }; c(fe, "FederatedWheelEvent"); fe.DOM_DELTA_PIXEL = 0; fe.DOM_DELTA_LINE = 1; fe.DOM_DELTA_PAGE = 2 }); var Ry, dS, fS, ul, Co, Df = m(() => { Ry = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); ce(); ut(); al(); da(); cl(); ll(); dS = 2048, fS = new V, ul = new V, Co = class { constructor(t) { this.dispatch = new Ry.default, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = { trackingData: {} }, this.eventPool = new Map, this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel) } addEventMapping (t, e) { this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({ fn: e, priority: 0 }), this.mappingTable[t].sort((s, o) => s.priority - o.priority) } dispatchEvent (t, e) { t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, e), this.dispatch.emit(e || t.type, t) } mapEvent (t) { if (!this.rootTarget) return; let e = this.mappingTable[t.type]; if (e) for (let s = 0, o = e.length; s < o; s++)e[s].fn(t); else U(`[EventBoundary]: Event mapping not defined for ${t.type}`) } hitTest (t, e) { ye.pauseUpdate = !0; let o = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", i = this[o](this.rootTarget, this.rootTarget.eventMode, fS.set(t, e), this.hitTestFn, this.hitPruneFn); return i && i[0] } propagate (t, e) { if (!t.target) return; let s = t.composedPath(); t.eventPhase = t.CAPTURING_PHASE; for (let o = 0, i = s.length - 1; o < i; o++)if (t.currentTarget = s[o], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return; if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, e), !(t.propagationStopped || t.propagationImmediatelyStopped)) { t.eventPhase = t.BUBBLING_PHASE; for (let o = s.length - 2; o >= 0; o--)if (t.currentTarget = s[o], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return } } all (t, e, s = this._allInteractiveElements) { if (s.length === 0) return; t.eventPhase = t.BUBBLING_PHASE; let o = Array.isArray(e) ? e : [e]; for (let i = s.length - 1; i >= 0; i--)o.forEach(n => { t.currentTarget = s[i], this.notifyTarget(t, n) }) } propagationPath (t) { let e = [t]; for (let s = 0; s < dS && t !== this.rootTarget && t.parent; s++) { if (!t.parent) throw new Error("Cannot find propagation path to disconnected target"); e.push(t.parent), t = t.parent } return e.reverse(), e } hitTestMoveRecursive (t, e, s, o, i, n = !1) { let a = !1; if (this._interactivePrune(t)) return null; if ((t.eventMode === "dynamic" || e === "dynamic") && (ye.pauseUpdate = !1), t.interactiveChildren && t.children) { let u = t.children; for (let d = u.length - 1; d >= 0; d--) { let f = u[d], p = this.hitTestMoveRecursive(f, this._isInteractive(e) ? e : f.eventMode, s, o, i, n || i(t, s)); if (p) { if (p.length > 0 && !p[p.length - 1].parent) continue; let g = t.isInteractive(); (p.length > 0 || g) && (g && this._allInteractiveElements.push(t), p.push(t)), this._hitElements.length === 0 && (this._hitElements = p), a = !0 } } } let l = this._isInteractive(e), h = t.isInteractive(); return h && h && this._allInteractiveElements.push(t), n || this._hitElements.length > 0 ? null : a ? this._hitElements : l && !i(t, s) && o(t, s) ? h ? [t] : [] : null } hitTestRecursive (t, e, s, o, i) { if (this._interactivePrune(t) || i(t, s)) return null; if ((t.eventMode === "dynamic" || e === "dynamic") && (ye.pauseUpdate = !1), t.interactiveChildren && t.children) { let l = t.children, h = s; for (let u = l.length - 1; u >= 0; u--) { let d = l[u], f = this.hitTestRecursive(d, this._isInteractive(e) ? e : d.eventMode, h, o, i); if (f) { if (f.length > 0 && !f[f.length - 1].parent) continue; let p = t.isInteractive(); return (f.length > 0 || p) && f.push(t), f } } } let n = this._isInteractive(e), a = t.isInteractive(); return n && o(t, s) ? a ? [t] : [] : null } _isInteractive (t) { return t === "static" || t === "dynamic" } _interactivePrune (t) { return !t || !t.visible || !t.renderable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren } hitPruneFn (t, e) { if (t.hitArea && (t.worldTransform.applyInverse(e, ul), !t.hitArea.contains(ul.x, ul.y))) return !0; if (t.effects && t.effects.length) for (let s = 0; s < t.effects.length; s++) { let o = t.effects[s]; if (o.containsPoint && !o.containsPoint(e, this.hitTestFn)) return !0 } return !1 } hitTestFn (t, e) { return t.hitArea ? !0 : t?.containsPoint ? (t.worldTransform.applyInverse(e, ul), t.containsPoint(ul)) : !1 } notifyTarget (t, e) { e = e ?? t.type; let s = `on${e}`; t.currentTarget[s]?.(t); let o = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e; this._notifyListeners(t, o), t.eventPhase === t.AT_TARGET && this._notifyListeners(t, e) } mapPointerDown (t) { if (!(t instanceof kt)) { U("EventBoundary cannot map a non-pointer event as a pointer event"); return } let e = this.createPointerEvent(t); if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch") this.dispatchEvent(e, "touchstart"); else if (e.pointerType === "mouse" || e.pointerType === "pen") { let o = e.button === 2; this.dispatchEvent(e, o ? "rightdown" : "mousedown") } let s = this.trackingData(t.pointerId); s.pressTargetsByButton[t.button] = e.composedPath(), this.freeEvent(e) } mapPointerMove (t) { if (!(t instanceof kt)) { U("EventBoundary cannot map a non-pointer event as a pointer event"); return } this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0; let e = this.createPointerEvent(t); this._isPointerMoveEvent = !1; let s = e.pointerType === "mouse" || e.pointerType === "pen", o = this.trackingData(t.pointerId), i = this.findMountedTarget(o.overTargets); if (o.overTargets?.length > 0 && i !== e.target) { let l = t.type === "mousemove" ? "mouseout" : "pointerout", h = this.createPointerEvent(t, l, i); if (this.dispatchEvent(h, "pointerout"), s && this.dispatchEvent(h, "mouseout"), !e.composedPath().includes(i)) { let u = this.createPointerEvent(t, "pointerleave", i); for (u.eventPhase = u.AT_TARGET; u.target && !e.composedPath().includes(u.target);)u.currentTarget = u.target, this.notifyTarget(u), s && this.notifyTarget(u, "mouseleave"), u.target = u.target.parent; this.freeEvent(u) } this.freeEvent(h) } if (i !== e.target) { let l = t.type === "mousemove" ? "mouseover" : "pointerover", h = this.clonePointerEvent(e, l); this.dispatchEvent(h, "pointerover"), s && this.dispatchEvent(h, "mouseover"); let u = i?.parent; for (; u && u !== this.rootTarget.parent && u !== e.target;)u = u.parent; if (!u || u === this.rootTarget.parent) { let f = this.clonePointerEvent(e, "pointerenter"); for (f.eventPhase = f.AT_TARGET; f.target && f.target !== i && f.target !== this.rootTarget.parent;)f.currentTarget = f.target, this.notifyTarget(f), s && this.notifyTarget(f, "mouseenter"), f.target = f.target.parent; this.freeEvent(f) } this.freeEvent(h) } let n = [], a = this.enableGlobalMoveEvents ?? !0; this.moveOnAll ? n.push("pointermove") : this.dispatchEvent(e, "pointermove"), a && n.push("globalpointermove"), e.pointerType === "touch" && (this.moveOnAll ? n.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), a && n.push("globaltouchmove")), s && (this.moveOnAll ? n.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), a && n.push("globalmousemove"), this.cursor = e.target?.cursor), n.length > 0 && this.all(e, n), this._allInteractiveElements.length = 0, this._hitElements.length = 0, o.overTargets = e.composedPath(), this.freeEvent(e) } mapPointerOver (t) { if (!(t instanceof kt)) { U("EventBoundary cannot map a non-pointer event as a pointer event"); return } let e = this.trackingData(t.pointerId), s = this.createPointerEvent(t), o = s.pointerType === "mouse" || s.pointerType === "pen"; this.dispatchEvent(s, "pointerover"), o && this.dispatchEvent(s, "mouseover"), s.pointerType === "mouse" && (this.cursor = s.target?.cursor); let i = this.clonePointerEvent(s, "pointerenter"); for (i.eventPhase = i.AT_TARGET; i.target && i.target !== this.rootTarget.parent;)i.currentTarget = i.target, this.notifyTarget(i), o && this.notifyTarget(i, "mouseenter"), i.target = i.target.parent; e.overTargets = s.composedPath(), this.freeEvent(s), this.freeEvent(i) } mapPointerOut (t) { if (!(t instanceof kt)) { U("EventBoundary cannot map a non-pointer event as a pointer event"); return } let e = this.trackingData(t.pointerId); if (e.overTargets) { let s = t.pointerType === "mouse" || t.pointerType === "pen", o = this.findMountedTarget(e.overTargets), i = this.createPointerEvent(t, "pointerout", o); this.dispatchEvent(i), s && this.dispatchEvent(i, "mouseout"); let n = this.createPointerEvent(t, "pointerleave", o); for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent;)n.currentTarget = n.target, this.notifyTarget(n), s && this.notifyTarget(n, "mouseleave"), n.target = n.target.parent; e.overTargets = null, this.freeEvent(i), this.freeEvent(n) } this.cursor = null } mapPointerUp (t) { if (!(t instanceof kt)) { U("EventBoundary cannot map a non-pointer event as a pointer event"); return } let e = performance.now(), s = this.createPointerEvent(t); if (this.dispatchEvent(s, "pointerup"), s.pointerType === "touch") this.dispatchEvent(s, "touchend"); else if (s.pointerType === "mouse" || s.pointerType === "pen") { let a = s.button === 2; this.dispatchEvent(s, a ? "rightup" : "mouseup") } let o = this.trackingData(t.pointerId), i = this.findMountedTarget(o.pressTargetsByButton[t.button]), n = i; if (i && !s.composedPath().includes(i)) { let a = i; for (; a && !s.composedPath().includes(a);) { if (s.currentTarget = a, this.notifyTarget(s, "pointerupoutside"), s.pointerType === "touch") this.notifyTarget(s, "touchendoutside"); else if (s.pointerType === "mouse" || s.pointerType === "pen") { let l = s.button === 2; this.notifyTarget(s, l ? "rightupoutside" : "mouseupoutside") } a = a.parent } delete o.pressTargetsByButton[t.button], n = a } if (n) { let a = this.clonePointerEvent(s, "click"); a.target = n, a.path = null, o.clicksByButton[t.button] || (o.clicksByButton[t.button] = { clickCount: 0, target: a.target, timeStamp: e }); let l = o.clicksByButton[t.button]; if (l.target === a.target && e - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1, l.target = a.target, l.timeStamp = e, a.detail = l.clickCount, a.pointerType === "mouse") { let h = a.button === 2; this.dispatchEvent(a, h ? "rightclick" : "click") } else a.pointerType === "touch" && this.dispatchEvent(a, "tap"); this.dispatchEvent(a, "pointertap"), this.freeEvent(a) } this.freeEvent(s) } mapPointerUpOutside (t) { if (!(t instanceof kt)) { U("EventBoundary cannot map a non-pointer event as a pointer event"); return } let e = this.trackingData(t.pointerId), s = this.findMountedTarget(e.pressTargetsByButton[t.button]), o = this.createPointerEvent(t); if (s) { let i = s; for (; i;)o.currentTarget = i, this.notifyTarget(o, "pointerupoutside"), o.pointerType === "touch" ? this.notifyTarget(o, "touchendoutside") : (o.pointerType === "mouse" || o.pointerType === "pen") && this.notifyTarget(o, o.button === 2 ? "rightupoutside" : "mouseupoutside"), i = i.parent; delete e.pressTargetsByButton[t.button] } this.freeEvent(o) } mapWheel (t) { if (!(t instanceof fe)) { U("EventBoundary cannot map a non-wheel event as a wheel event"); return } let e = this.createWheelEvent(t); this.dispatchEvent(e), this.freeEvent(e) } findMountedTarget (t) { if (!t) return null; let e = t[0]; for (let s = 1; s < t.length && t[s].parent === e; s++)e = t[s]; return e } createPointerEvent (t, e, s) { let o = this.allocateEvent(kt); return this.copyPointerData(t, o), this.copyMouseData(t, o), this.copyData(t, o), o.nativeEvent = t.nativeEvent, o.originalEvent = t, o.target = s ?? this.hitTest(o.global.x, o.global.y) ?? this._hitElements[0], typeof e == "string" && (o.type = e), o } createWheelEvent (t) { let e = this.allocateEvent(fe); return this.copyWheelData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.nativeEvent = t.nativeEvent, e.originalEvent = t, e.target = this.hitTest(e.global.x, e.global.y), e } clonePointerEvent (t, e) { let s = this.allocateEvent(kt); return s.nativeEvent = t.nativeEvent, s.originalEvent = t.originalEvent, this.copyPointerData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.target = t.target, s.path = t.composedPath().slice(), s.type = e ?? s.type, s } copyWheelData (t, e) { e.deltaMode = t.deltaMode, e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ } copyPointerData (t, e) { t instanceof kt && e instanceof kt && (e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist) } copyMouseData (t, e) { t instanceof ve && e instanceof ve && (e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.copyFrom(t.client), e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.copyFrom(t.movement), e.screen.copyFrom(t.screen), e.shiftKey = t.shiftKey, e.global.copyFrom(t.global)) } copyData (t, e) { e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.detail = t.detail, e.view = t.view, e.which = t.which, e.layer.copyFrom(t.layer), e.page.copyFrom(t.page) } trackingData (t) { return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }), this.mappingState.trackingData[t] } allocateEvent (t) { this.eventPool.has(t) || this.eventPool.set(t, []); let e = this.eventPool.get(t).pop() || new t(this); return e.eventPhase = e.NONE, e.currentTarget = null, e.path = null, e.target = null, e } freeEvent (t) { if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!"); let e = t.constructor; this.eventPool.has(e) || this.eventPool.set(e, []), this.eventPool.get(e).push(t) } _notifyListeners (t, e) { let s = t.currentTarget._events[e]; if (s && t.currentTarget.isInteractive()) if ("fn" in s) s.once && t.currentTarget.removeListener(e, s.fn, void 0, !0), s.fn.call(s.context, t); else for (let o = 0, i = s.length; o < i && !t.propagationImmediatelyStopped; o++)s[o].once && t.currentTarget.removeListener(e, s[o].fn, void 0, !0), s[o].fn.call(s[o].context, t) } }; c(Co, "EventBoundary") }); var pS, mS, y_, Ti, hl = m(() => { S(); Df(); al(); cl(); ll(); pS = 1, mS = { touchstart: "pointerdown", touchend: "pointerup", touchendoutside: "pointerupoutside", touchmove: "pointermove", touchcancel: "pointercancel" }, y_ = c(class b_ { constructor(t) { this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new Co(null), ye.init(this), this.autoPreventDefault = !0, this._eventsAdded = !1, this._rootPointerEvent = new kt(null), this._rootWheelEvent = new fe(null), this.cursorStyles = { default: "inherit", pointer: "pointer" }, this.features = new Proxy({ ...b_.defaultEventFeatures }, { set: (e, s, o) => (s === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = o), e[s] = o, !0) }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this) } static get defaultEventMode () { return this._defaultEventMode } init (t) { let { canvas: e, resolution: s } = this.renderer; this.setTargetElement(e), this.resolution = s, b_._defaultEventMode = t.eventMode ?? "passive", Object.assign(this.features, t.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove } resolutionChange (t) { this.resolution = t } destroy () { this.setTargetElement(null), this.renderer = null, this._currentCursor = null } setCursor (t) { t = t || "default"; let e = !0; if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = !1), this._currentCursor === t) return; this._currentCursor = t; let s = this.cursorStyles[t]; if (s) switch (typeof s) { case "string": e && (this.domElement.style.cursor = s); break; case "function": s(t); break; case "object": e && Object.assign(this.domElement.style, s); break } else e && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t) } get pointer () { return this._rootPointerEvent } _onPointerDown (t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; let e = this._normalizeToPointerData(t); this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault(); for (let s = 0, o = e.length; s < o; s++) { let i = e[s], n = this._bootstrapEvent(this._rootPointerEvent, i); this.rootBoundary.mapEvent(n) } this.setCursor(this.rootBoundary.cursor) } _onPointerMove (t) { if (!this.features.move) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, ye.pointerMoved(); let e = this._normalizeToPointerData(t); for (let s = 0, o = e.length; s < o; s++) { let i = this._bootstrapEvent(this._rootPointerEvent, e[s]); this.rootBoundary.mapEvent(i) } this.setCursor(this.rootBoundary.cursor) } _onPointerUp (t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; let e = t.target; t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]); let s = e !== this.domElement ? "outside" : "", o = this._normalizeToPointerData(t); for (let i = 0, n = o.length; i < n; i++) { let a = this._bootstrapEvent(this._rootPointerEvent, o[i]); a.type += s, this.rootBoundary.mapEvent(a) } this.setCursor(this.rootBoundary.cursor) } _onPointerOverOut (t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; let e = this._normalizeToPointerData(t); for (let s = 0, o = e.length; s < o; s++) { let i = this._bootstrapEvent(this._rootPointerEvent, e[s]); this.rootBoundary.mapEvent(i) } this.setCursor(this.rootBoundary.cursor) } onWheel (t) { if (!this.features.wheel) return; let e = this.normalizeWheelEvent(t); this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(e) } setTargetElement (t) { this._removeEvents(), this.domElement = t, ye.domElement = t, this._addEvents() } _addEvents () { if (this._eventsAdded || !this.domElement) return; ye.addTickerListener(); let t = this.domElement.style; t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0), this.domElement.addEventListener("pointerdown", this._onPointerDown, !0), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0), globalThis.addEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0), this.domElement.addEventListener("mousedown", this._onPointerDown, !0), this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0), globalThis.addEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, !0), this.domElement.addEventListener("touchend", this._onPointerUp, !0), this.domElement.addEventListener("touchmove", this._onPointerMove, !0))), this.domElement.addEventListener("wheel", this.onWheel, { passive: !0, capture: !0 }), this._eventsAdded = !0 } _removeEvents () { if (!this._eventsAdded || !this.domElement) return; ye.removeTickerListener(); let t = this.domElement.style; t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0), this.domElement.removeEventListener("mousedown", this._onPointerDown, !0), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0), this.domElement.removeEventListener("touchend", this._onPointerUp, !0), this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this._eventsAdded = !1 } mapPositionToPoint (t, e, s) { let o = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : { x: 0, y: 0, width: this.domElement.width, height: this.domElement.height, left: 0, top: 0 }, i = 1 / this.resolution; t.x = (e - o.left) * (this.domElement.width / o.width) * i, t.y = (s - o.top) * (this.domElement.height / o.height) * i } _normalizeToPointerData (t) { let e = []; if (this.supportsTouchEvents && t instanceof TouchEvent) for (let s = 0, o = t.changedTouches.length; s < o; s++) { let i = t.changedTouches[s]; typeof i.button > "u" && (i.button = 0), typeof i.buttons > "u" && (i.buttons = 1), typeof i.isPrimary > "u" && (i.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof i.width > "u" && (i.width = i.radiusX || 1), typeof i.height > "u" && (i.height = i.radiusY || 1), typeof i.tiltX > "u" && (i.tiltX = 0), typeof i.tiltY > "u" && (i.tiltY = 0), typeof i.pointerType > "u" && (i.pointerType = "touch"), typeof i.pointerId > "u" && (i.pointerId = i.identifier || 0), typeof i.pressure > "u" && (i.pressure = i.force || .5), typeof i.twist > "u" && (i.twist = 0), typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0), typeof i.layerX > "u" && (i.layerX = i.offsetX = i.clientX), typeof i.layerY > "u" && (i.layerY = i.offsetY = i.clientY), i.isNormalized = !0, i.type = t.type, e.push(i) } else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) { let s = t; typeof s.isPrimary > "u" && (s.isPrimary = !0), typeof s.width > "u" && (s.width = 1), typeof s.height > "u" && (s.height = 1), typeof s.tiltX > "u" && (s.tiltX = 0), typeof s.tiltY > "u" && (s.tiltY = 0), typeof s.pointerType > "u" && (s.pointerType = "mouse"), typeof s.pointerId > "u" && (s.pointerId = pS), typeof s.pressure > "u" && (s.pressure = .5), typeof s.twist > "u" && (s.twist = 0), typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0), s.isNormalized = !0, e.push(s) } else e.push(t); return e } normalizeWheelEvent (t) { let e = this._rootWheelEvent; return this._transferMouseData(e, t), e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ, e.deltaMode = t.deltaMode, this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.nativeEvent = t, e.type = t.type, e } _bootstrapEvent (t, e) { return t.originalEvent = null, t.nativeEvent = e, t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist, this._transferMouseData(t, e), this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = e.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = mS[t.type] || t.type), t } _transferMouseData (t, e) { t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.x = e.clientX, t.client.y = e.clientY, t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.x = e.movementX, t.movement.y = e.movementY, t.page.x = e.pageX, t.page.y = e.pageY, t.relatedTarget = null, t.shiftKey = e.shiftKey } }, "_EventSystem"); y_.extension = { name: "events", type: [x.WebGLSystem, x.CanvasSystem, x.WebGPUSystem], priority: -1 }; y_.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 }; Ti = y_ }); var dl, Lf = m(() => { hl(); ha(); dl = { onclick: null, onmousedown: null, onmouseenter: null, onmouseleave: null, onmousemove: null, onglobalmousemove: null, onmouseout: null, onmouseover: null, onmouseup: null, onmouseupoutside: null, onpointercancel: null, onpointerdown: null, onpointerenter: null, onpointerleave: null, onpointermove: null, onglobalpointermove: null, onpointerout: null, onpointerover: null, onpointertap: null, onpointerup: null, onpointerupoutside: null, onrightclick: null, onrightdown: null, onrightup: null, onrightupoutside: null, ontap: null, ontouchcancel: null, ontouchend: null, ontouchendoutside: null, ontouchmove: null, onglobaltouchmove: null, ontouchstart: null, onwheel: null, get interactive () { return this.eventMode === "dynamic" || this.eventMode === "static" }, set interactive (r) { this.eventMode = r ? "static" : "passive" }, _internalEventMode: void 0, get eventMode () { return this._internalEventMode ?? Ti.defaultEventMode }, set eventMode (r) { this._internalEventMode = r }, isInteractive () { return this.eventMode === "static" || this.eventMode === "dynamic" }, interactiveChildren: !0, hitArea: null, addEventListener (r, t, e) { let s = typeof e == "boolean" && e || typeof e == "object" && e.capture, o = typeof e == "object" ? e.signal : void 0, i = typeof e == "object" ? e.once === !0 : !1, n = typeof t == "function" ? void 0 : t; r = s ? `${r}capture` : r; let a = typeof t == "function" ? t : t.handleEvent, l = this; o && o.addEventListener("abort", () => { l.off(r, a, n) }), i ? l.once(r, a, n) : l.on(r, a, n) }, removeEventListener (r, t, e) { let s = typeof e == "boolean" && e || typeof e == "object" && e.capture, o = typeof t == "function" ? void 0 : t; r = s ? `${r}capture` : r, t = typeof t == "function" ? t : t.handleEvent, this.off(r, t, o) }, dispatchEvent (r) { if (!(r instanceof de)) throw new Error("Container cannot propagate events outside of the Federated Events API"); return r.defaultPrevented = !1, r.path = null, r.target = this, r.manager.dispatchEvent(r), !r.defaultPrevented } } }); var My = m(() => { S(); It(); hl(); Lf(); I.add(Ti); N.mixin(dl) }); var mt, pe = m(() => { "use strict"; mt = (r => (r[r.Low = 0] = "Low", r[r.Normal = 1] = "Normal", r[r.High = 2] = "High", r))(mt || {}) }); var fl, Hf = m(() => { "use strict"; fl = { createCanvas: (r, t) => { let e = document.createElement("canvas"); return e.width = r, e.height = t, e }, getCanvasRenderingContext2D: () => CanvasRenderingContext2D, getWebGLRenderingContext: () => WebGLRenderingContext, getNavigator: () => navigator, getBaseUrl: () => document.baseURI ?? window.location.href, getFontFaceSet: () => document.fonts, fetch: (r, t) => fetch(r, t), parseXML: r => new DOMParser().parseFromString(r, "text/xml") } }); var Gy, k, ft = m(() => { Hf(); Gy = fl, k = { get () { return Gy }, set (r) { Gy = r } } }); function $e (r) { if (typeof r != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(r)}`) } function pl (r) { return r.split("?")[0].split("#")[0] } function xS (r) { return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } function gS (r, t, e) { return r.replace(new RegExp(xS(t), "g"), e) } function _S (r, t) { let e = "", s = 0, o = -1, i = 0, n = -1; for (let a = 0; a <= r.length; ++a) { if (a < r.length) n = r.charCodeAt(a); else { if (n === 47) break; n = 47 } if (n === 47) { if (!(o === a - 1 || i === 1)) if (o !== a - 1 && i === 2) { if (e.length < 2 || s !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) { if (e.length > 2) { let l = e.lastIndexOf("/"); if (l !== e.length - 1) { l === -1 ? (e = "", s = 0) : (e = e.slice(0, l), s = e.length - 1 - e.lastIndexOf("/")), o = a, i = 0; continue } } else if (e.length === 2 || e.length === 1) { e = "", s = 0, o = a, i = 0; continue } } t && (e.length > 0 ? e += "/.." : e = "..", s = 2) } else e.length > 0 ? e += `/${r.slice(o + 1, a)}` : e = r.slice(o + 1, a), s = a - o - 1; o = a, i = 0 } else n === 46 && i !== -1 ? ++i : i = -1 } return e } var At, Wr = m(() => { ft(); c($e, "assertPath"); c(pl, "removeUrlParams"); c(xS, "escapeRegExp"); c(gS, "replaceAll"); c(_S, "normalizeStringPosix"); At = { toPosix (r) { return gS(r, "\\", "/") }, isUrl (r) { return /^https?:/.test(this.toPosix(r)) }, isDataUrl (r) { return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(r) }, isBlobUrl (r) { return r.startsWith("blob:") }, hasProtocol (r) { return /^[^/:]+:/.test(this.toPosix(r)) }, getProtocol (r) { $e(r), r = this.toPosix(r); let t = /^file:\/\/\//.exec(r); if (t) return t[0]; let e = /^[^/:]+:\/{0,2}/.exec(r); return e ? e[0] : "" }, toAbsolute (r, t, e) { if ($e(r), this.isDataUrl(r) || this.isBlobUrl(r)) return r; let s = pl(this.toPosix(t ?? k.get().getBaseUrl())), o = pl(this.toPosix(e ?? this.rootname(s))); return r = this.toPosix(r), r.startsWith("/") ? At.join(o, r.slice(1)) : this.isAbsolute(r) ? r : this.join(s, r) }, normalize (r) { if ($e(r), r.length === 0) return "."; if (this.isDataUrl(r) || this.isBlobUrl(r)) return r; r = this.toPosix(r); let t = "", e = r.startsWith("/"); this.hasProtocol(r) && (t = this.rootname(r), r = r.slice(t.length)); let s = r.endsWith("/"); return r = _S(r, !1), r.length > 0 && s && (r += "/"), e ? `/${r}` : t + r }, isAbsolute (r) { return $e(r), r = this.toPosix(r), this.hasProtocol(r) ? !0 : r.startsWith("/") }, join (...r) { if (r.length === 0) return "."; let t; for (let e = 0; e < r.length; ++e) { let s = r[e]; if ($e(s), s.length > 0) if (t === void 0) t = s; else { let o = r[e - 1] ?? ""; this.joinExtensions.includes(this.extname(o).toLowerCase()) ? t += `/../${s}` : t += `/${s}` } } return t === void 0 ? "." : this.normalize(t) }, dirname (r) { if ($e(r), r.length === 0) return "."; r = this.toPosix(r); let t = r.charCodeAt(0), e = t === 47, s = -1, o = !0, i = this.getProtocol(r), n = r; r = r.slice(i.length); for (let a = r.length - 1; a >= 1; --a)if (t = r.charCodeAt(a), t === 47) { if (!o) { s = a; break } } else o = !1; return s === -1 ? e ? "/" : this.isUrl(n) ? i + r : i : e && s === 1 ? "//" : i + r.slice(0, s) }, rootname (r) { $e(r), r = this.toPosix(r); let t = ""; if (r.startsWith("/") ? t = "/" : t = this.getProtocol(r), this.isUrl(r)) { let e = r.indexOf("/", t.length); e !== -1 ? t = r.slice(0, e) : t = r, t.endsWith("/") || (t += "/") } return t }, basename (r, t) { $e(r), t && $e(t), r = pl(this.toPosix(r)); let e = 0, s = -1, o = !0, i; if (t !== void 0 && t.length > 0 && t.length <= r.length) { if (t.length === r.length && t === r) return ""; let n = t.length - 1, a = -1; for (i = r.length - 1; i >= 0; --i) { let l = r.charCodeAt(i); if (l === 47) { if (!o) { e = i + 1; break } } else a === -1 && (o = !1, a = i + 1), n >= 0 && (l === t.charCodeAt(n) ? --n === -1 && (s = i) : (n = -1, s = a)) } return e === s ? s = a : s === -1 && (s = r.length), r.slice(e, s) } for (i = r.length - 1; i >= 0; --i)if (r.charCodeAt(i) === 47) { if (!o) { e = i + 1; break } } else s === -1 && (o = !1, s = i + 1); return s === -1 ? "" : r.slice(e, s) }, extname (r) { $e(r), r = pl(this.toPosix(r)); let t = -1, e = 0, s = -1, o = !0, i = 0; for (let n = r.length - 1; n >= 0; --n) { let a = r.charCodeAt(n); if (a === 47) { if (!o) { e = n + 1; break } continue } s === -1 && (o = !1, s = n + 1), a === 46 ? t === -1 ? t = n : i !== 1 && (i = 1) : t !== -1 && (i = -1) } return t === -1 || s === -1 || i === 0 || i === 1 && t === s - 1 && t === e + 1 ? "" : r.slice(t, s) }, parse (r) { $e(r); let t = { root: "", dir: "", base: "", ext: "", name: "" }; if (r.length === 0) return t; r = pl(this.toPosix(r)); let e = r.charCodeAt(0), s = this.isAbsolute(r), o, i = ""; t.root = this.rootname(r), s || this.hasProtocol(r) ? o = 1 : o = 0; let n = -1, a = 0, l = -1, h = !0, u = r.length - 1, d = 0; for (; u >= o; --u) { if (e = r.charCodeAt(u), e === 47) { if (!h) { a = u + 1; break } continue } l === -1 && (h = !1, l = u + 1), e === 46 ? n === -1 ? n = u : d !== 1 && (d = 1) : n !== -1 && (d = -1) } return n === -1 || l === -1 || d === 0 || d === 1 && n === l - 1 && n === a + 1 ? l !== -1 && (a === 0 && s ? t.base = t.name = r.slice(1, l) : t.base = t.name = r.slice(a, l)) : (a === 0 && s ? (t.name = r.slice(1, n), t.base = r.slice(1, l)) : (t.name = r.slice(a, n), t.base = r.slice(a, l)), t.ext = r.slice(n, l)), t.dir = this.dirname(r), i && (t.dir = i + t.dir), t }, sep: "/", delimiter: ":", joinExtensions: [".html"] } }); var Xt, Ei = m(() => { "use strict"; Xt = c((r, t, e = !1) => (Array.isArray(r) || (r = [r]), t ? r.map(s => typeof s == "string" || e ? t(s) : s) : r), "convertToList") }); function Uy (r, t, e, s, o) { let i = t[e]; for (let n = 0; n < i.length; n++) { let a = i[n]; e < t.length - 1 ? Uy(r.replace(s[e], a), t, e + 1, s, o) : o.push(r.replace(s[e], a)) } } function ml (r) { let t = /\{(.*?)\}/g, e = r.match(t), s = []; if (e) { let o = []; e.forEach(i => { let n = i.substring(1, i.length - 1).split(","); o.push(n) }), Uy(r, o, 0, e, s) } else s.push(r); return s } var Nf = m(() => { "use strict"; c(Uy, "processX"); c(ml, "createStringVariations") }); var fr, fa = m(() => { "use strict"; fr = c(r => !Array.isArray(r), "isSingleItem") }); function Wf (r) { return r.split(".").pop().split("?").shift().split("#").shift() } var Dt, Xr = m(() => { ut(); Wr(); Ei(); Nf(); fa(); Dt = class { constructor() { this._defaultBundleIdentifierOptions = { connector: "-", createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`, extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "") }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {} } setBundleIdentifier (t) { if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly") } prefer (...t) { t.forEach(e => { this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params)) }), this._resolverHash = {} } set basePath (t) { this._basePath = t } get basePath () { return this._basePath } set rootPath (t) { this._rootPath = t } get rootPath () { return this._rootPath } get parsers () { return this._parsers } reset () { this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null } setDefaultSearchParams (t) { if (typeof t == "string") this._defaultSearchParams = t; else { let e = t; this._defaultSearchParams = Object.keys(e).map(s => `${encodeURIComponent(s)}=${encodeURIComponent(e[s])}`).join("&") } } getAlias (t) { let { alias: e, src: s } = t; return Xt(e || s, i => typeof i == "string" ? i : Array.isArray(i) ? i.map(n => n?.src ?? n) : i?.src ? i.src : i, !0) } addManifest (t) { this._manifest && U("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach(e => { this.addBundle(e.name, e.assets) }) } addBundle (t, e) { let s = [], o = e; Array.isArray(e) || (o = Object.entries(e).map(([i, n]) => typeof n == "string" || Array.isArray(n) ? { alias: i, src: n } : { alias: i, ...n })), o.forEach(i => { let n = i.src, a = i.alias, l; if (typeof a == "string") { let h = this._createBundleAssetId(t, a); s.push(h), l = [a, h] } else { let h = a.map(u => this._createBundleAssetId(t, u)); s.push(...h), l = [...a, ...h] } this.add({ ...i, alias: l, src: n }) }), this._bundles[t] = s } add (t) { let e = []; Array.isArray(t) ? e.push(...t) : e.push(t); let s; s = c(i => { this.hasKey(i) && U(`[Resolver] already has key: ${i} overwriting`) }, "keyCheck"), Xt(e).forEach(i => { let { src: n } = i, { data: a, format: l, loadParser: h } = i, u = Xt(n).map(p => typeof p == "string" ? ml(p) : Array.isArray(p) ? p : [p]), d = this.getAlias(i); Array.isArray(d) ? d.forEach(s) : s(d); let f = []; u.forEach(p => { p.forEach(g => { let b = {}; if (typeof g != "object") { b.src = g; for (let _ = 0; _ < this._parsers.length; _++) { let y = this._parsers[_]; if (y.test(g)) { b = y.parse(g); break } } } else a = g.data ?? a, l = g.format ?? l, h = g.loadParser ?? h, b = { ...b, ...g }; if (!d) throw new Error(`[Resolver] alias is undefined for this asset: ${b.src}`); b = this._buildResolvedAsset(b, { aliases: d, data: a, format: l, loadParser: h }), f.push(b) }) }), d.forEach(p => { this._assetMap[p] = f }) }) } resolveBundle (t) { let e = fr(t); t = Xt(t); let s = {}; return t.forEach(o => { let i = this._bundles[o]; if (i) { let n = this.resolve(i), a = {}; for (let l in n) { let h = n[l]; a[this._extractAssetIdFromBundle(o, l)] = h } s[o] = a } }), e ? s[t[0]] : s } resolveUrl (t) { let e = this.resolve(t); if (typeof t != "string") { let s = {}; for (let o in e) s[o] = e[o].src; return s } return e.src } resolve (t) { let e = fr(t); t = Xt(t); let s = {}; return t.forEach(o => { if (!this._resolverHash[o]) if (this._assetMap[o]) { let i = this._assetMap[o], n = this._getPreferredOrder(i); n?.priority.forEach(a => { n.params[a].forEach(l => { let h = i.filter(u => u[a] ? u[a] === l : !1); h.length && (i = h) }) }), this._resolverHash[o] = i[0] } else this._resolverHash[o] = this._buildResolvedAsset({ alias: [o], src: o }, {}); s[o] = this._resolverHash[o] }), e ? s[t[0]] : s } hasKey (t) { return !!this._assetMap[t] } hasBundle (t) { return !!this._bundles[t] } _getPreferredOrder (t) { for (let e = 0; e < t.length; e++) { let s = t[0], o = this._preferredOrder.find(i => i.params.format.includes(s.format)); if (o) return o } return this._preferredOrder[0] } _appendDefaultSearchParams (t) { if (!this._defaultSearchParams) return t; let e = /\?/.test(t) ? "&" : "?"; return `${t}${e}${this._defaultSearchParams}` } _buildResolvedAsset (t, e) { let { aliases: s, data: o, loadParser: i, format: n } = e; return (this._basePath || this._rootPath) && (t.src = At.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = s ?? t.alias ?? [t.src], t.src = this._appendDefaultSearchParams(t.src), t.data = { ...o || {}, ...t.data }, t.loadParser = i ?? t.loadParser, t.format = n ?? t.format ?? Wf(t.src), t } }; c(Dt, "Resolver"); Dt.RETINA_PREFIX = /@([0-9\.]+)x/; c(Wf, "getUrlExtension") }); var Bo, xl = m(() => { "use strict"; Bo = c((r, t) => { let e = t.split("?")[1]; return e && (r += `?${e}`), r }, "copySearchParams") }); function bS () { for (let r = 0; r < 16; r++) { let t = []; v_.push(t); for (let e = 0; e < 16; e++) { let s = Xf(Pi[r] * Pi[e] + Bi[r] * Ci[e]), o = Xf(Ci[r] * Pi[e] + Ai[r] * Ci[e]), i = Xf(Pi[r] * Bi[e] + Bi[r] * Ai[e]), n = Xf(Ci[r] * Bi[e] + Ai[r] * Ai[e]); for (let a = 0; a < 16; a++)if (Pi[a] === s && Ci[a] === o && Bi[a] === i && Ai[a] === n) { t.push(a); break } } } for (let r = 0; r < 16; r++) { let t = new B; t.set(Pi[r], Ci[r], Bi[r], Ai[r], 0, 0), Fy.push(t) } } var Pi, Ci, Bi, Ai, v_, Fy, Xf, Q, gl = m(() => { ot(); Pi = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Ci = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], Bi = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Ai = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], v_ = [], Fy = [], Xf = Math.sign; c(bS, "init"); bS(); Q = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: r => Pi[r], uY: r => Ci[r], vX: r => Bi[r], vY: r => Ai[r], inv: r => r & 8 ? r & 15 : -r & 7, add: (r, t) => v_[r][t], sub: (r, t) => v_[r][Q.inv(t)], rotate180: r => r ^ 4, isVertical: r => (r & 3) === 2, byDirection: (r, t) => Math.abs(r) * 2 <= Math.abs(t) ? t >= 0 ? Q.S : Q.N : Math.abs(t) * 2 <= Math.abs(r) ? r > 0 ? Q.E : Q.W : t > 0 ? r > 0 ? Q.SE : Q.SW : r > 0 ? Q.NE : Q.NW, matrixAppendRotationInv: (r, t, e = 0, s = 0) => { let o = Fy[Q.inv(t)]; o.tx = e, o.ty = s, r.append(o) } } }); var pa, zf = m(() => { "use strict"; pa = c(() => { }, "NOOP") }); function Fe (r) { return r += r === 0 ? 1 : 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1 } function ma (r) { return !(r & r - 1) && !!r } function S_ (r) { let t = (r > 65535 ? 1 : 0) << 4; r >>>= t; let e = (r > 255 ? 1 : 0) << 3; return r >>>= e, t |= e, e = (r > 15 ? 1 : 0) << 2, r >>>= e, t |= e, e = (r > 3 ? 1 : 0) << 1, r >>>= e, t |= e, t | r >> 1 } var wi = m(() => { "use strict"; c(Fe, "nextPow2"); c(ma, "isPow2"); c(S_, "log2") }); function me (r) { let t = {}; for (let e in r) r[e] !== void 0 && (t[e] = r[e]); return t } var Ri = m(() => { "use strict"; c(me, "definedProps") }); function yS (r) { let t = Iy[r]; return t === void 0 && (Iy[r] = Z("resource")), t } var Oy, Iy, ky, _l, Vf = m(() => { Oy = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); Wt(); lt(); Iy = Object.create(null); c(yS, "createResourceIdFromString"); ky = c(class Dy extends Oy.default { constructor(t = {}) { super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, t = { ...Dy.defaultOptions, ...t }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1 } set addressMode (t) { this.addressModeU = t, this.addressModeV = t, this.addressModeW = t } get addressMode () { return this.addressModeU } set wrapMode (t) { w(G, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t } get wrapMode () { return this.addressMode } set scaleMode (t) { this.magFilter = t, this.minFilter = t, this.mipmapFilter = t } get scaleMode () { return this.magFilter } set maxAnisotropy (t) { this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear") } get maxAnisotropy () { return this._maxAnisotropy } get _resourceId () { return this._sharedResourceId || this._generateResourceId() } update () { this.emit("change", this), this._sharedResourceId = null } _generateResourceId () { let t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`; return this._sharedResourceId = yS(t), this._resourceId } destroy () { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners() } }, "_TextureStyle"); ky.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" }; _l = ky }); var Ly, Hy, J, Lt = m(() => { Ly = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); wi(); Ri(); Wt(); Vf(); Hy = c(class Ny extends Ly.default { constructor(t = {}) { super(), this.options = t, this.uid = Z("textureSource"), this._resourceType = "textureSource", this._resourceId = Z("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = { ...Ny.defaultOptions, ...t }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new _l(me(t)), this.destroyed = !1, this._refreshPOT() } get source () { return this } get style () { return this._style } set style (t) { this.style !== t && (this._style?.off("change", this._onStyleChange, this), this._style = t, this._style?.on("change", this._onStyleChange, this), this._onStyleChange()) } get addressMode () { return this._style.addressMode } set addressMode (t) { this._style.addressMode = t } get repeatMode () { return this._style.addressMode } set repeatMode (t) { this._style.addressMode = t } get magFilter () { return this._style.magFilter } set magFilter (t) { this._style.magFilter = t } get minFilter () { return this._style.minFilter } set minFilter (t) { this._style.minFilter = t } get mipmapFilter () { return this._style.mipmapFilter } set mipmapFilter (t) { this._style.mipmapFilter = t } get lodMinClamp () { return this._style.lodMinClamp } set lodMinClamp (t) { this._style.lodMinClamp = t } get lodMaxClamp () { return this._style.lodMaxClamp } set lodMaxClamp (t) { this._style.lodMaxClamp = t } _onStyleChange () { this.emit("styleChange", this) } update () { if (this.resource) { let t = this._resolution; if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return } this.emit("update", this) } destroy () { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners() } unload () { this._resourceId = Z("resource"), this.emit("change", this), this.emit("unload", this) } get resourceWidth () { let { resource: t } = this; return t.naturalWidth || t.videoWidth || t.displayWidth || t.width } get resourceHeight () { let { resource: t } = this; return t.naturalHeight || t.videoHeight || t.displayHeight || t.height } get resolution () { return this._resolution } set resolution (t) { this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t) } resize (t, e, s) { s = s || this._resolution, t = t || this.width, e = e || this.height; let o = Math.round(t * s), i = Math.round(e * s); return this.width = o / s, this.height = i / s, this._resolution = s, this.pixelWidth === o && this.pixelHeight === i ? !1 : (this._refreshPOT(), this.pixelWidth = o, this.pixelHeight = i, this.emit("resize", this), this._resourceId = Z("resource"), this.emit("change", this), !0) } updateMipmaps () { this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this) } set wrapMode (t) { this._style.wrapMode = t } get wrapMode () { return this._style.wrapMode } set scaleMode (t) { this._style.scaleMode = t } get scaleMode () { return this._style.scaleMode } _refreshPOT () { this.isPowerOfTwo = ma(this.pixelWidth) && ma(this.pixelHeight) } static test (t) { throw new Error("Unimplemented") } }, "_TextureSource"); Hy.defaultOptions = { resolution: 1, format: "bgra8unorm", alphaMode: "premultiply-alpha-on-upload", dimensions: "2d", mipLevelCount: 1, autoGenerateMipmaps: !1, sampleCount: 1, antialias: !1, autoGarbageCollect: !1 }; J = Hy }); var je, bl = m(() => { S(); Lt(); je = class extends J { constructor(t) { let e = t.resource || new Float32Array(t.width * t.height * 4), s = t.format; s || (e instanceof Float32Array ? s = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? s = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? s = "rgba16uint" : (e instanceof Int8Array, s = "bgra8unorm")), super({ ...t, resource: e, format: s }), this.uploadMethodId = "buffer" } static test (t) { return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array } }; c(je, "BufferImageSource"); je.extension = x.TextureSource }); var Wy, pr, yl = m(() => { ot(); Wy = new B, pr = class { constructor(t, e) { this.mapCoord = new B, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : .5 : this.clampMargin = e, this.isSimple = !1, this.texture = t } get texture () { return this._texture } set texture (t) { this.texture !== t && (this._texture?.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update()) } multiplyUvs (t, e) { e === void 0 && (e = t); let s = this.mapCoord; for (let o = 0; o < t.length; o += 2) { let i = t[o], n = t[o + 1]; e[o] = i * s.a + n * s.c + s.tx, e[o + 1] = i * s.b + n * s.d + s.ty } return e } update () { let t = this._texture; this._updateID++; let e = t.uvs; this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0); let s = t.orig, o = t.trim; o && (Wy.set(s.width / o.width, 0, 0, s.height / o.height, -o.x / o.width, -o.y / o.height), this.mapCoord.append(Wy)); let i = t.source, n = this.uClampFrame, a = this.clampMargin / i._resolution, l = this.clampOffset; return n[0] = (t.frame.x + a + l) / i.width, n[1] = (t.frame.y + a + l) / i.height, n[2] = (t.frame.x + t.frame.width - a + l) / i.width, n[3] = (t.frame.y + t.frame.height - a + l) / i.height, this.uClampOffset[0] = l / i.pixelWidth, this.uClampOffset[1] = l / i.pixelHeight, this.isSimple = t.frame.width === i.width && t.frame.height === i.height && t.rotate === 0, !0 } }; c(pr, "TextureMatrix") }); var Xy, E, rt = m(() => { Xy = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); gl(); Gt(); Wt(); lt(); zf(); bl(); Lt(); yl(); E = class extends Xy.default { constructor({ source: t, label: e, frame: s, orig: o, trim: i, defaultAnchor: n, defaultBorders: a, rotate: l, dynamic: h } = {}) { if (super(), this.uid = Z("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new H, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = e, this.source = t?.source ?? new J, this.noFrame = !s, s) this.frame.copyFrom(s); else { let { width: u, height: d } = this._source; this.frame.width = u, this.frame.height = d } this.orig = o || this.frame, this.trim = i, this.rotate = l ?? 0, this.defaultAnchor = n, this.defaultBorders = a, this.destroyed = !1, this.dynamic = h || !1, this.updateUvs() } set source (t) { this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this) } get source () { return this._source } get textureMatrix () { return this._textureMatrix || (this._textureMatrix = new pr(this)), this._textureMatrix } get width () { return this.orig.width } get height () { return this.orig.height } updateUvs () { let { uvs: t, frame: e } = this, { width: s, height: o } = this._source, i = e.x / s, n = e.y / o, a = e.width / s, l = e.height / o, h = this.rotate; if (h) { let u = a / 2, d = l / 2, f = i + u, p = n + d; h = Q.add(h, Q.NW), t.x0 = f + u * Q.uX(h), t.y0 = p + d * Q.uY(h), h = Q.add(h, 2), t.x1 = f + u * Q.uX(h), t.y1 = p + d * Q.uY(h), h = Q.add(h, 2), t.x2 = f + u * Q.uX(h), t.y2 = p + d * Q.uY(h), h = Q.add(h, 2), t.x3 = f + u * Q.uX(h), t.y3 = p + d * Q.uY(h) } else t.x0 = i, t.y0 = n, t.x1 = i + a, t.y1 = n, t.x2 = i + a, t.y2 = n + l, t.x3 = i, t.y3 = n + l } destroy (t = !1) { this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners() } update () { this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this) } get baseTexture () { return w(G, "Texture.baseTexture is now Texture.source"), this._source } }; c(E, "Texture"); E.EMPTY = new E({ label: "EMPTY", source: new J({ label: "EMPTY" }) }); E.EMPTY.destroy = pa; E.WHITE = new E({ source: new je({ resource: new Uint8Array([255, 255, 255, 255]), width: 1, height: 1, alphaMode: "premultiply-alpha-on-upload", label: "WHITE" }), label: "WHITE" }); E.WHITE.destroy = pa }); var zy, xa, Yf = m(() => { Gt(); rt(); zy = c(class vl { constructor(t, e) { this.linkedSheets = [], this._texture = t instanceof E ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e; let s = parseFloat(e.meta.scale); s ? (this.resolution = s, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null } parse () { return new Promise(t => { this._callback = t, this._batchIndex = 0, this._frameKeys.length <= vl.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch() }) } _processFrames (t) { let e = t, s = vl.BATCH_SIZE; for (; e - t < s && e < this._frameKeys.length;) { let o = this._frameKeys[e], i = this._frames[o], n = i.frame; if (n) { let a = null, l = null, h = i.trimmed !== !1 && i.sourceSize ? i.sourceSize : i.frame, u = new H(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution); i.rotated ? a = new H(Math.floor(n.x) / this.resolution, Math.floor(n.y) / this.resolution, Math.floor(n.h) / this.resolution, Math.floor(n.w) / this.resolution) : a = new H(Math.floor(n.x) / this.resolution, Math.floor(n.y) / this.resolution, Math.floor(n.w) / this.resolution, Math.floor(n.h) / this.resolution), i.trimmed !== !1 && i.spriteSourceSize && (l = new H(Math.floor(i.spriteSourceSize.x) / this.resolution, Math.floor(i.spriteSourceSize.y) / this.resolution, Math.floor(n.w) / this.resolution, Math.floor(n.h) / this.resolution)), this.textures[o] = new E({ source: this.textureSource, frame: a, orig: u, trim: l, rotate: i.rotated ? 2 : 0, defaultAnchor: i.anchor, defaultBorders: i.borders, label: o.toString() }) } e++ } } _processAnimations () { let t = this.data.animations || {}; for (let e in t) { this.animations[e] = []; for (let s = 0; s < t[e].length; s++) { let o = t[e][s]; this.animations[e].push(this.textures[o]) } } } _parseComplete () { let t = this._callback; this._callback = null, this._batchIndex = 0, t.call(this, this.textures) } _nextBatch () { this._processFrames(this._batchIndex * vl.BATCH_SIZE), this._batchIndex++, setTimeout(() => { this._batchIndex * vl.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete()) }, 0) } destroy (t = !1) { for (let e in this.textures) this.textures[e].destroy(); this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (this._texture?.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [] } }, "_Spritesheet"); zy.BATCH_SIZE = 1e3; xa = zy }); function Vy (r, t, e) { let s = {}; if (r.forEach(o => { s[o] = t }), Object.keys(t.textures).forEach(o => { s[o] = t.textures[o] }), !e) { let o = At.dirname(r[0]); t.linkedSheets.forEach((i, n) => { let a = Vy([`${o}/${t.data.meta.related_multi_packs[n]}`], i, !0); Object.assign(s, a) }) } return s } var vS, Sl, $f = m(() => { pe(); Xr(); xl(); S(); rt(); Wr(); Yf(); vS = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"]; c(Vy, "getCacheableAssets"); Sl = { extension: x.Asset, cache: { test: r => r instanceof xa, getCacheableAssets: (r, t) => Vy(r, t, !1) }, resolver: { test: r => { let e = r.split("?")[0].split("."), s = e.pop(), o = e.pop(); return s === "json" && vS.includes(o) }, parse: r => { let t = r.split("."); return { resolution: parseFloat(Dt.RETINA_PREFIX.exec(r)?.[1] ?? "1"), format: t[t.length - 2], src: r } } }, loader: { name: "spritesheetLoader", extension: { type: x.LoadParser, priority: mt.Normal }, async testParse (r, t) { return At.extname(t.src).toLowerCase() === ".json" && !!r.frames }, async parse (r, t, e) { let { texture: s, imageFilename: o } = t?.data ?? {}, i = At.dirname(t.src); i && i.lastIndexOf("/") !== i.length - 1 && (i += "/"); let n; if (s instanceof E) n = s; else { let h = Bo(i + (o ?? r.meta.image), t.src); n = (await e.load([h]))[h] } let a = new xa(n.source, r); await a.parse(); let l = r?.meta?.related_multi_packs; if (Array.isArray(l)) { let h = []; for (let d of l) { if (typeof d != "string") continue; let f = i + d; t.data?.ignoreMultiPack || (f = Bo(f, t.src), h.push(e.load({ src: f, data: { ignoreMultiPack: !0 } }))) } let u = await Promise.all(h); a.linkedSheets = u, u.forEach(d => { d.linkedSheets = [a].concat(a.linkedSheets.filter(f => f !== d)) }) } return a }, async unload (r, t, e) { await e.unload(r.textureSource._sourceOrigin), r.destroy(!1) } } } }); var jf = m(() => { S(); $f(); I.add(Sl) }); function mr (r, t, e, s) { let { width: o, height: i } = e.orig, n = e.trim; if (n) { let a = n.width, l = n.height; r.minX = n.x - t._x * o - s, r.maxX = r.minX + a, r.minY = n.y - t._y * i - s, r.maxY = r.minY + l } else r.minX = -t._x * o - s, r.maxX = r.minX + o, r.minY = -t._y * i - s, r.maxY = r.minY + i } var ga = m(() => { "use strict"; c(mr, "updateQuadBounds") }); var wt, zr = m(() => { bo(); rt(); ga(); It(); wt = class extends N { constructor(t = E.EMPTY) { t instanceof E && (t = { texture: t }); let { texture: e, anchor: s, roundPixels: o, width: i, height: n, ...a } = t; super({ label: "Sprite", ...a }), this.renderPipeId = "sprite", this.batched = !0, this._didSpriteUpdate = !1, this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._boundsDirty = !0, this._sourceBoundsDirty = !0, this._roundPixels = 0, this._anchor = new at({ _onUpdate: () => { this.onViewUpdate() } }), s ? this.anchor = s : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = !1, this.roundPixels = o ?? !1, i && (this.width = i), n && (this.height = n) } static from (t, e = !1) { return t instanceof E ? new wt(t) : new wt(E.from(t, e)) } set texture (t) { t || (t = E.EMPTY); let e = this._texture; e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate()) } get texture () { return this._texture } get bounds () { return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds } get sourceBounds () { return this._sourceBoundsDirty && (this._updateSourceBounds(), this._sourceBoundsDirty = !1), this._sourceBounds } containsPoint (t) { let e = this.sourceBounds; return t.x >= e.maxX && t.x <= e.minX && t.y >= e.maxY && t.y <= e.minY } addBounds (t) { let e = this._texture.trim ? this.sourceBounds : this.bounds; t.addFrame(e.minX, e.minY, e.maxX, e.maxY) } onViewUpdate () { this._didChangeId += 4096, this._didSpriteUpdate = !0, this._sourceBoundsDirty = this._boundsDirty = !0, !this.didViewUpdate && (this.didViewUpdate = !0, this.renderGroup && this.renderGroup.onChildViewUpdate(this)) } _updateBounds () { mr(this._bounds, this._anchor, this._texture, 0) } _updateSourceBounds () { let t = this._anchor, e = this._texture, s = this._sourceBounds, { width: o, height: i } = e.orig; s.maxX = -t._x * o, s.minX = s.maxX + o, s.maxY = -t._y * i, s.minY = s.maxY + i } destroy (t = !1) { if (super.destroy(t), typeof t == "boolean" ? t : t?.texture) { let s = typeof t == "boolean" ? t : t?.textureSource; this._texture.destroy(s) } this._texture = null, this._bounds = null, this._sourceBounds = null, this._anchor = null } get anchor () { return this._anchor } set anchor (t) { typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t) } get roundPixels () { return !!this._roundPixels } set roundPixels (t) { this._roundPixels = t ? 1 : 0 } get width () { return Math.abs(this.scale.x) * this._texture.orig.width } set width (t) { this._setWidth(t, this._texture.orig.width) } get height () { return Math.abs(this.scale.y) * this._texture.orig.height } set height (t) { this._setHeight(t, this._texture.orig.height) } getSize (t) { return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t } setSize (t, e) { let s, o; typeof t != "object" ? (s = t, o = e ?? t) : (s = t.width, o = t.height ?? t.width), s !== void 0 && this._setWidth(s, this._texture.orig.width), o !== void 0 && this._setHeight(o, this._texture.orig.height) } }; c(wt, "Sprite") }); function Vr (r, t, e) { let s = SS; r.measurable = !0, Ye(r, e, s), t.addBoundsMask(s), r.measurable = !1 } var SS, _a = m(() => { te(); vo(); SS = new it; c(Vr, "addMaskBounds") }); function Yr (r, t, e) { let s = ee.get(); r.measurable = !0; let o = le.get().identity(), i = Tl(r, e, o); Dr(r, s, i), r.measurable = !1, t.addBoundsMask(s), le.return(o), ee.return(s) } function Tl (r, t, e) { return r ? (r !== t && (Tl(r.parent, t, e), r.updateLocalTransform(), e.append(r.localTransform)), e) : (U("Mask bounds, renderable is not inside the root container"), e) } var ba = m(() => { ca(); vi(); ut(); c(Yr, "addMaskLocalBounds"); c(Tl, "getMatrixRelativeToParent") }); var $r, Kf = m(() => { S(); zr(); _a(); ba(); $r = class { constructor(t) { this.priority = 0, this.pipe = "alphaMask", t?.mask && this.init(t.mask) } init (t) { this.mask = t, this.renderMaskToTexture = !(t instanceof wt), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1 } reset () { this.mask.measurable = !0, this.mask = null } addBounds (t, e) { Vr(this.mask, t, e) } addLocalBounds (t, e) { Yr(this.mask, t, e) } containsPoint (t, e) { let s = this.mask; return e(s, t) } destroy () { this.reset() } static test (t) { return t instanceof wt } }; c($r, "AlphaMask"); $r.extension = x.MaskEffect }); var jr, qf = m(() => { S(); jr = class { constructor(t) { this.priority = 0, this.pipe = "colorMask", t?.mask && this.init(t.mask) } init (t) { this.mask = t } destroy () { } static test (t) { return typeof t == "number" } }; c(jr, "ColorMask"); jr.extension = x.MaskEffect }); var Kr, Zf = m(() => { S(); It(); _a(); ba(); Kr = class { constructor(t) { this.priority = 0, this.pipe = "stencilMask", t?.mask && this.init(t.mask) } init (t) { this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1 } reset () { this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null } addBounds (t, e) { Vr(this.mask, t, e) } addLocalBounds (t, e) { Yr(this.mask, t, e) } containsPoint (t, e) { let s = this.mask; return e(s, t) } destroy () { this.reset() } static test (t) { return t instanceof N } }; c(Kr, "StencilMask"); Kr.extension = x.MaskEffect }); var se, Mi = m(() => { ft(); S(); Lt(); se = class extends J { constructor(t) { t.resource || (t.resource = k.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity; let e = t.resource; (this.pixelWidth !== e.width || this.pixelWidth !== e.height) && this.resizeCanvas(), this.transparent = !!t.transparent } resizeCanvas () { this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight) } resize (t = this.width, e = this.height, s = this._resolution) { let o = super.resize(t, e, s); return o && this.resizeCanvas(), o } static test (t) { return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas } }; c(se, "CanvasSource"); se.extension = x.TextureSource }); var jt, Ao = m(() => { ft(); S(); ut(); Lt(); jt = class extends J { constructor(t) { if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) { let e = k.get().createCanvas(t.resource.width, t.resource.height); e.getContext("2d").drawImage(t.resource, 0, 0), t.resource = e, U("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.") } super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0 } static test (t) { return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap } }; c(jt, "ImageSource"); jt.extension = x.TextureSource }); async function Gi () { return T_ ?? (T_ = (async () => { let t = document.createElement("canvas").getContext("webgl"); if (!t) return "premultiply-alpha-on-upload"; let e = await new Promise(n => { let a = document.createElement("video"); a.onloadeddata = () => n(a), a.onerror = () => n(null), a.autoplay = !1, a.crossOrigin = "anonymous", a.preload = "auto", a.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", a.load() }); if (!e) return "premultiply-alpha-on-upload"; let s = t.createTexture(); t.bindTexture(t.TEXTURE_2D, s); let o = t.createFramebuffer(); t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, s, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e); let i = new Uint8Array(4); return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, i), t.deleteFramebuffer(o), t.deleteTexture(s), t.getExtension("WEBGL_lose_context")?.loseContext(), i[0] <= i[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload" })()), T_ } var T_, El = m(() => { "use strict"; c(Gi, "detectVideoAlphaMode") }); var Qf, qr, Pl = m(() => { S(); Po(); El(); Lt(); Qf = c(class Yy extends J { constructor(t) { super(t), this.isReady = !1, this.uploadMethodId = "video", t = { ...Yy.defaultOptions, ...t }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== !1 && this.load() } updateFrame () { if (!this.destroyed) { if (this._updateFPS) { let t = Bt.shared.elapsedMS * this.resource.playbackRate; this._msToNextUpdate = Math.floor(this._msToNextUpdate - t) } (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update() } } _videoFrameRequestCallback () { this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback) } get isValid () { return !!this.resource.videoWidth && !!this.resource.videoHeight } async load () { if (this._load) return this._load; let t = this.resource, e = this.options; return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, !0)), this.alphaMode = await Gi(), this._load = new Promise((s, o) => { this.isValid ? s(this) : (this._resolve = s, this._reject = o, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => { this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`)) })), t.load()) }), this._load } _onError (t) { this.resource.removeEventListener("error", this._onError, !0), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null) } _isSourcePlaying () { let t = this.resource; return !t.paused && !t.ended } _isSourceReady () { return this.resource.readyState > 2 } _onPlayStart () { this.isValid || this._mediaReady(), this._configureAutoUpdate() } _onPlayStop () { this._configureAutoUpdate() } _onSeeked () { this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0) } _onCanPlay () { this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady() } _onCanPlayThrough () { this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady() } _mediaReady () { let t = this.resource; this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play() } destroy () { this._configureAutoUpdate(); let t = this.resource; t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), super.destroy() } get autoUpdate () { return this._autoUpdate } set autoUpdate (t) { t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate()) } get updateFPS () { return this._updateFPS } set updateFPS (t) { t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate()) } _configureAutoUpdate () { this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Bt.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Bt.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Bt.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0)) } static test (t) { return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || globalThis.VideoFrame && t instanceof VideoFrame } }, "_VideoSource"); Qf.extension = x.TextureSource; Qf.defaultOptions = { ...J.defaultOptions, autoLoad: !0, autoPlay: !0, updateFPS: 0, crossorigin: !0, loop: !1, muted: !0, playsinline: !0, preload: !1 }; Qf.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }; qr = Qf }); var Jf, tt, Ke = m(() => { ut(); Ei(); Jf = class { constructor() { this._parsers = [], this._cache = new Map, this._cacheMap = new Map } reset () { this._cacheMap.clear(), this._cache.clear() } has (t) { return this._cache.has(t) } get (t) { let e = this._cache.get(t); return e || U(`[Assets] Asset id ${t} was not found in the Cache`), e } set (t, e) { let s = Xt(t), o; for (let l = 0; l < this.parsers.length; l++) { let h = this.parsers[l]; if (h.test(e)) { o = h.getCacheableAssets(s, e); break } } let i = new Map(Object.entries(o || {})); o || s.forEach(l => { i.set(l, e) }); let n = [...i.keys()], a = { cacheKeys: n, keys: s }; s.forEach(l => { this._cacheMap.set(l, a) }), n.forEach(l => { let h = o ? o[l] : e; this._cache.has(l) && this._cache.get(l) !== h && U("[Cache] already has key:", l), this._cache.set(l, i.get(l)) }) } remove (t) { if (!this._cacheMap.has(t)) { U(`[Assets] Asset id ${t} was not found in the Cache`); return } let e = this._cacheMap.get(t); e.cacheKeys.forEach(o => { this._cache.delete(o) }), e.keys.forEach(o => { this._cacheMap.delete(o) }) } get parsers () { return this._parsers } }; c(Jf, "CacheClass"); tt = new Jf }); function tp (r = {}) { let t = r && r.resource, e = t ? r.resource : r, s = t ? r : { resource: r }; for (let o = 0; o < E_.length; o++) { let i = E_[o]; if (i.test(e)) return new i(s) } throw new Error(`Could not find a source type for resource: ${s.resource}`) } function ep (r = {}, t = !1) { let e = r && r.resource, s = e ? r.resource : r, o = e ? r : { resource: r }; if (!t && tt.has(s)) return tt.get(s); let i = new E({ source: tp(o) }); return i.on("destroy", () => { tt.has(s) && tt.remove(s) }), t || tt.set(s, i), i } function rp (r, t = !1) { return typeof r == "string" ? tt.get(r) : r instanceof J ? new E({ source: r }) : ep(r, t) } var E_, sp = m(() => { Ke(); S(); Lt(); rt(); E_ = []; I.handleByList(x.TextureSource, E_); c(tp, "autoDetectSource"); c(ep, "resourceToTexture"); c(rp, "textureFrom"); E.from = rp }); var op = m(() => { S(); Kf(); qf(); Zf(); bl(); Mi(); Ao(); Pl(); sp(); Kc(); I.add($r, jr, Kr, qr, jt, se, je) }); var K, qe = m(() => { "use strict"; K = (r => (r[r.MAP_READ = 1] = "MAP_READ", r[r.MAP_WRITE = 2] = "MAP_WRITE", r[r.COPY_SRC = 4] = "COPY_SRC", r[r.COPY_DST = 8] = "COPY_DST", r[r.INDEX = 16] = "INDEX", r[r.VERTEX = 32] = "VERTEX", r[r.UNIFORM = 64] = "UNIFORM", r[r.STORAGE = 128] = "STORAGE", r[r.INDIRECT = 256] = "INDIRECT", r[r.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", r[r.STATIC = 1024] = "STATIC", r))(K || {}) }); var $y, _t, xr = m(() => { $y = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); Wt(); qe(); _t = class extends $y.default { constructor(t) { let { data: e, size: s } = t, { usage: o, label: i, shrinkToFit: n } = t; super(), this.uid = Z("buffer"), this._resourceType = "buffer", this._resourceId = Z("resource"), this._touched = 0, this._updateID = 1, this.shrinkToFit = !0, this.destroyed = !1, e instanceof Array && (e = new Float32Array(e)), this._data = e, s = s ?? e?.byteLength; let a = !!e; this.descriptor = { size: s, usage: o, mappedAtCreation: a, label: i }, this.shrinkToFit = n ?? !0 } get data () { return this._data } set data (t) { this.setDataWithSize(t, t.length, !0) } get static () { return !!(this.descriptor.usage & K.STATIC) } set static (t) { t ? this.descriptor.usage |= K.STATIC : this.descriptor.usage &= ~K.STATIC } setDataWithSize (t, e, s) { if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) { s && this.emit("update", this); return } let o = this._data; if (this._data = t, o.length !== t.length) { !this.shrinkToFit && t.byteLength < o.byteLength ? s && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = Z("resource"), this.emit("change", this)); return } s && this.emit("update", this) } update (t) { this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this) } destroy () { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners() } }; c(_t, "Buffer") }); function ya (r, t) { if (!(r instanceof _t)) { let e = t ? K.INDEX : K.VERTEX; r instanceof Array && (t ? (r = new Uint32Array(r), e = K.INDEX | K.COPY_DST) : (r = new Float32Array(r), e = K.VERTEX | K.COPY_DST)), r = new _t({ data: r, label: t ? "index-mesh-buffer" : "vertex-mesh-buffer", usage: e }) } return r } var ip = m(() => { xr(); qe(); c(ya, "ensureIsBuffer") }); function Cl (r, t, e) { let s = r.getAttribute(t); if (!s) return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e; let o = s.buffer.data, i = 1 / 0, n = 1 / 0, a = -1 / 0, l = -1 / 0, h = o.BYTES_PER_ELEMENT, u = (s.offset || 0) / h, d = (s.stride || 2 * 4) / h; for (let f = u; f < o.length; f += d) { let p = o[f], g = o[f + 1]; p > a && (a = p), g > l && (l = g), p < i && (i = p), g < n && (n = g) } return e.minX = i, e.minY = n, e.maxX = a, e.maxY = l, e } var np = m(() => { "use strict"; c(Cl, "getGeometryBounds") }); function TS (r) { return (r instanceof _t || Array.isArray(r) || r.BYTES_PER_ELEMENT) && (r = { buffer: r }), r.buffer = ya(r.buffer, !1), r } var jy, oe, wo = m(() => { jy = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); te(); Wt(); xr(); ip(); np(); c(TS, "ensureIsAttribute"); oe = class extends jy.default { constructor(t) { let { attributes: e, indexBuffer: s, topology: o } = t; super(), this.uid = Z("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new it, this._boundsDirty = !0, this.attributes = e, this.buffers = [], this.instanceCount = t.instanceCount || 1; for (let i in e) { let n = e[i] = TS(e[i]); this.buffers.indexOf(n.buffer) === -1 && (this.buffers.push(n.buffer), n.buffer.on("update", this.onBufferUpdate, this), n.buffer.on("change", this.onBufferUpdate, this)) } s && (this.indexBuffer = ya(s, !0), this.buffers.push(this.indexBuffer)), this.topology = o || "triangle-list" } onBufferUpdate () { this._boundsDirty = !0, this.emit("update", this) } getAttribute (t) { return this.attributes[t] } getIndex () { return this.indexBuffer } getBuffer (t) { return this.getAttribute(t).buffer } getSize () { for (let t in this.attributes) { let e = this.attributes[t]; return e.buffer.data.length / (e.stride / 4 || e.size) } return 0 } get bounds () { return this._boundsDirty ? (this._boundsDirty = !1, Cl(this, "aPosition", this._bounds)) : this._bounds } destroy (t = !1) { this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach(e => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null } }; c(oe, "Geometry") }); var ES, PS, gr, Bl = m(() => { xr(); qe(); wo(); ES = new Float32Array(1), PS = new Uint32Array(1), gr = class extends oe { constructor() { let e = new _t({ data: ES, label: "attribute-batch-buffer", usage: K.VERTEX | K.COPY_DST, shrinkToFit: !1 }), s = new _t({ data: PS, label: "index-batch-buffer", usage: K.INDEX | K.COPY_DST, shrinkToFit: !1 }), o = 6 * 4; super({ attributes: { aPosition: { buffer: e, format: "float32x2", stride: o, offset: 0, location: 1 }, aUV: { buffer: e, format: "float32x2", stride: o, offset: 2 * 4, location: 3 }, aColor: { buffer: e, format: "unorm8x4", stride: o, offset: 4 * 4, location: 0 }, aTextureIdAndRound: { buffer: e, format: "uint16x2", stride: o, offset: 5 * 4, location: 2 } }, indexBuffer: s }) } }; c(gr, "BatchGeometry") }); var Rt, _r = m(() => { "use strict"; Rt = class { constructor(t) { this.resources = Object.create(null), this._dirty = !0; let e = 0; for (let s in t) { let o = t[s]; this.setResource(o, e++) } this._updateKey() } _updateKey () { if (!this._dirty) return; this._dirty = !1; let t = [], e = 0; for (let s in this.resources) t[e++] = this.resources[s]._resourceId; this._key = t.join("|") } setResource (t, e) { let s = this.resources[e]; t !== s && (s && t.off?.("change", this.onResourceChange, this), t.on?.("change", this.onResourceChange, this), this.resources[e] = t, this._dirty = !0) } getResource (t) { return this.resources[t] } _touch (t) { let e = this.resources; for (let s in e) e[s]._touched = t } destroy () { let t = this.resources; for (let e in t) t[e].off?.("change", this.onResourceChange, this); this.resources = null } onResourceChange (t) { if (this._dirty = !0, t.destroyed) { let e = this.resources; for (let s in e) e[s] === t && (e[s] = null) } else this._updateKey() } }; c(Rt, "BindGroup") }); var Mt, Ze = m(() => { "use strict"; Mt = 16 }); function Zr (r, t) { let e = 0; for (let s = 0; s < t; s++)e = e * 31 + r[s].uid >>> 0; return Ky[e] || CS(r, e) } function CS (r, t) { let e = {}, s = 0; for (let i = 0; i < 16; i++) { let n = i < r.length ? r[i] : E.EMPTY.source; e[s++] = n.source, e[s++] = n.style } let o = new Rt(e); return Ky[t] = o, o } var Ky, va = m(() => { _r(); rt(); Ze(); Ky = {}; c(Zr, "getTextureBatchBindGroup"); c(CS, "generateTextureBatchBindGroup") }); var Qr, ap = m(() => { "use strict"; Qr = class { constructor(t) { typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength } get int8View () { return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View } get uint8View () { return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View } get int16View () { return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View } get int32View () { return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View } get float64View () { return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array } get bigUint64View () { return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array } view (t) { return this[`${t}View`] } destroy () { this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null } static sizeOf (t) { switch (t) { case "int8": case "uint8": return 1; case "int16": case "uint16": return 2; case "int32": case "uint32": case "float32": return 4; default: throw new Error(`${t} isn't a valid view type`) } } }; c(Qr, "ViewableBuffer") }); function Ro (r, t) { let e = r.byteLength / 8 | 0, s = new Float64Array(r, 0, e); new Float64Array(t, 0, e).set(s); let i = r.byteLength - e * 8; if (i > 0) { let n = new Uint8Array(r, e * 8, i); new Uint8Array(t, e * 8, i).set(n) } } var Al = m(() => { "use strict"; c(Ro, "fastCopy") }); var wl, xt, Jr = m(() => { "use strict"; wl = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" }, xt = (r => (r[r.DISABLED = 0] = "DISABLED", r[r.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", r[r.MASK_ACTIVE = 2] = "MASK_ACTIVE", r[r.RENDERING_MASK_REMOVE = 3] = "RENDERING_MASK_REMOVE", r[r.NONE = 4] = "NONE", r))(xt || {}) }); function Sa (r, t) { return t.alphaMode === "no-premultiply-alpha" && wl[r] || r } var cp = m(() => { Jr(); c(Sa, "getAdjustedBlendModeBlend") }); var ts, lp = m(() => { "use strict"; ts = class { constructor() { this.ids = Object.create(null), this.textures = [], this.count = 0 } clear () { for (let t = 0; t < this.count; t++) { let e = this.textures[t]; this.textures[t] = null, this.ids[e.uid] = null } this.count = 0 } }; c(ts, "BatchTextureArray") }); var Mo, Rl, qy, Ui, Ml = m(() => { Wt(); ap(); Al(); cp(); lp(); Ze(); Mo = class { constructor() { this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.blendMode = "normal", this.canBundle = !0 } destroy () { this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null } }; c(Mo, "Batch"); Rl = 0, qy = c(class Zy { constructor(t = {}) { this.uid = Z("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._vertexSize = 6, this._elements = [], this._batchPool = [], this._batchPoolIndex = 0, this._textureBatchPool = [], this._textureBatchPoolIndex = 0, t = { ...Zy.defaultOptions, ...t }; let { vertexSize: e, indexSize: s } = t; this.attributeBuffer = new Qr(e * this._vertexSize * 4), this.indexBuffer = new Uint16Array(s) } begin () { this.batchIndex = 0, this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0, this._batchPoolIndex = 0, this._textureBatchPoolIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0 } add (t) { this._elements[this.elementSize++] = t, t.indexStart = this.indexSize, t.location = this.attributeSize, t.batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.vertexSize * this._vertexSize } checkAndUpdateTexture (t, e) { let s = t.batch.textures.ids[e._source.uid]; return !s && s !== 0 ? !1 : (t.textureId = s, t.texture = e, !0) } updateElement (t) { this.dirty = !0, t.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, t.location, t.textureId) } break (t) { let e = this._elements, s = this._textureBatchPool[this._textureBatchPoolIndex++] || new ts; if (s.clear(), !e[this.elementStart]) return; let o = e[this.elementStart], i = Sa(o.blendMode, o.texture._source); this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize); let n = this.attributeBuffer.float32View, a = this.attributeBuffer.uint32View, l = this.indexBuffer, h = this._batchIndexSize, u = this._batchIndexStart, d = "startBatch", f = this._batchPool[this._batchPoolIndex++] || new Mo; for (let p = this.elementStart; p < this.elementSize; ++p) { let g = e[p]; e[p] = null; let _ = g.texture._source, y = Sa(g.blendMode, _), v = i !== y; if (_._batchTick === Rl && !v) { g.textureId = _._textureBindLocation, h += g.indexSize, g.packAttributes(n, a, g.location, g.textureId), g.packIndex(l, g.indexStart, g.location / this._vertexSize), g.batch = f; continue } _._batchTick = Rl, (s.count >= 16 || v) && (this._finishBatch(f, u, h - u, s, i, t, d), d = "renderBatch", u = h, i = y, s = this._textureBatchPool[this._textureBatchPoolIndex++] || new ts, s.clear(), f = this._batchPool[this._batchPoolIndex++] || new Mo, ++Rl), g.textureId = _._textureBindLocation = s.count, s.ids[_.uid] = s.count, s.textures[s.count++] = _, g.batch = f, h += g.indexSize, g.packAttributes(n, a, g.location, g.textureId), g.packIndex(l, g.indexStart, g.location / this._vertexSize) } s.count > 0 && (this._finishBatch(f, u, h - u, s, i, t, d), u = h, ++Rl), this.elementStart = this.elementSize, this._batchIndexStart = u, this._batchIndexSize = h } _finishBatch (t, e, s, o, i, n, a) { t.gpuBindGroup = null, t.action = a, t.batcher = this, t.textures = o, t.blendMode = i, t.start = e, t.size = s, ++Rl, n.add(t) } finish (t) { this.break(t) } ensureAttributeBuffer (t) { t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4) } ensureIndexBuffer (t) { t <= this.indexBuffer.length || this._resizeIndexBuffer(t) } _resizeAttributeBuffer (t) { let e = Math.max(t, this.attributeBuffer.size * 2), s = new Qr(e); Ro(this.attributeBuffer.rawBinaryData, s.rawBinaryData), this.attributeBuffer = s } _resizeIndexBuffer (t) { let e = this.indexBuffer, s = Math.max(t, e.length * 1.5); s += s % 2; let o = s > 65535 ? new Uint32Array(s) : new Uint16Array(s); if (o.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT) for (let i = 0; i < e.length; i++)o[i] = e[i]; else Ro(e.buffer, o.buffer); this.indexBuffer = o } destroy () { for (let t = 0; t < this.batches.length; t++)this.batches[t].destroy(); this.batches = null; for (let t = 0; t < this._elements.length; t++)this._elements[t].batch = null; this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null } }, "_Batcher"); qy.defaultOptions = { vertexSize: 4, indexSize: 6 }; Ui = qy }); function Fi (r, t, e, s, o, i, n, a = null) { let l = 0; e *= t, o *= i; let h = a.a, u = a.b, d = a.c, f = a.d, p = a.tx, g = a.ty; for (; l < n;) { let b = r[e], _ = r[e + 1]; s[o] = h * b + d * _ + p, s[o + 1] = u * b + f * _ + g, o += i, e += t, l++ } } function Ii (r, t, e, s) { let o = 0; for (t *= e; o < s;)r[t] = 0, r[t + 1] = 0, t += e, o++ } var Gl = m(() => { "use strict"; c(Fi, "buildUvs"); c(Ii, "buildSimpleUvs") }); function Go (r, t, e, s, o) { let i = t.a, n = t.b, a = t.c, l = t.d, h = t.tx, u = t.ty; e = e || 0, s = s || 2, o = o || r.length / s - e; let d = e * s; for (let f = 0; f < o; f++) { let p = r[d], g = r[d + 1]; r[d] = i * p + a * g + h, r[d + 1] = n * p + l * g + u, d += s } } var Ul = m(() => { "use strict"; c(Go, "transformVertices") }); function Fl (r, t) { if (r === 16777215 || !t) return t; if (t === 16777215 || !r) return r; let e = r >> 16 & 255, s = r >> 8 & 255, o = r & 255, i = t >> 16 & 255, n = t >> 8 & 255, a = t & 255, l = e * i / 255, h = s * n / 255, u = o * a / 255; return (l << 16) + (h << 8) + u } var up = m(() => { "use strict"; c(Fl, "multiplyHexColors") }); var Qe, Il = m(() => { up(); Qe = class { constructor() { this.batcher = null, this.batch = null, this.applyTransform = !0, this.roundPixels = 0 } get blendMode () { return this.applyTransform ? this.renderable.groupBlendMode : "normal" } packIndex (t, e, s) { let o = this.geometryData.indices; for (let i = 0; i < this.indexSize; i++)t[e++] = o[i + this.indexOffset] + s - this.vertexOffset } packAttributes (t, e, s, o) { let i = this.geometryData, n = this.renderable, a = i.vertices, l = i.uvs, h = this.vertexOffset * 2, u = (this.vertexOffset + this.vertexSize) * 2, d = this.color, f = d >> 16 | d & 65280 | (d & 255) << 16; if (this.applyTransform) { let p = Fl(f, n.groupColor) + (this.alpha * n.groupAlpha * 255 << 24), g = n.groupTransform, b = o << 16 | this.roundPixels & 65535, _ = g.a, y = g.b, v = g.c, T = g.d, P = g.tx, M = g.ty; for (let D = h; D < u; D += 2) { let R = a[D], F = a[D + 1]; t[s] = _ * R + v * F + P, t[s + 1] = y * R + T * F + M, t[s + 2] = l[D], t[s + 3] = l[D + 1], e[s + 4] = p, e[s + 5] = b, s += 6 } } else { let p = f + (this.alpha * 255 << 24); for (let g = h; g < u; g += 2)t[s] = a[g], t[s + 1] = a[g + 1], t[s + 2] = l[g], t[s + 3] = l[g + 1], e[s + 4] = p, e[s + 5] = o << 16, s += 6 } } get vertSize () { return this.vertexSize } copyTo (t) { t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.vertexOffset = this.vertexOffset, t.vertexSize = this.vertexSize, t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData } reset () { this.applyTransform = !0 } }; c(Qe, "BatchableGraphics") }); var Je, Ol = m(() => { "use strict"; Je = { build (r, t) { let e, s, o, i, n, a; if (r.type === "circle") { let P = r; e = P.x, s = P.y, n = a = P.radius, o = i = 0 } else if (r.type === "ellipse") { let P = r; e = P.x, s = P.y, n = P.halfWidth, a = P.halfHeight, o = i = 0 } else { let P = r, M = P.width / 2, D = P.height / 2; e = P.x + M, s = P.y + D, n = a = Math.max(0, Math.min(P.radius, Math.min(M, D))), o = M - n, i = D - a } if (!(n >= 0 && a >= 0 && o >= 0 && i >= 0)) return t; let l = Math.ceil(2.3 * Math.sqrt(n + a)), h = l * 8 + (o ? 4 : 0) + (i ? 4 : 0); if (h === 0) return t; if (l === 0) return t[0] = t[6] = e + o, t[1] = t[3] = s + i, t[2] = t[4] = e - o, t[5] = t[7] = s - i, t; let u = 0, d = l * 4 + (o ? 2 : 0) + 2, f = d, p = h, g = o + n, b = i, _ = e + g, y = e - g, v = s + b; if (t[u++] = _, t[u++] = v, t[--d] = v, t[--d] = y, i) { let P = s - b; t[f++] = y, t[f++] = P, t[--p] = P, t[--p] = _ } for (let P = 1; P < l; P++) { let M = Math.PI / 2 * (P / l), D = o + Math.cos(M) * n, R = i + Math.sin(M) * a, F = e + D, C = e - D, A = s + R, ct = s - R; t[u++] = F, t[u++] = A, t[--d] = A, t[--d] = C, t[f++] = C, t[f++] = ct, t[--p] = ct, t[--p] = F } g = o, b = i + a, _ = e + g, y = e - g, v = s + b; let T = s - b; return t[u++] = _, t[u++] = v, t[--p] = T, t[--p] = _, o && (t[u++] = y, t[u++] = v, t[--p] = T, t[--p] = y), t }, triangulate (r, t, e, s, o, i) { if (r.length === 0) return; let n = 0, a = 0; for (let u = 0; u < r.length; u += 2)n += r[u], a += r[u + 1]; n /= r.length / 2, a /= r.length / 2; let l = s; t[l * e] = n, t[l * e + 1] = a; let h = l++; for (let u = 0; u < r.length; u += 2)t[l * e] = r[u], t[l * e + 1] = r[u + 1], u > 0 && (o[i++] = l, o[i++] = h, o[i++] = l - 1), l++; o[i++] = h + 1, o[i++] = h, o[i++] = l - 1 } } }); var kl, Ta, hp = m(() => { "use strict"; kl = 1e-4, Ta = 1e-4 }); function Dl (r) { let t = r.length; if (t < 6) return 1; let e = 0; for (let s = 0, o = r[t - 2], i = r[t - 1]; s < t; s += 2) { let n = r[s], a = r[s + 1]; e += (n - o) * (a + i), o = n, i = a } return e < 0 ? -1 : 1 } var dp = m(() => { "use strict"; c(Dl, "getOrientationOfPoints") }); function Qy (r, t, e, s, o, i, n, a) { let l = r - e * o, h = t - s * o, u = r + e * i, d = t + s * i, f, p; n ? (f = s, p = -e) : (f = -s, p = e); let g = l + f, b = h + p, _ = u + f, y = d + p; return a.push(g, b), a.push(_, y), 2 } function Oi (r, t, e, s, o, i, n, a) { let l = e - r, h = s - t, u = Math.atan2(l, h), d = Math.atan2(o - r, i - t); a && u < d ? u += Math.PI * 2 : !a && u > d && (d += Math.PI * 2); let f = u, p = d - u, g = Math.abs(p), b = Math.sqrt(l * l + h * h), _ = (15 * g * Math.sqrt(b) / Math.PI >> 0) + 1, y = p / _; if (f += y, a) { n.push(r, t), n.push(e, s); for (let v = 1, T = f; v < _; v++, T += y)n.push(r, t), n.push(r + Math.sin(T) * b, t + Math.cos(T) * b); n.push(r, t), n.push(o, i) } else { n.push(e, s), n.push(r, t); for (let v = 1, T = f; v < _; v++, T += y)n.push(r + Math.sin(T) * b, t + Math.cos(T) * b), n.push(r, t); n.push(o, i), n.push(r, t) } return _ * 2 } function Ll (r, t, e, s, o, i, n, a, l) { let h = 1e-4; if (r.length === 0) return; let u = t, d = u.alignment; if (t.alignment !== .5) { let pt = Dl(r); e && (pt *= -1), d = (d - .5) * pt + .5 } let f = new V(r[0], r[1]), p = new V(r[r.length - 2], r[r.length - 1]), g = s, b = Math.abs(f.x - p.x) < h && Math.abs(f.y - p.y) < h; if (g) { r = r.slice(), b && (r.pop(), r.pop(), p.set(r[r.length - 2], r[r.length - 1])); let pt = (f.x + p.x) * .5, _o = (p.y + f.y) * .5; r.unshift(pt, _o), r.push(pt, _o) } let _ = o, y = r.length / 2, v = r.length, T = _.length / 2, P = u.width / 2, M = P * P, D = u.miterLimit * u.miterLimit, R = r[0], F = r[1], C = r[2], A = r[3], ct = 0, nt = 0, L = -(F - A), z = R - C, Et = 0, Ft = 0, ze = Math.sqrt(L * L + z * z); L /= ze, z /= ze, L *= P, z *= P; let py = d, $ = (1 - py) * 2, q = py * 2; g || (u.cap === "round" ? v += Oi(R - L * ($ - q) * .5, F - z * ($ - q) * .5, R - L * $, F - z * $, R + L * q, F + z * q, _, !0) + 2 : u.cap === "square" && (v += Qy(R, F, L, z, $, q, !0, _))), _.push(R - L * $, F - z * $), _.push(R + L * q, F + z * q); for (let pt = 1; pt < y - 1; ++pt) { R = r[(pt - 1) * 2], F = r[(pt - 1) * 2 + 1], C = r[pt * 2], A = r[pt * 2 + 1], ct = r[(pt + 1) * 2], nt = r[(pt + 1) * 2 + 1], L = -(F - A), z = R - C, ze = Math.sqrt(L * L + z * z), L /= ze, z /= ze, L *= P, z *= P, Et = -(A - nt), Ft = C - ct, ze = Math.sqrt(Et * Et + Ft * Ft), Et /= ze, Ft /= ze, Et *= P, Ft *= P; let _o = C - R, Fc = F - A, Ic = C - ct, Oc = nt - A, my = _o * Ic + Fc * Oc, ff = Fc * Ic - Oc * _o, kc = ff < 0; if (Math.abs(ff) < .001 * Math.abs(my)) { _.push(C - L * $, A - z * $), _.push(C + L * q, A + z * q), my >= 0 && (u.join === "round" ? v += Oi(C, A, C - L * $, A - z * $, C - Et * $, A - Ft * $, _, !1) + 4 : v += 2, _.push(C - Et * q, A - Ft * q), _.push(C + Et * $, A + Ft * $)); continue } let xy = (-L + R) * (-z + A) - (-L + C) * (-z + F), gy = (-Et + ct) * (-Ft + A) - (-Et + C) * (-Ft + nt), pf = (_o * gy - Ic * xy) / ff, mf = (Oc * xy - Fc * gy) / ff, a_ = (pf - C) * (pf - C) + (mf - A) * (mf - A), di = C + (pf - C) * $, fi = A + (mf - A) * $, pi = C - (pf - C) * q, mi = A - (mf - A) * q, $0 = Math.min(_o * _o + Fc * Fc, Ic * Ic + Oc * Oc), _y = kc ? $ : q, j0 = $0 + _y * _y * M; a_ <= j0 ? u.join === "bevel" || a_ / M > D ? (kc ? (_.push(di, fi), _.push(C + L * q, A + z * q), _.push(di, fi), _.push(C + Et * q, A + Ft * q)) : (_.push(C - L * $, A - z * $), _.push(pi, mi), _.push(C - Et * $, A - Ft * $), _.push(pi, mi)), v += 2) : u.join === "round" ? kc ? (_.push(di, fi), _.push(C + L * q, A + z * q), v += Oi(C, A, C + L * q, A + z * q, C + Et * q, A + Ft * q, _, !0) + 4, _.push(di, fi), _.push(C + Et * q, A + Ft * q)) : (_.push(C - L * $, A - z * $), _.push(pi, mi), v += Oi(C, A, C - L * $, A - z * $, C - Et * $, A - Ft * $, _, !1) + 4, _.push(C - Et * $, A - Ft * $), _.push(pi, mi)) : (_.push(di, fi), _.push(pi, mi)) : (_.push(C - L * $, A - z * $), _.push(C + L * q, A + z * q), u.join === "round" ? kc ? v += Oi(C, A, C + L * q, A + z * q, C + Et * q, A + Ft * q, _, !0) + 2 : v += Oi(C, A, C - L * $, A - z * $, C - Et * $, A - Ft * $, _, !1) + 2 : u.join === "miter" && a_ / M <= D && (kc ? (_.push(pi, mi), _.push(pi, mi)) : (_.push(di, fi), _.push(di, fi)), v += 2), _.push(C - Et * $, A - Ft * $), _.push(C + Et * q, A + Ft * q), v += 2) } R = r[(y - 2) * 2], F = r[(y - 2) * 2 + 1], C = r[(y - 1) * 2], A = r[(y - 1) * 2 + 1], L = -(F - A), z = R - C, ze = Math.sqrt(L * L + z * z), L /= ze, z /= ze, L *= P, z *= P, _.push(C - L * $, A - z * $), _.push(C + L * q, A + z * q), g || (u.cap === "round" ? v += Oi(C - L * ($ - q) * .5, A - z * ($ - q) * .5, C - L * $, A - z * $, C + L * q, A + z * q, _, !1) + 2 : u.cap === "square" && (v += Qy(C, A, L, z, $, q, !1, _))); let Y0 = 1e-4 * 1e-4; for (let pt = T; pt < v + T - 2; ++pt)R = _[pt * 2], F = _[pt * 2 + 1], C = _[(pt + 1) * 2], A = _[(pt + 1) * 2 + 1], ct = _[(pt + 2) * 2], nt = _[(pt + 2) * 2 + 1], !(Math.abs(R * (A - nt) + C * (nt - F) + ct * (F - A)) < Y0) && a.push(pt, pt + 1, pt + 2) } var fp = m(() => { ce(); hp(); dp(); c(Qy, "square"); c(Oi, "round"); c(Ll, "buildLine") }); function ki (r, t, e, s, o, i, n) { let a = (0, Jy.default)(r, t, 2); if (!a) return; for (let h = 0; h < a.length; h += 3)i[n++] = a[h] + o, i[n++] = a[h + 1] + o, i[n++] = a[h + 2] + o; let l = o * s; for (let h = 0; h < r.length; h += 2)e[l] = r[h], e[l + 1] = r[h + 1], l += s } var Jy, Hl = m(() => { Jy = Ct(Tt("/node_modules/earcut?_v=2.2.4&_env=prod"), 1); c(ki, "triangulateWithHoles") }); var BS, Di, Nl = m(() => { Hl(); BS = [], Di = { build (r, t) { for (let e = 0; e < r.points.length; e++)t[e] = r.points[e]; return t }, triangulate (r, t, e, s, o, i) { ki(r, BS, t, e, s, o, i) } } }); var Li, Wl = m(() => { "use strict"; Li = { build (r, t) { let e = r, s = e.x, o = e.y, i = e.width, n = e.height; return i >= 0 && n >= 0 && (t[0] = s, t[1] = o, t[2] = s + i, t[3] = o, t[4] = s + i, t[5] = o + n, t[6] = s, t[7] = o + n), t }, triangulate (r, t, e, s, o, i) { let n = 0; s *= e, t[s + n] = r[0], t[s + n + 1] = r[1], n += e, t[s + n] = r[2], t[s + n + 1] = r[3], n += e, t[s + n] = r[6], t[s + n + 1] = r[7], n += e, t[s + n] = r[4], t[s + n + 1] = r[5], n += e; let a = s / e; o[i++] = a, o[i++] = a + 1, o[i++] = a + 2, o[i++] = a + 1, o[i++] = a + 3, o[i++] = a + 2 } } }); var Hi, Xl = m(() => { "use strict"; Hi = { build (r, t) { return t[0] = r.x, t[1] = r.y, t[2] = r.x2, t[3] = r.y2, t[4] = r.x3, t[5] = r.y3, t }, triangulate (r, t, e, s, o, i) { let n = 0; s *= e, t[s + n] = r[0], t[s + n + 1] = r[1], n += e, t[s + n] = r[2], t[s + n + 1] = r[3], n += e, t[s + n] = r[4], t[s + n + 1] = r[5]; let a = s / e; o[i++] = a, o[i++] = a + 1, o[i++] = a + 2 } } }); function zl (r, t) { let { geometryData: e, batches: s } = t; s.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0; for (let o = 0; o < r.instructions.length; o++) { let i = r.instructions[o]; if (i.action === "texture") wS(i.data, s, e); else if (i.action === "fill" || i.action === "stroke") { let n = i.action === "stroke", a = i.data.path.shapePath, l = i.data.style, h = i.data.hole; n && h && tv(h.shapePath, l, null, !0, s, e), tv(a, l, h, n, s, e) } } } function wS (r, t, e) { let { vertices: s, uvs: o, indices: i } = e, n = i.length, a = s.length / 2, l = [], h = P_.rectangle, u = AS, d = r.image; u.x = r.dx, u.y = r.dy, u.width = r.dw, u.height = r.dh; let f = r.transform; h.build(u, l), f && Go(l, f), h.triangulate(l, s, 2, a, i, n); let p = d.uvs; o.push(p.x0, p.y0, p.x1, p.y1, p.x3, p.y3, p.x2, p.y2); let g = Y.get(Qe); g.indexOffset = n, g.indexSize = i.length - n, g.vertexOffset = a, g.vertexSize = s.length / 2 - a, g.color = r.style, g.alpha = r.alpha, g.texture = d, g.geometryData = e, t.push(g) } function tv (r, t, e, s, o, i) { let { vertices: n, uvs: a, indices: l } = i, h = r.shapePrimitives.length - 1; r.shapePrimitives.forEach(({ shape: u, transform: d }, f) => { let p = l.length, g = n.length / 2, b = [], _ = P_[u.type]; if (_.build(u, b), d && Go(b, d), s) { let P = u.closePath ?? !0; Ll(b, t, !1, P, n, 2, g, l, p) } else if (e && h === f) { h !== 0 && console.warn("[Pixi Graphics] only the last shape have be cut out"); let P = [], M = b.slice(); RS(e.shapePath).forEach(R => { P.push(M.length / 2), M.push(...R) }), ki(M, P, n, 2, g, l, p) } else _.triangulate(b, n, 2, g, l, p); let y = a.length / 2, v = t.texture; if (v !== E.WHITE) { let P = t.matrix; d && P.append(d.clone().invert()), Fi(n, 2, g, a, y, 2, n.length / 2 - g, P) } else Ii(a, y, 2, n.length / 2 - g); let T = Y.get(Qe); T.indexOffset = p, T.indexSize = l.length - p, T.vertexOffset = g, T.vertexSize = n.length / 2 - g, T.color = t.color, T.alpha = t.alpha, T.texture = v, T.geometryData = i, o.push(T) }) } function RS (r) { if (!r) return []; let t = r.shapePrimitives, e = []; for (let s = 0; s < t.length; s++) { let o = t[s].shape, i = []; P_[o.type].build(o, i), e.push(i) } return e } var P_, AS, pp = m(() => { Gt(); Gl(); Ul(); rt(); Jt(); Il(); Ol(); fp(); Nl(); Wl(); Xl(); Hl(); P_ = { rectangle: Li, polygon: Di, triangle: Hi, circle: Je, ellipse: Je, roundedRectangle: Je }, AS = new H; c(zl, "buildContextBatches"); c(wS, "addTextureToGeometryData"); c(tv, "addShapePathToGeometryData"); c(RS, "getHoleArrays") }); var Ni, Wi, B_, es, Ea = m(() => { S(); Bl(); va(); Ml(); sl(); Jt(); pp(); Ni = class { constructor() { this.batches = [], this.geometryData = { vertices: [], uvs: [], indices: [] } } }; c(Ni, "GpuGraphicsContext"); Wi = class { constructor() { this.geometry = new gr, this.instructions = new hr } init () { this.instructions.reset() } }; c(Wi, "GraphicsContextRenderData"); B_ = c(class C_ { constructor() { this._activeBatchers = [], this._gpuContextHash = {}, this._graphicsDataContextHash = Object.create(null), this._needsContextNeedsRebuild = [] } init (t) { C_.defaultOptions.bezierSmoothness = t?.bezierSmoothness ?? C_.defaultOptions.bezierSmoothness } prerender () { this._returnActiveBatchers() } getContextRenderData (t) { return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t) } updateGpuContext (t) { let e = this._gpuContextHash[t.uid] || this._initContext(t); if (t.dirty) { e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), zl(t, e); let s = t.batchMode; t.customShader || s === "no-batch" ? e.isBatchable = !1 : s === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = !1 } return e } getGpuContext (t) { return this._gpuContextHash[t.uid] || this._initContext(t) } _returnActiveBatchers () { for (let t = 0; t < this._activeBatchers.length; t++)Y.return(this._activeBatchers[t]); this._activeBatchers.length = 0 } _initContextRenderData (t) { let e = Y.get(Wi), { batches: s, geometryData: o } = this._gpuContextHash[t.uid], i = o.vertices.length, n = o.indices.length; for (let u = 0; u < s.length; u++)s[u].applyTransform = !1; let a = Y.get(Ui); this._activeBatchers.push(a), a.ensureAttributeBuffer(i), a.ensureIndexBuffer(n), a.begin(); for (let u = 0; u < s.length; u++) { let d = s[u]; a.add(d) } a.finish(e.instructions); let l = e.geometry; l.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0), l.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0); let h = a.batches; for (let u = 0; u < h.length; u++) { let d = h[u]; d.bindGroup = Zr(d.textures.textures, d.textures.count) } return this._graphicsDataContextHash[t.uid] = e, e } _initContext (t) { let e = new Ni; return this._gpuContextHash[t.uid] = e, t.on("update", this.onGraphicsContextUpdate, this), t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] } onGraphicsContextUpdate (t) { this._needsContextNeedsRebuild.push(t) } onGraphicsContextDestroy (t) { this._cleanGraphicsContextData(t), t.off("update", this.onGraphicsContextUpdate, this), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null } _cleanGraphicsContextData (t) { let e = this._gpuContextHash[t.uid]; e.isBatchable || this._graphicsDataContextHash[t.uid] && (Y.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach(s => { Y.return(s) }) } destroy () { for (let t of this._needsContextNeedsRebuild) this._gpuContextHash[t.uid] && this.onGraphicsContextDestroy(t); this._needsContextNeedsRebuild.length = 0 } }, "_GraphicsContextSystem"); B_.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "graphicsContext" }; B_.defaultOptions = { bezierSmoothness: .5 }; es = B_ }); var MS, A_, w_, R_, M_, G_, U_, F_, Pt, Se = m(() => { "use strict"; MS = { normal: 0, add: 1, multiply: 2, screen: 3, overlay: 4, erase: 5, "normal-npm": 6, "add-npm": 7, "screen-npm": 8 }, A_ = 0, w_ = 1, R_ = 2, M_ = 3, G_ = 4, U_ = 5, F_ = c(class ev { constructor() { this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0 } get blend () { return !!(this.data & 1 << A_) } set blend (t) { !!(this.data & 1 << A_) !== t && (this.data ^= 1 << A_) } get offsets () { return !!(this.data & 1 << w_) } set offsets (t) { !!(this.data & 1 << w_) !== t && (this.data ^= 1 << w_) } set cullMode (t) { if (t === "none") { this.culling = !1; return } this.culling = !0, this.clockwiseFrontFace = t === "front" } get cullMode () { return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none" } get culling () { return !!(this.data & 1 << R_) } set culling (t) { !!(this.data & 1 << R_) !== t && (this.data ^= 1 << R_) } get depthTest () { return !!(this.data & 1 << M_) } set depthTest (t) { !!(this.data & 1 << M_) !== t && (this.data ^= 1 << M_) } get depthMask () { return !!(this.data & 1 << U_) } set depthMask (t) { !!(this.data & 1 << U_) !== t && (this.data ^= 1 << U_) } get clockwiseFrontFace () { return !!(this.data & 1 << G_) } set clockwiseFrontFace (t) { !!(this.data & 1 << G_) !== t && (this.data ^= 1 << G_) } get blendMode () { return this._blendMode } set blendMode (t) { this.blend = t !== "none", this._blendMode = t, this._blendModeId = MS[t] || 0 } get polygonOffset () { return this._polygonOffset } set polygonOffset (t) { this.offsets = !!t, this._polygonOffset = t } toString () { return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]` } static for2d () { let t = new ev; return t.depthTest = !1, t.blend = !0, t } }, "_State"); F_.default2d = F_.for2d(); Pt = F_ }); function I_ (r, t, e, s) { e[s++] = (r >> 16 & 255) / 255, e[s++] = (r >> 8 & 255) / 255, e[s++] = (r & 255) / 255, e[s++] = t } function tr (r, t, e) { let s = (r >> 24 & 255) / 255; t[e++] = (r & 255) / 255 * s, t[e++] = (r >> 8 & 255) / 255 * s, t[e++] = (r >> 16 & 255) / 255 * s, t[e++] = s } var Xi = m(() => { "use strict"; c(I_, "colorToUniform"); c(tr, "color32BitToUniform") }); var rs, mp = m(() => { S(); Se(); Jt(); Xi(); Il(); rs = class { constructor(t, e) { this.state = Pt.for2d(), this._graphicsBatchesHash = Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init() } validateRenderable (t) { let e = t.context, s = !!this._graphicsBatchesHash[t.uid], o = this.renderer.graphicsContext.updateGpuContext(e); return !!(o.isBatchable || s !== o.isBatchable) } addRenderable (t, e) { let s = this.renderer.graphicsContext.updateGpuContext(t.context); t._didGraphicsUpdate && (t._didGraphicsUpdate = !1, this._rebuild(t)), s.isBatchable ? this._addToBatcher(t, e) : (this.renderer.renderPipes.batch.break(e), e.add(t)) } updateRenderable (t) { let e = this._graphicsBatchesHash[t.uid]; if (e) for (let s = 0; s < e.length; s++) { let o = e[s]; o.batcher.updateElement(o) } } destroyRenderable (t) { this._graphicsBatchesHash[t.uid] && this._removeBatchForRenderable(t.uid) } execute (t) { if (!t.isRenderable) return; let e = this.renderer, s = t.context; if (!e.graphicsContext.getGpuContext(s).batches.length) return; let i = s.customShader || this._adaptor.shader; this.state.blendMode = t.groupBlendMode; let n = i.resources.localUniforms.uniforms; n.uTransformMatrix = t.groupTransform, n.uRound = e._roundPixels | t._roundPixels, tr(t.groupColorAlpha, n.uColor, 0), this._adaptor.execute(this, t) } _rebuild (t) { let e = !!this._graphicsBatchesHash[t.uid], s = this.renderer.graphicsContext.updateGpuContext(t.context); e && this._removeBatchForRenderable(t.uid), s.isBatchable && this._initBatchesForRenderable(t), t.batched = s.isBatchable } _addToBatcher (t, e) { let s = this.renderer.renderPipes.batch, o = this._getBatchesForRenderable(t); for (let i = 0; i < o.length; i++) { let n = o[i]; s.addToBatch(n, e) } } _getBatchesForRenderable (t) { return this._graphicsBatchesHash[t.uid] || this._initBatchesForRenderable(t) } _initBatchesForRenderable (t) { let e = t.context, s = this.renderer.graphicsContext.getGpuContext(e), o = this.renderer._roundPixels | t._roundPixels, i = s.batches.map(n => { let a = Y.get(Qe); return n.copyTo(a), a.renderable = t, a.roundPixels = o, a }); return this._graphicsBatchesHash[t.uid] = i, t.on("destroyed", () => { this.destroyRenderable(t) }), i } _removeBatchForRenderable (t) { this._graphicsBatchesHash[t].forEach(e => { Y.return(e) }), this._graphicsBatchesHash[t] = null } destroy () { this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null; for (let t in this._graphicsBatchesHash) this._removeBatchForRenderable(t); this._graphicsBatchesHash = null } }; c(rs, "GraphicsPipe"); rs.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "graphics" } }); var O_ = m(() => { S(); Ea(); mp(); I.add(rs); I.add(es) }); function er (r, t) { let e = rv[r]; return e === void 0 && (k_[t] === void 0 && (k_[t] = 1), rv[r] = e = k_[t]++), e } var k_, rv, zi = m(() => { "use strict"; k_ = Object.create(null), rv = Object.create(null); c(er, "createIdFromString") }); function Vl (r, t) { switch (r) { case "f32": return 0; case "vec2<f32>": return new Float32Array(2 * t); case "vec3<f32>": return new Float32Array(3 * t); case "vec4<f32>": return new Float32Array(4 * t); case "mat2x2<f32>": return new Float32Array([1, 0, 0, 1]); case "mat3x3<f32>": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4x4<f32>": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } var xp = m(() => { "use strict"; c(Vl, "getDefaultUniformValue") }); var sv, et, Ot = m(() => { Wt(); zi(); xp(); sv = c(class ov { constructor(t, e) { this._touched = 0, this.uid = Z("uniform"), this._resourceType = "uniformGroup", this._resourceId = Z("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, e = { ...ov.defaultOptions, ...e }, this.uniformStructures = t; let s = {}; for (let o in t) { let i = t[o]; i.name = o, i.size = i.size ?? 1, i.value ?? (i.value = Vl(i.type, i.size)), s[o] = i.value } this.uniforms = s, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = er(Object.keys(s).map(o => `${o}-${t[o].type}`).join("-"), "uniform-group") } update () { this._dirtyId++ } }, "_UniformGroup"); sv.defaultOptions = { ubo: !1, isStatic: !1 }; et = sv }); var Ie, Pa = m(() => { "use strict"; Ie = class { constructor() { this.batcher = null, this.batch = null, this.roundPixels = 0, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1 } get blendMode () { return this.mesh.groupBlendMode } reset () { this.mesh = null, this.texture = null, this.batcher = null, this.batch = null } packIndex (t, e, s) { let o = this.geometry.indices; for (let i = 0; i < o.length; i++)t[e++] = o[i] + s } packAttributes (t, e, s, o) { let i = this.mesh, n = this.geometry, a = i.groupTransform, l = o << 16 | this.roundPixels & 65535, h = a.a, u = a.b, d = a.c, f = a.d, p = a.tx, g = a.ty, b = n.positions, _ = n.getBuffer("aUV"), y = _.data, v = y, T = this.texture.textureMatrix; T.isSimple || (v = this._transformedUvs, (this._textureMatrixUpdateId !== T._updateID || this._uvUpdateId !== _._updateID) && ((!v || v.length < y.length) && (v = this._transformedUvs = new Float32Array(y.length)), this._textureMatrixUpdateId = T._updateID, this._uvUpdateId = _._updateID, T.multiplyUvs(y, v))); let P = i.groupColorAlpha; for (let M = 0; M < b.length; M += 2) { let D = b[M], R = b[M + 1]; t[s] = h * D + d * R + p, t[s + 1] = u * D + f * R + g, t[s + 2] = v[M], t[s + 3] = v[M + 1], e[s + 4] = P, e[s + 5] = l, s += 6 } } get vertexSize () { return this.geometry.positions.length / 2 } get indexSize () { return this.geometry.indices.length } }; c(Ie, "BatchableMesh") }); var ss, gp = m(() => { S(); ot(); _r(); Ot(); Jt(); Xi(); Pa(); ss = class { constructor(t, e) { this.localUniforms = new et({ uTransformMatrix: { value: new B, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), this.localUniformsBindGroup = new Rt({ 0: this.localUniforms }), this._meshDataHash = Object.create(null), this._gpuBatchableMeshHash = Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init() } validateRenderable (t) { let e = this._getMeshData(t), s = e.batched, o = t.batched; if (e.batched = o, s !== o) return !0; if (o) { let i = t._geometry; if (i.indices.length !== e.indexSize || i.positions.length !== e.vertexSize) return e.indexSize = i.indices.length, e.vertexSize = i.positions.length, !0; let n = this._getBatchableMesh(t), a = t.texture; if (n.texture._source !== a._source && n.texture._source !== a._source) return !n.batcher.checkAndUpdateTexture(n, a) } return !1 } addRenderable (t, e) { let s = this.renderer.renderPipes.batch, { batched: o } = this._getMeshData(t); if (o) { let i = this._getBatchableMesh(t); i.texture = t._texture, i.geometry = t._geometry, s.addToBatch(i) } else s.break(e), e.add({ renderPipeId: "mesh", mesh: t }) } updateRenderable (t) { if (t.batched) { let e = this._gpuBatchableMeshHash[t.uid]; e.texture = t._texture, e.geometry = t._geometry, e.batcher.updateElement(e) } } destroyRenderable (t) { this._meshDataHash[t.uid] = null; let e = this._gpuBatchableMeshHash[t.uid]; e && (Y.return(e), this._gpuBatchableMeshHash[t.uid] = null) } execute ({ mesh: t }) { if (!t.isRenderable) return; t.state.blendMode = t.groupBlendMode; let e = this.localUniforms; e.uniforms.uTransformMatrix = t.groupTransform, e.uniforms.uRound = this.renderer._roundPixels | t._roundPixels, e.update(), tr(t.groupColorAlpha, e.uniforms.uColor, 0), this._adaptor.execute(this, t) } _getMeshData (t) { return this._meshDataHash[t.uid] || this._initMeshData(t) } _initMeshData (t) { return this._meshDataHash[t.uid] = { batched: t.batched, indexSize: t._geometry.indices?.length, vertexSize: t._geometry.positions?.length }, t.on("destroyed", () => { this.destroyRenderable(t) }), this._meshDataHash[t.uid] } _getBatchableMesh (t) { return this._gpuBatchableMeshHash[t.uid] || this._initBatchableMesh(t) } _initBatchableMesh (t) { let e = Y.get(Ie); return e.mesh = t, e.texture = t._texture, e.roundPixels = this.renderer._roundPixels | t._roundPixels, this._gpuBatchableMeshHash[t.uid] = e, e.mesh = t, e } destroy () { for (let t in this._gpuBatchableMeshHash) this._gpuBatchableMeshHash[t] && Y.return(this._gpuBatchableMeshHash[t]); this._gpuBatchableMeshHash = null, this._meshDataHash = null, this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null } }; c(ss, "MeshPipe"); ss.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "mesh" } }); var D_ = m(() => { S(); gp(); I.add(ss) }); var Oe, Ca = m(() => { "use strict"; Oe = class { constructor() { this.vertexSize = 4, this.indexSize = 6, this.location = 0, this.batcher = null, this.batch = null, this.roundPixels = 0 } get blendMode () { return this.renderable.groupBlendMode } packAttributes (t, e, s, o) { let i = this.renderable, n = this.texture, a = i.groupTransform, l = a.a, h = a.b, u = a.c, d = a.d, f = a.tx, p = a.ty, g = this.bounds, b = g.maxX, _ = g.minX, y = g.maxY, v = g.minY, T = n.uvs, P = i.groupColorAlpha, M = o << 16 | this.roundPixels & 65535; t[s + 0] = l * _ + u * v + f, t[s + 1] = d * v + h * _ + p, t[s + 2] = T.x0, t[s + 3] = T.y0, e[s + 4] = P, e[s + 5] = M, t[s + 6] = l * b + u * v + f, t[s + 7] = d * v + h * b + p, t[s + 8] = T.x1, t[s + 9] = T.y1, e[s + 10] = P, e[s + 11] = M, t[s + 12] = l * b + u * y + f, t[s + 13] = d * y + h * b + p, t[s + 14] = T.x2, t[s + 15] = T.y2, e[s + 16] = P, e[s + 17] = M, t[s + 18] = l * _ + u * y + f, t[s + 19] = d * y + h * _ + p, t[s + 20] = T.x3, t[s + 21] = T.y3, e[s + 22] = P, e[s + 23] = M } packIndex (t, e, s) { t[e] = s + 0, t[e + 1] = s + 1, t[e + 2] = s + 2, t[e + 3] = s + 0, t[e + 4] = s + 2, t[e + 5] = s + 3 } reset () { this.renderable = null, this.texture = null, this.batcher = null, this.batch = null, this.bounds = null } }; c(Oe, "BatchableSprite") }); var os, _p = m(() => { S(); ga(); Jt(); Ca(); os = class { constructor(t) { this._gpuText = Object.create(null), this._renderer = t } validateRenderable (t) { let e = this._getGpuText(t), s = t._getKey(); if (e.currentKey !== s) { let o = t.resolution ?? this._renderer.resolution, { width: i, height: n } = this._renderer.canvasText.getTextureSize(t.text, o, t._style); return !(this._renderer.canvasText.getReferenceCount(e.currentKey) === 1 && i === e.texture._source.width && n === e.texture._source.height) } return !1 } addRenderable (t, e) { let o = this._getGpuText(t).batchableSprite; t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(o) } updateRenderable (t) { let s = this._getGpuText(t).batchableSprite; t._didTextUpdate && this._updateText(t), s.batcher.updateElement(s) } destroyRenderable (t) { this._destroyRenderableById(t.uid) } _destroyRenderableById (t) { let e = this._gpuText[t]; this._renderer.canvasText.decreaseReferenceCount(e.currentKey), Y.return(e.batchableSprite), this._gpuText[t] = null } _updateText (t) { let e = t._getKey(), s = this._getGpuText(t), o = s.batchableSprite; s.currentKey !== e && this._updateGpuText(t), t._didTextUpdate = !1; let i = t._style.padding; mr(o.bounds, t._anchor, o.texture, i) } _updateGpuText (t) { let e = this._getGpuText(t), s = e.batchableSprite; e.texture && this._renderer.canvasText.decreaseReferenceCount(e.currentKey), e.texture = s.texture = this._renderer.canvasText.getManagedTexture(t), e.currentKey = t._getKey(), s.texture = e.texture } _getGpuText (t) { return this._gpuText[t.uid] || this.initGpuText(t) } initGpuText (t) { let e = { texture: null, currentKey: "--", batchableSprite: Y.get(Oe) }; return e.batchableSprite.renderable = t, e.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, e.batchableSprite.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuText[t.uid] = e, this._updateText(t), t.on("destroyed", () => { this.destroyRenderable(t) }), e } destroy () { for (let t in this._gpuText) this._destroyRenderableById(t); this._gpuText = null, this._renderer = null } }; c(os, "CanvasTextPipe"); os.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "text" } }); var Vi, ie, Yi = m(() => { ft(); wi(); Vi = class { constructor(t) { this._canvasPool = Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = !1 } _createCanvasAndContext (t, e) { let s = k.get().createCanvas(); s.width = t, s.height = e; let o = s.getContext("2d"); return { canvas: s, context: o } } getOptimalCanvasAndContext (t, e, s = 1) { t = Math.ceil(t * s - 1e-6), e = Math.ceil(e * s - 1e-6), t = Fe(t), e = Fe(e); let o = (t << 17) + (e << 1); this._canvasPool[o] || (this._canvasPool[o] = []); let i = this._canvasPool[o].pop(); return i || (i = this._createCanvasAndContext(t, e)), i } returnCanvasAndContext (t) { let { width: e, height: s } = t.canvas, o = (e << 17) + (s << 1); this._canvasPool[o].push(t) } clear () { this._canvasPool = {} } }; c(Vi, "CanvasPoolClass"); ie = new Vi }); var GS, $i, gt, br = m(() => { wi(); Lt(); rt(); GS = 0, $i = class { constructor(t) { this._poolKeyHash = Object.create(null), this._texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1 } createTexture (t, e, s) { let o = new J({ ...this.textureOptions, width: t, height: e, resolution: 1, antialias: s, autoGarbageCollect: !0 }); return new E({ source: o, label: `texturePool_${GS++}` }) } getOptimalTexture (t, e, s = 1, o) { let i = Math.ceil(t * s - 1e-6), n = Math.ceil(e * s - 1e-6); i = Fe(i), n = Fe(n); let a = (i << 17) + (n << 1) + (o ? 1 : 0); this._texturePool[a] || (this._texturePool[a] = []); let l = this._texturePool[a].pop(); return l || (l = this.createTexture(i, n, o)), l.source._resolution = s, l.source.width = i / s, l.source.height = n / s, l.source.pixelWidth = i, l.source.pixelHeight = n, l.frame.x = 0, l.frame.y = 0, l.frame.width = t, l.frame.height = e, l.updateUvs(), this._poolKeyHash[l.uid] = a, l } getSameSizeTexture (t, e = !1) { let s = t.source; return this.getOptimalTexture(t.width, t.height, s._resolution, e) } returnTexture (t) { let e = this._poolKeyHash[t.uid]; this._texturePool[e].push(t) } clear (t) { if (t = t !== !1, t) for (let e in this._texturePool) { let s = this._texturePool[e]; if (s) for (let o = 0; o < s.length; o++)s[o].destroy(!0) } this._texturePool = {} } }; c($i, "TexturePoolClass"); gt = new $i }); function iv (r, t, e) { for (let s = 0, o = 4 * e * t; s < t; ++s, o += 4)if (r[o + 3] !== 0) return !1; return !0 } function nv (r, t, e, s, o) { let i = 4 * t; for (let n = s, a = s * i + 4 * e; n <= o; ++n, a += i)if (r[a + 3] !== 0) return !1; return !0 } function Yl (r, t = 1) { let { width: e, height: s } = r, o = r.getContext("2d", { willReadFrequently: !0 }); if (o === null) throw new TypeError("Failed to get canvas 2D context"); let n = o.getImageData(0, 0, e, s).data, a = 0, l = 0, h = e - 1, u = s - 1; for (; l < s && iv(n, e, l);)++l; if (l === s) return H.EMPTY; for (; iv(n, e, u);)--u; for (; nv(n, e, a, l, u);)++a; for (; nv(n, e, h, l, u);)--h; return ++h, ++u, new H(a / t, l / t, (h - a) / t, (u - l) / t) } var bp = m(() => { Gt(); c(iv, "checkRow"); c(nv, "checkColumn"); c(Yl, "getCanvasBoundingBox") }); var av, is, Ba = m(() => { $t(); ft(); ot(); Ao(); rt(); Wt(); av = c(class L_ { constructor(t, e, s, o) { this.uid = Z("fillGradient"), this.type = "linear", this.gradientStops = [], this.x0 = t, this.y0 = e, this.x1 = s, this.y1 = o } addColorStop (t, e) { return this.gradientStops.push({ offset: t, color: j.shared.setValue(e).toHex() }), this } buildLinearGradient () { let t = L_.defaultTextureSize, { gradientStops: e } = this, s = k.get().createCanvas(); s.width = t, s.height = t; let o = s.getContext("2d"), i = o.createLinearGradient(0, 0, L_.defaultTextureSize, 1); for (let b = 0; b < e.length; b++) { let _ = e[b]; i.addColorStop(_.offset, _.color) } o.fillStyle = i, o.fillRect(0, 0, t, t), this.texture = new E({ source: new jt({ resource: s, addressModeU: "clamp-to-edge", addressModeV: "repeat" }) }); let { x0: n, y0: a, x1: l, y1: h } = this, u = new B, d = l - n, f = h - a, p = Math.sqrt(d * d + f * f), g = Math.atan2(f, d); u.translate(-n, -a), u.scale(1 / t, 1 / t), u.rotate(-g), u.scale(256 / p, 1), this.transform = u } }, "_FillGradient"); av.defaultTextureSize = 256; is = av }); function $l (r, t) { let e = (0, cv.default)(r), s = [], o = null, i = 0, n = 0; for (let a = 0; a < e.length; a++) { let l = e[a], h = l[0], u = l; switch (h) { case "M": i = u[1], n = u[2], t.moveTo(i, n); break; case "m": i += u[1], n += u[2], t.moveTo(i, n); break; case "H": i = u[1], t.lineTo(i, n); break; case "h": i += u[1], t.lineTo(i, n); break; case "V": n = u[1], t.lineTo(i, n); break; case "v": n += u[1], t.lineTo(i, n); break; case "L": i = u[1], n = u[2], t.lineTo(i, n); break; case "l": i += u[1], n += u[2], t.lineTo(i, n); break; case "C": i = u[5], n = u[6], t.bezierCurveTo(u[1], u[2], u[3], u[4], i, n); break; case "c": t.bezierCurveTo(i + u[1], n + u[2], i + u[3], n + u[4], i + u[5], n + u[6]), i += u[5], n += u[6]; break; case "S": i = u[3], n = u[4], t.bezierCurveToShort(u[1], u[2], i, n); break; case "s": t.bezierCurveToShort(i + u[1], n + u[2], i + u[3], n + u[4]), i += u[3], n += u[4]; break; case "Q": i = u[3], n = u[4], t.quadraticCurveTo(u[1], u[2], i, n); break; case "q": t.quadraticCurveTo(i + u[1], n + u[2], i + u[3], n + u[4]), i += u[3], n += u[4]; break; case "T": i = u[1], n = u[2], t.quadraticCurveToShort(i, n); break; case "t": i += u[1], n += u[2], t.quadraticCurveToShort(i, n); break; case "A": i = u[6], n = u[7], t.arcToSvg(u[1], u[2], u[3], u[4], u[5], i, n); break; case "a": i += u[6], n += u[7], t.arcToSvg(u[1], u[2], u[3], u[4], u[5], i, n); break; case "Z": case "z": t.closePath(), s.length > 0 && (o = s.pop(), o ? (i = o.startX, n = o.startY) : (i = 0, n = 0)), o = null; break; default: U(`Unknown SVG path command: ${h}`) }h !== "Z" && h !== "z" && o === null && (o = { startX: i, startY: n }, s.push(o)) } return t } var cv, yp = m(() => { cv = Ct(Tt("/node_modules/parse-svg-path?_v=0.1.2&_env=prod"), 1); ut(); c($l, "SVGToGraphicsPath") }); var yr, vp = m(() => { Gt(); yr = class { constructor(t = 0, e = 0, s = 0) { this.type = "circle", this.x = t, this.y = e, this.radius = s } clone () { return new yr(this.x, this.y, this.radius) } contains (t, e) { if (this.radius <= 0) return !1; let s = this.radius * this.radius, o = this.x - t, i = this.y - e; return o *= o, i *= i, o + i <= s } strokeContains (t, e, s) { if (this.radius === 0) return !1; let o = this.x - t, i = this.y - e, n = this.radius, a = s / 2, l = Math.sqrt(o * o + i * i); return l < n + a && l > n - a } getBounds (t) { return t = t || new H, t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t } copyFrom (t) { return this.x = t.x, this.y = t.y, this.radius = t.radius, this } copyTo (t) { return t.copyFrom(this), t } toString () { return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]` } }; c(yr, "Circle") }); var vr, Sp = m(() => { Gt(); vr = class { constructor(t = 0, e = 0, s = 0, o = 0) { this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = s, this.halfHeight = o } clone () { return new vr(this.x, this.y, this.halfWidth, this.halfHeight) } contains (t, e) { if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1; let s = (t - this.x) / this.halfWidth, o = (e - this.y) / this.halfHeight; return s *= s, o *= o, s + o <= 1 } strokeContains (t, e, s) { let { halfWidth: o, halfHeight: i } = this; if (o <= 0 || i <= 0) return !1; let n = s / 2, a = o - n, l = i - n, h = o + n, u = i + n, d = t - this.x, f = e - this.y, p = d * d / (a * a) + f * f / (l * l), g = d * d / (h * h) + f * f / (u * u); return p > 1 && g <= 1 } getBounds () { return new H(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2) } copyFrom (t) { return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this } copyTo (t) { return t.copyFrom(this), t } toString () { return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]` } }; c(vr, "Ellipse") }); function ns (r, t, e, s, o, i) { let n = r - e, a = t - s, l = o - e, h = i - s, u = n * l + a * h, d = l * l + h * h, f = -1; d !== 0 && (f = u / d); let p, g; f < 0 ? (p = e, g = s) : f > 1 ? (p = o, g = i) : (p = e + f * l, g = s + f * h); let b = r - p, _ = t - g; return b * b + _ * _ } var jl = m(() => { "use strict"; c(ns, "squaredDistanceToLineSegment") }); var ke, Tp = m(() => { jl(); Gt(); ke = class { constructor(...t) { this.type = "polygon"; let e = Array.isArray(t[0]) ? t[0] : t; if (typeof e[0] != "number") { let s = []; for (let o = 0, i = e.length; o < i; o++)s.push(e[o].x, e[o].y); e = s } this.points = e, this.closePath = !0 } clone () { let t = this.points.slice(), e = new ke(t); return e.closePath = this.closePath, e } contains (t, e) { let s = !1, o = this.points.length / 2; for (let i = 0, n = o - 1; i < o; n = i++) { let a = this.points[i * 2], l = this.points[i * 2 + 1], h = this.points[n * 2], u = this.points[n * 2 + 1]; l > e != u > e && t < (h - a) * ((e - l) / (u - l)) + a && (s = !s) } return s } strokeContains (t, e, s) { let o = s / 2, i = o * o, { points: n } = this, a = n.length - (this.closePath ? 0 : 2); for (let l = 0; l < a; l += 2) { let h = n[l], u = n[l + 1], d = n[(l + 2) % n.length], f = n[(l + 3) % n.length]; if (ns(t, e, h, u, d, f) <= i) return !0 } return !1 } getBounds (t) { t = t || new H; let e = this.points, s = 1 / 0, o = -1 / 0, i = 1 / 0, n = -1 / 0; for (let a = 0, l = e.length; a < l; a += 2) { let h = e[a], u = e[a + 1]; s = h < s ? h : s, o = h > o ? h : o, i = u < i ? u : i, n = u > n ? u : n } return t.x = s, t.width = o - s, t.y = i, t.height = n - i, t } copyFrom (t) { return this.points = t.points.slice(), this.closePath = t.closePath, this } copyTo (t) { return t.copyFrom(this), t } toString () { return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]` } get lastX () { return this.points[this.points.length - 2] } get lastY () { return this.points[this.points.length - 1] } get x () { return this.points[this.points.length - 2] } get y () { return this.points[this.points.length - 1] } }; c(ke, "Polygon") }); var Ep, Sr, Pp = m(() => { Gt(); Ep = c((r, t, e, s, o, i) => { let n = r - e, a = t - s, l = Math.sqrt(n * n + a * a); return l >= o - i && l <= o + i }, "isCornerWithinStroke"), Sr = class { constructor(t = 0, e = 0, s = 0, o = 0, i = 20) { this.type = "roundedRectangle", this.x = t, this.y = e, this.width = s, this.height = o, this.radius = i } getBounds (t) { return t = t || new H, t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t } clone () { return new Sr(this.x, this.y, this.width, this.height, this.radius) } copyFrom (t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this } copyTo (t) { return t.copyFrom(this), t } contains (t, e) { if (this.width <= 0 || this.height <= 0) return !1; if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) { let s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2)); if (e >= this.y + s && e <= this.y + this.height - s || t >= this.x + s && t <= this.x + this.width - s) return !0; let o = t - (this.x + s), i = e - (this.y + s), n = s * s; if (o * o + i * i <= n || (o = t - (this.x + this.width - s), o * o + i * i <= n) || (i = e - (this.y + this.height - s), o * o + i * i <= n) || (o = t - (this.x + s), o * o + i * i <= n)) return !0 } return !1 } strokeContains (t, e, s) { let { x: o, y: i, width: n, height: a, radius: l } = this, h = s / 2, u = o + l, d = i + l, f = n - l * 2, p = a - l * 2, g = o + n, b = i + a; return (t >= o - h && t <= o + h || t >= g - h && t <= g + h) && e >= d && e <= d + p || (e >= i - h && e <= i + h || e >= b - h && e <= b + h) && t >= u && t <= u + f ? !0 : t < u && e < d && Ep(t, e, u, d, l, h) || t > g - l && e < d && Ep(t, e, g - l, d, l, h) || t > g - l && e > b - l && Ep(t, e, g - l, b - l, l, h) || t < u && e > b - l && Ep(t, e, u, b - l, l, h) } toString () { return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]` } }; c(Sr, "RoundedRectangle") }); function Ki (r, t, e, s, o, i, n, a, l, h) { let d = Math.min(.99, Math.max(0, h ?? es.defaultOptions.bezierSmoothness)), f = (FS - d) / 1; return f *= f, IS(t, e, s, o, i, n, a, l, r, f), r } function IS (r, t, e, s, o, i, n, a, l, h) { N_(r, t, e, s, o, i, n, a, l, h, 0), l.push(n, a) } function N_ (r, t, e, s, o, i, n, a, l, h, u) { if (u > US) return; let d = Math.PI, f = (r + e) / 2, p = (t + s) / 2, g = (e + o) / 2, b = (s + i) / 2, _ = (o + n) / 2, y = (i + a) / 2, v = (f + g) / 2, T = (p + b) / 2, P = (g + _) / 2, M = (b + y) / 2, D = (v + P) / 2, R = (T + M) / 2; if (u > 0) { let F = n - r, C = a - t, A = Math.abs((e - n) * C - (s - a) * F), ct = Math.abs((o - n) * C - (i - a) * F), nt, L; if (A > Cp && ct > Cp) { if ((A + ct) * (A + ct) <= h * (F * F + C * C)) { if (Aa < H_) { l.push(D, R); return } let z = Math.atan2(i - s, o - e); if (nt = Math.abs(z - Math.atan2(s - t, e - r)), L = Math.abs(Math.atan2(a - i, n - o) - z), nt >= d && (nt = 2 * d - nt), L >= d && (L = 2 * d - L), nt + L < Aa) { l.push(D, R); return } if (ji !== 0) { if (nt > ji) { l.push(e, s); return } if (L > ji) { l.push(o, i); return } } } } else if (A > Cp) { if (A * A <= h * (F * F + C * C)) { if (Aa < H_) { l.push(D, R); return } if (nt = Math.abs(Math.atan2(i - s, o - e) - Math.atan2(s - t, e - r)), nt >= d && (nt = 2 * d - nt), nt < Aa) { l.push(e, s), l.push(o, i); return } if (ji !== 0 && nt > ji) { l.push(e, s); return } } } else if (ct > Cp) { if (ct * ct <= h * (F * F + C * C)) { if (Aa < H_) { l.push(D, R); return } if (nt = Math.abs(Math.atan2(a - i, n - o) - Math.atan2(i - s, o - e)), nt >= d && (nt = 2 * d - nt), nt < Aa) { l.push(e, s), l.push(o, i); return } if (ji !== 0 && nt > ji) { l.push(o, i); return } } } else if (F = D - (r + n) / 2, C = R - (t + a) / 2, F * F + C * C <= h) { l.push(D, R); return } } N_(r, t, f, p, v, T, D, R, l, h, u + 1), N_(D, R, P, M, _, y, n, a, l, h, u + 1) } var US, Cp, FS, H_, Aa, ji, Kl = m(() => { Ea(); US = 8, Cp = 11920929e-14, FS = 1, H_ = .01, Aa = 0, ji = 0; c(Ki, "buildAdaptiveBezier"); c(IS, "begin"); c(N_, "recursive") }); function ql (r, t, e, s, o, i, n, a) { let h = Math.min(.99, Math.max(0, a ?? es.defaultOptions.bezierSmoothness)), u = (DS - h) / 1; return u *= u, HS(t, e, s, o, i, n, r, u), r } function HS (r, t, e, s, o, i, n, a) { W_(n, r, t, e, s, o, i, a, 0), n.push(o, i) } function W_ (r, t, e, s, o, i, n, a, l) { if (l > OS) return; let h = Math.PI, u = (t + s) / 2, d = (e + o) / 2, f = (s + i) / 2, p = (o + n) / 2, g = (u + f) / 2, b = (d + p) / 2, _ = i - t, y = n - e, v = Math.abs((s - i) * y - (o - n) * _); if (v > kS) { if (v * v <= a * (_ * _ + y * y)) { if (lv < LS) { r.push(g, b); return } let T = Math.abs(Math.atan2(n - o, i - s) - Math.atan2(o - e, s - t)); if (T >= h && (T = 2 * h - T), T < lv) { r.push(g, b); return } } } else if (_ = g - (t + i) / 2, y = b - (e + n) / 2, _ * _ + y * y <= a) { r.push(g, b); return } W_(r, t, e, u, d, g, b, a, l + 1), W_(r, g, b, f, p, i, n, a, l + 1) } var OS, kS, DS, LS, lv, Bp = m(() => { Ea(); OS = 8, kS = 11920929e-14, DS = 1, LS = .01, lv = 0; c(ql, "buildAdaptiveQuadratic"); c(HS, "begin"); c(W_, "recursive") }); function qi (r, t, e, s, o, i, n, a) { let l = Math.abs(o - i); (!n && o > i || n && i > o) && (l = 2 * Math.PI - l), a = a || Math.max(6, Math.floor(6 * Math.pow(s, 1 / 3) * (l / Math.PI))), a = Math.max(a, 3); let h = l / a, u = o; h *= n ? -1 : 1; for (let d = 0; d < a + 1; d++) { let f = Math.cos(u), p = Math.sin(u), g = t + f * s, b = e + p * s; r.push(g, b), u += h } } var Zl = m(() => { "use strict"; c(qi, "buildArc") }); function Ql (r, t, e, s, o, i) { let n = r[r.length - 2], l = r[r.length - 1] - e, h = n - t, u = o - e, d = s - t, f = Math.abs(l * d - h * u); if (f < 1e-8 || i === 0) { (r[r.length - 2] !== t || r[r.length - 1] !== e) && r.push(t, e); return } let p = l * l + h * h, g = u * u + d * d, b = l * u + h * d, _ = i * Math.sqrt(p) / f, y = i * Math.sqrt(g) / f, v = _ * b / p, T = y * b / g, P = _ * d + y * h, M = _ * u + y * l, D = h * (y + v), R = l * (y + v), F = d * (_ + T), C = u * (_ + T), A = Math.atan2(R - M, D - P), ct = Math.atan2(C - M, F - P); qi(r, P + t, M + e, i, A, ct, h * u > d * l) } var Ap = m(() => { Zl(); c(Ql, "buildArcTo") }); function NS (r, t) { let e = t === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(t / 4), s = t === 1.5707963267948966 ? .551915024494 : e, o = Math.cos(r), i = Math.sin(r), n = Math.cos(r + t), a = Math.sin(r + t); return [{ x: o - i * s, y: i + o * s }, { x: n + a * s, y: a - n * s }, { x: n, y: a }] } function tu (r, t, e, s, o, i, n, a = 0, l = 0, h = 0) { if (i === 0 || n === 0) return; let u = Math.sin(a * Jl / 360), d = Math.cos(a * Jl / 360), f = d * (t - s) / 2 + u * (e - o) / 2, p = -u * (t - s) / 2 + d * (e - o) / 2; if (f === 0 && p === 0) return; i = Math.abs(i), n = Math.abs(n); let g = Math.pow(f, 2) / Math.pow(i, 2) + Math.pow(p, 2) / Math.pow(n, 2); g > 1 && (i *= Math.sqrt(g), n *= Math.sqrt(g)), WS(t, e, s, o, i, n, l, h, u, d, f, p, X_); let { ang1: b, ang2: _ } = X_, { centerX: y, centerY: v } = X_, T = Math.abs(_) / (Jl / 4); Math.abs(1 - T) < 1e-7 && (T = 1); let P = Math.max(Math.ceil(T), 1); _ /= P; let M = r[r.length - 2], D = r[r.length - 1], R = { x: 0, y: 0 }; for (let F = 0; F < P; F++) { let C = NS(b, _), { x: A, y: ct } = z_(C[0], i, n, d, u, y, v, R), { x: nt, y: L } = z_(C[1], i, n, d, u, y, v, R), { x: z, y: Et } = z_(C[2], i, n, d, u, y, v, R); Ki(r, M, D, A, ct, nt, L, z, Et), M = z, D = Et, b += _ } } var Jl, X_, z_, uv, WS, wp = m(() => { Kl(); Jl = Math.PI * 2, X_ = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 }, z_ = c(({ x: r, y: t }, e, s, o, i, n, a, l) => { r *= e, t *= s; let h = o * r - i * t, u = i * r + o * t; return l.x = h + n, l.y = u + a, l }, "mapToEllipse"); c(NS, "approxUnitArc"); uv = c((r, t, e, s) => { let o = r * s - t * e < 0 ? -1 : 1, i = r * e + t * s; return i > 1 && (i = 1), i < -1 && (i = -1), o * Math.acos(i) }, "vectorAngle"), WS = c((r, t, e, s, o, i, n, a, l, h, u, d, f) => { let p = Math.pow(o, 2), g = Math.pow(i, 2), b = Math.pow(u, 2), _ = Math.pow(d, 2), y = p * g - p * _ - g * b; y < 0 && (y = 0), y /= p * _ + g * b, y = Math.sqrt(y) * (n === a ? -1 : 1); let v = y * o / i * d, T = y * -i / o * u, P = h * v - l * T + (r + e) / 2, M = l * v + h * T + (t + s) / 2, D = (u - v) / o, R = (d - T) / i, F = (-u - v) / o, C = (-d - T) / i, A = uv(1, 0, D, R), ct = uv(D, R, F, C); a === 0 && ct > 0 && (ct -= Jl), a === 1 && ct < 0 && (ct += Jl), f.centerX = P, f.centerY = M, f.ang1 = A, f.ang2 = ct }, "getArcCenter"); c(tu, "buildArcToSvg") }); function eu (r, t, e) { let s = c((n, a) => { let l = a.x - n.x, h = a.y - n.y, u = Math.sqrt(l * l + h * h), d = l / u, f = h / u; return { len: u, nx: d, ny: f } }, "vecFrom"), o = c((n, a) => { n === 0 ? r.moveTo(a.x, a.y) : r.lineTo(a.x, a.y) }, "sharpCorner"), i = t[t.length - 1]; for (let n = 0; n < t.length; n++) { let a = t[n % t.length], l = a.radius ?? e; if (l <= 0) { o(n, a), i = a; continue } let h = t[(n + 1) % t.length], u = s(a, i), d = s(a, h); if (u.len < 1e-4 || d.len < 1e-4) { o(n, a), i = a; continue } let f = Math.asin(u.nx * d.ny - u.ny * d.nx), p = 1, g = !1; u.nx * d.nx - u.ny * -d.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, p = -1, g = !0) : f > 0 && (p = -1, g = !0); let b = f / 2, _, y = Math.abs(Math.cos(b) * l / Math.sin(b)); y > Math.min(u.len / 2, d.len / 2) ? (y = Math.min(u.len / 2, d.len / 2), _ = Math.abs(y * Math.sin(b) / Math.cos(b))) : _ = l; let v = a.x + d.nx * y + -d.ny * _ * p, T = a.y + d.ny * y + d.nx * _ * p, P = Math.atan2(u.ny, u.nx) + Math.PI / 2 * p, M = Math.atan2(d.ny, d.nx) - Math.PI / 2 * p; n === 0 && r.moveTo(v + Math.cos(P) * _, T + Math.sin(P) * _), r.arc(v, T, _, P, M, g), i = a } } function ru (r, t, e, s) { let o = c((a, l) => Math.sqrt((a.x - l.x) ** 2 + (a.y - l.y) ** 2), "distance"), i = c((a, l, h) => ({ x: a.x + (l.x - a.x) * h, y: a.y + (l.y - a.y) * h }), "pointLerp"), n = t.length; for (let a = 0; a < n; a++) { let l = t[(a + 1) % n], h = l.radius ?? e; if (h <= 0) { a === 0 ? r.moveTo(l.x, l.y) : r.lineTo(l.x, l.y); continue } let u = t[a], d = t[(a + 2) % n], f = o(u, l), p; if (f < 1e-4) p = l; else { let _ = Math.min(f / 2, h); p = i(l, u, _ / f) } let g = o(d, l), b; if (g < 1e-4) b = l; else { let _ = Math.min(g / 2, h); b = i(l, d, _ / g) } a === 0 ? r.moveTo(p.x, p.y) : r.lineTo(p.x, p.y), r.quadraticCurveTo(l.x, l.y, b.x, b.y, s) } } var Rp = m(() => { "use strict"; c(eu, "roundedShapeArc"); c(ru, "roundedShapeQuadraticCurve") }); var XS, Uo, Mp = m(() => { vp(); Sp(); Tp(); Gt(); Pp(); te(); Kl(); Bp(); Zl(); Ap(); wp(); Rp(); XS = new H, Uo = class { constructor(t) { this.shapePrimitives = [], this._currentPoly = null, this._bounds = new it, this._graphicsPath2D = t } moveTo (t, e) { return this.startPoly(t, e), this } lineTo (t, e) { this._ensurePoly(); let s = this._currentPoly.points, o = s[s.length - 2], i = s[s.length - 1]; return (o !== t || i !== e) && s.push(t, e), this } arc (t, e, s, o, i, n) { this._ensurePoly(!1); let a = this._currentPoly.points; return qi(a, t, e, s, o, i, n), this } arcTo (t, e, s, o, i) { this._ensurePoly(); let n = this._currentPoly.points; return Ql(n, t, e, s, o, i), this } arcToSvg (t, e, s, o, i, n, a) { let l = this._currentPoly.points; return tu(l, this._currentPoly.lastX, this._currentPoly.lastY, n, a, t, e, s, o, i), this } bezierCurveTo (t, e, s, o, i, n, a) { this._ensurePoly(); let l = this._currentPoly; return Ki(this._currentPoly.points, l.lastX, l.lastY, t, e, s, o, i, n, a), this } quadraticCurveTo (t, e, s, o, i) { this._ensurePoly(); let n = this._currentPoly; return ql(this._currentPoly.points, n.lastX, n.lastY, t, e, s, o, i), this } closePath () { return this.endPoly(!0), this } addPath (t, e) { this.endPoly(), e && !e.isIdentity() && (t = t.clone(!0), t.transform(e)); for (let s = 0; s < t.instructions.length; s++) { let o = t.instructions[s]; this[o.action](...o.data) } return this } finish (t = !1) { this.endPoly(t) } rect (t, e, s, o, i) { return this.drawShape(new H(t, e, s, o), i), this } circle (t, e, s, o) { return this.drawShape(new yr(t, e, s), o), this } poly (t, e, s) { let o = new ke(t); return o.closePath = e, this.drawShape(o, s), this } regularPoly (t, e, s, o, i = 0, n) { o = Math.max(o | 0, 3); let a = -1 * Math.PI / 2 + i, l = Math.PI * 2 / o, h = []; for (let u = 0; u < o; u++) { let d = u * l + a; h.push(t + s * Math.cos(d), e + s * Math.sin(d)) } return this.poly(h, !0, n), this } roundPoly (t, e, s, o, i, n = 0, a) { if (o = Math.max(o | 0, 3), i <= 0) return this.regularPoly(t, e, s, o, n); let l = s * Math.sin(Math.PI / o) - .001; i = Math.min(i, l); let h = -1 * Math.PI / 2 + n, u = Math.PI * 2 / o, d = (o - 2) * Math.PI / o / 2; for (let f = 0; f < o; f++) { let p = f * u + h, g = t + s * Math.cos(p), b = e + s * Math.sin(p), _ = p + Math.PI + d, y = p - Math.PI - d, v = g + i * Math.cos(_), T = b + i * Math.sin(_), P = g + i * Math.cos(y), M = b + i * Math.sin(y); f === 0 ? this.moveTo(v, T) : this.lineTo(v, T), this.quadraticCurveTo(g, b, P, M, a) } return this.closePath() } roundShape (t, e, s = !1, o) { return t.length < 3 ? this : (s ? ru(this, t, e, o) : eu(this, t, e), this.closePath()) } filletRect (t, e, s, o, i) { if (i === 0) return this.rect(t, e, s, o); let n = Math.min(s, o) / 2, a = Math.min(n, Math.max(-n, i)), l = t + s, h = e + o, u = a < 0 ? -a : 0, d = Math.abs(a); return this.moveTo(t, e + d).arcTo(t + u, e + u, t + d, e, d).lineTo(l - d, e).arcTo(l - u, e + u, l, e + d, d).lineTo(l, h - d).arcTo(l - u, h - u, t + s - d, h, d).lineTo(t + d, h).arcTo(t + u, h - u, t, h - d, d).closePath() } chamferRect (t, e, s, o, i, n) { if (i <= 0) return this.rect(t, e, s, o); let a = Math.min(i, Math.min(s, o) / 2), l = t + s, h = e + o, u = [t + a, e, l - a, e, l, e + a, l, h - a, l - a, h, t + a, h, t, h - a, t, e + a]; for (let d = u.length - 1; d >= 2; d -= 2)u[d] === u[d - 2] && u[d - 1] === u[d - 3] && u.splice(d - 1, 2); return this.poly(u, !0, n) } ellipse (t, e, s, o, i) { return this.drawShape(new vr(t, e, s, o), i), this } roundRect (t, e, s, o, i, n) { return this.drawShape(new Sr(t, e, s, o, i), n), this } drawShape (t, e) { return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: e }), this } startPoly (t, e) { let s = this._currentPoly; return s && this.endPoly(), s = new ke, s.points.push(t, e), this._currentPoly = s, this } endPoly (t = !1) { let e = this._currentPoly; return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({ shape: e })), this._currentPoly = null, this } _ensurePoly (t = !0) { if (!this._currentPoly && (this._currentPoly = new ke, t)) { let e = this.shapePrimitives[this.shapePrimitives.length - 1]; if (e) { let s = e.shape.x, o = e.shape.y; if (!e.transform.isIdentity()) { let i = e.transform, n = s; s = i.a * s + i.c * o + i.tx, o = i.b * n + i.d * o + i.ty } this._currentPoly.points.push(s, o) } else this._currentPoly.points.push(0, 0) } } buildPath () { let t = this._graphicsPath2D; this.shapePrimitives.length = 0, this._currentPoly = null; for (let e = 0; e < t.instructions.length; e++) { let s = t.instructions[e]; this[s.action](...s.data) } this.finish() } get bounds () { let t = this._bounds; t.clear(); let e = this.shapePrimitives; for (let s = 0; s < e.length; s++) { let o = e[s], i = o.shape.getBounds(XS); o.transform ? t.addRect(i, o.transform) : t.addRect(i) } return t } }; c(Uo, "ShapePath") }); function su (r, t) { return r ? r.prepend(t) : t.clone() } var ne, wa = m(() => { ce(); Wt(); ut(); yp(); Mp(); ne = class { constructor(t) { this.instructions = [], this.uid = Z("graphicsPath"), this._dirty = !0, typeof t == "string" ? $l(t, this) : this.instructions = t?.slice() ?? [] } get shapePath () { return this._shapePath || (this._shapePath = new Uo(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath } addPath (t, e) { return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, e] }), this._dirty = !0, this } arc (...t) { return this.instructions.push({ action: "arc", data: t }), this._dirty = !0, this } arcTo (...t) { return this.instructions.push({ action: "arcTo", data: t }), this._dirty = !0, this } arcToSvg (...t) { return this.instructions.push({ action: "arcToSvg", data: t }), this._dirty = !0, this } bezierCurveTo (...t) { return this.instructions.push({ action: "bezierCurveTo", data: t }), this._dirty = !0, this } bezierCurveToShort (t, e, s, o, i) { let n = this.instructions[this.instructions.length - 1], a = this.getLastPoint(V.shared), l = 0, h = 0; if (!n || n.action !== "bezierCurveTo") l = a.x, h = a.y; else { l = n.data[2], h = n.data[3]; let u = a.x, d = a.y; l = u + (u - l), h = d + (d - h) } return this.instructions.push({ action: "bezierCurveTo", data: [l, h, t, e, s, o, i] }), this._dirty = !0, this } closePath () { return this.instructions.push({ action: "closePath", data: [] }), this._dirty = !0, this } ellipse (...t) { return this.instructions.push({ action: "ellipse", data: t }), this._dirty = !0, this } lineTo (...t) { return this.instructions.push({ action: "lineTo", data: t }), this._dirty = !0, this } moveTo (...t) { return this.instructions.push({ action: "moveTo", data: t }), this } quadraticCurveTo (...t) { return this.instructions.push({ action: "quadraticCurveTo", data: t }), this._dirty = !0, this } quadraticCurveToShort (t, e, s) { let o = this.instructions[this.instructions.length - 1], i = this.getLastPoint(V.shared), n = 0, a = 0; if (!o || o.action !== "quadraticCurveTo") n = i.x, a = i.y; else { n = o.data[0], a = o.data[1]; let l = i.x, h = i.y; n = l + (l - n), a = h + (h - a) } return this.instructions.push({ action: "quadraticCurveTo", data: [n, a, t, e, s] }), this._dirty = !0, this } rect (t, e, s, o, i) { return this.instructions.push({ action: "rect", data: [t, e, s, o, i] }), this._dirty = !0, this } circle (t, e, s, o) { return this.instructions.push({ action: "circle", data: [t, e, s, o] }), this._dirty = !0, this } roundRect (...t) { return this.instructions.push({ action: "roundRect", data: t }), this._dirty = !0, this } poly (...t) { return this.instructions.push({ action: "poly", data: t }), this._dirty = !0, this } regularPoly (...t) { return this.instructions.push({ action: "regularPoly", data: t }), this._dirty = !0, this } roundPoly (...t) { return this.instructions.push({ action: "roundPoly", data: t }), this._dirty = !0, this } roundShape (...t) { return this.instructions.push({ action: "roundShape", data: t }), this._dirty = !0, this } filletRect (...t) { return this.instructions.push({ action: "filletRect", data: t }), this._dirty = !0, this } chamferRect (...t) { return this.instructions.push({ action: "chamferRect", data: t }), this._dirty = !0, this } star (t, e, s, o, i, n, a) { i = i || o / 2; let l = -1 * Math.PI / 2 + n, h = s * 2, u = Math.PI * 2 / h, d = []; for (let f = 0; f < h; f++) { let p = f % 2 ? i : o, g = f * u + l; d.push(t + p * Math.cos(g), e + p * Math.sin(g)) } return this.poly(d, !0, a), this } clone (t = !1) { let e = new ne; if (!t) e.instructions = this.instructions.slice(); else for (let s = 0; s < this.instructions.length; s++) { let o = this.instructions[s]; e.instructions.push({ action: o.action, data: o.data.slice() }) } return e } clear () { return this.instructions.length = 0, this._dirty = !0, this } transform (t) { if (t.isIdentity()) return this; let e = t.a, s = t.b, o = t.c, i = t.d, n = t.tx, a = t.ty, l = 0, h = 0, u = 0, d = 0, f = 0, p = 0, g = 0, b = 0; for (let _ = 0; _ < this.instructions.length; _++) { let y = this.instructions[_], v = y.data; switch (y.action) { case "moveTo": case "lineTo": l = v[0], h = v[1], v[0] = e * l + o * h + n, v[1] = s * l + i * h + a; break; case "bezierCurveTo": u = v[0], d = v[1], f = v[2], p = v[3], l = v[4], h = v[5], v[0] = e * u + o * d + n, v[1] = s * u + i * d + a, v[2] = e * f + o * p + n, v[3] = s * f + i * p + a, v[4] = e * l + o * h + n, v[5] = s * l + i * h + a; break; case "quadraticCurveTo": u = v[0], d = v[1], l = v[2], h = v[3], v[0] = e * u + o * d + n, v[1] = s * u + i * d + a, v[2] = e * l + o * h + n, v[3] = s * l + i * h + a; break; case "arcToSvg": l = v[5], h = v[6], g = v[0], b = v[1], v[0] = e * g + o * b, v[1] = s * g + i * b, v[5] = e * l + o * h + n, v[6] = s * l + i * h + a; break; case "circle": v[4] = su(v[3], t); break; case "rect": v[4] = su(v[4], t); break; case "ellipse": v[8] = su(v[8], t); break; case "roundRect": v[5] = su(v[5], t); break; case "addPath": v[0].transform(t); break; case "poly": v[2] = su(v[2], t); break; default: U("unknown transform action", y.action); break } } return this._dirty = !0, this } get bounds () { return this.shapePath.bounds } getLastPoint (t) { let e = this.instructions.length - 1, s = this.instructions[e]; if (!s) return t.x = 0, t.y = 0, t; for (; s.action === "closePath";) { if (e--, e < 0) return t.x = 0, t.y = 0, t; s = this.instructions[e] } switch (s.action) { case "moveTo": case "lineTo": t.x = s.data[0], t.y = s.data[1]; break; case "quadraticCurveTo": t.x = s.data[2], t.y = s.data[3]; break; case "bezierCurveTo": t.x = s.data[4], t.y = s.data[5]; break; case "arc": case "arcToSvg": t.x = s.data[5], t.y = s.data[6]; break; case "addPath": s.data[0].getLastPoint(t); break }return t } }; c(ne, "GraphicsPath"); c(su, "adjustTransform") }); function ou (r, t) { if (typeof r == "string") { let s = document.createElement("div"); s.innerHTML = r.trim(), r = s.querySelector("svg") } let e = { context: t, path: new ne }; return hv(r, e, null, null), t } function hv (r, t, e, s) { let o = r.children, { fillStyle: i, strokeStyle: n } = zS(r); i && e ? e = { ...e, ...i } : i && (e = i), n && s ? s = { ...s, ...n } : n && (s = n), t.context.fillStyle = e, t.context.strokeStyle = s; let a, l, h, u, d, f, p, g, b, _, y, v, T, P, M, D, R; switch (r.nodeName.toLowerCase()) { case "path": P = r.getAttribute("d"), M = new ne(P), t.context.path(M), e && t.context.fill(), s && t.context.stroke(); break; case "circle": p = zt(r, "cx", 0), g = zt(r, "cy", 0), b = zt(r, "r", 0), t.context.ellipse(p, g, b, b), e && t.context.fill(), s && t.context.stroke(); break; case "rect": a = zt(r, "x", 0), l = zt(r, "y", 0), D = zt(r, "width", 0), R = zt(r, "height", 0), _ = zt(r, "rx", 0), y = zt(r, "ry", 0), _ || y ? t.context.roundRect(a, l, D, R, _ || y) : t.context.rect(a, l, D, R), e && t.context.fill(), s && t.context.stroke(); break; case "ellipse": p = zt(r, "cx", 0), g = zt(r, "cy", 0), _ = zt(r, "rx", 0), y = zt(r, "ry", 0), t.context.beginPath(), t.context.ellipse(p, g, _, y), e && t.context.fill(), s && t.context.stroke(); break; case "line": h = zt(r, "x1", 0), u = zt(r, "y1", 0), d = zt(r, "x2", 0), f = zt(r, "y2", 0), t.context.beginPath(), t.context.moveTo(h, u), t.context.lineTo(d, f), s && t.context.stroke(); break; case "polygon": T = r.getAttribute("points"), v = T.match(/\d+/g).map(F => parseInt(F, 10)), t.context.poly(v, !0), e && t.context.fill(), s && t.context.stroke(); break; case "polyline": T = r.getAttribute("points"), v = T.match(/\d+/g).map(F => parseInt(F, 10)), t.context.poly(v, !1), s && t.context.stroke(); break; case "g": case "svg": break; default: { console.info(`[SVG parser] <${r.nodeName}> elements unsupported`); break } }for (let F = 0; F < o.length; F++)hv(o[F], t, e, s) } function zt (r, t, e) { let s = r.getAttribute(t); return s ? Number(s) : e } function zS (r) { let t = r.getAttribute("style"), e = {}, s = {}, o = !1, i = !1; if (t) { let n = t.split(";"); for (let a = 0; a < n.length; a++) { let l = n[a], [h, u] = l.split(":"); switch (h) { case "stroke": u !== "none" && (e.color = j.shared.setValue(u).toNumber(), i = !0); break; case "stroke-width": e.width = Number(u); break; case "fill": u !== "none" && (o = !0, s.color = j.shared.setValue(u).toNumber()); break; case "fill-opacity": s.alpha = Number(u); break; case "stroke-opacity": e.alpha = Number(u); break; case "opacity": s.alpha = Number(u), e.alpha = Number(u); break } } } else { let n = r.getAttribute("stroke"); n && n !== "none" && (i = !0, e.color = j.shared.setValue(n).toNumber(), e.width = zt(r, "stroke-width", 1)); let a = r.getAttribute("fill"); a && a !== "none" && (o = !0, s.color = j.shared.setValue(a).toNumber()) } return { strokeStyle: i ? e : null, fillStyle: o ? s : null } } var Gp = m(() => { $t(); wa(); c(ou, "SVGParser"); c(hv, "renderChildren"); c(zt, "parseFloatAttribute"); c(zS, "parseStyle") }); var dv, Tr, iu = m(() => { ot(); Wt(); dv = { repeat: { addressModeU: "repeat", addressModeV: "repeat" }, "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" }, "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" }, "no-repeat": { addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" } }, Tr = class { constructor(t, e) { this.uid = Z("fillPattern"), this.transform = new B, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), e && (t.source.style.addressModeU = dv[e].addressModeU, t.source.style.addressModeV = dv[e].addressModeV) } setTransform (t) { let e = this.texture; this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / e.frame.width, 1 / e.frame.height) } }; c(Tr, "FillPattern") }); function Te (r, t) { if (r == null) return null; let e, s; if (r?.fill ? (s = r.fill, e = { ...t, ...r }) : (s = r, e = t), j.isColorLike(s)) { let n = j.shared.setValue(s ?? 0); return { ...e, color: n.toNumber(), alpha: n.alpha === 1 ? e.alpha : n.alpha, texture: E.WHITE } } else if (s instanceof Tr) { let n = s; return { ...e, color: 16777215, texture: n.texture, matrix: n.transform, fill: e.fill ?? null } } else if (s instanceof is) { let n = s; return n.buildLinearGradient(), { ...e, color: 16777215, texture: n.texture, matrix: n.transform } } let o = { ...t, ...r }; if (o.texture) { if (o.texture !== E.WHITE) { let a = o.matrix?.invert() || new B; a.scale(1 / o.texture.frame.width, 1 / o.texture.frame.height), o.matrix = a } let n = o.texture.source.style; n.addressMode === "clamp-to-edge" && (n.addressMode = "repeat") } let i = j.shared.setValue(o.color); return o.alpha *= i.alpha, o.color = i.toNumber(), o.matrix = o.matrix ? o.matrix.clone() : null, o } var nu = m(() => { $t(); ot(); rt(); Ba(); iu(); c(Te, "convertFillInputToFillStyle") }); var pv, VS, fv, V_, Vt, Fo = m(() => { pv = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); $t(); ot(); ce(); rt(); Wt(); lt(); te(); wa(); Gp(); nu(); VS = new V, fv = new B, V_ = c(class Er extends pv.default { constructor() { super(...arguments), this.uid = Z("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new ne, this._transform = new B, this._fillStyle = { ...Er.defaultFillStyle }, this._strokeStyle = { ...Er.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new it, this._boundsDirty = !0 } clone () { let t = new Er; return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = { ...this._fillStyle }, t._strokeStyle = { ...this._strokeStyle }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = !0, t } get fillStyle () { return this._fillStyle } set fillStyle (t) { this._fillStyle = Te(t, Er.defaultFillStyle) } get strokeStyle () { return this._strokeStyle } set strokeStyle (t) { this._strokeStyle = Te(t, Er.defaultStrokeStyle) } setFillStyle (t) { return this._fillStyle = Te(t, Er.defaultFillStyle), this } setStrokeStyle (t) { return this._strokeStyle = Te(t, Er.defaultStrokeStyle), this } texture (t, e, s, o, i, n) { return this.instructions.push({ action: "texture", data: { image: t, dx: s || 0, dy: o || 0, dw: i || t.frame.width, dh: n || t.frame.height, transform: this._transform.clone(), alpha: this._fillStyle.alpha, style: e ? j.shared.setValue(e).toNumber() : 16777215 } }), this.onUpdate(), this } beginPath () { return this._activePath = new ne, this } fill (t, e) { let s, o = this.instructions[this.instructions.length - 1]; return this._tick === 0 && o && o.action === "stroke" ? s = o.data.path : s = this._activePath.clone(), s ? (t != null && (e !== void 0 && typeof t == "number" && (w(G, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = { color: t, alpha: e }), this._fillStyle = Te(t, Er.defaultFillStyle)), this.instructions.push({ action: "fill", data: { style: this.fillStyle, path: s } }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this } _initNextPathLocation () { let { x: t, y: e } = this._activePath.getLastPoint(V.shared); this._activePath.clear(), this._activePath.moveTo(t, e) } stroke (t) { let e, s = this.instructions[this.instructions.length - 1]; return this._tick === 0 && s && s.action === "fill" ? e = s.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = Te(t, Er.defaultStrokeStyle)), this.instructions.push({ action: "stroke", data: { style: this.strokeStyle, path: e } }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this } cut () { for (let t = 0; t < 2; t++) { let e = this.instructions[this.instructions.length - 1 - t], s = this._activePath.clone(); if (e && (e.action === "stroke" || e.action === "fill")) if (e.data.hole) e.data.hole.addPath(s); else { e.data.hole = s; break } } return this._initNextPathLocation(), this } arc (t, e, s, o, i, n) { this._tick++; let a = this._transform; return this._activePath.arc(a.a * t + a.c * e + a.tx, a.b * t + a.d * e + a.ty, s, o, i, n), this } arcTo (t, e, s, o, i) { this._tick++; let n = this._transform; return this._activePath.arcTo(n.a * t + n.c * e + n.tx, n.b * t + n.d * e + n.ty, n.a * s + n.c * o + n.tx, n.b * s + n.d * o + n.ty, i), this } arcToSvg (t, e, s, o, i, n, a) { this._tick++; let l = this._transform; return this._activePath.arcToSvg(t, e, s, o, i, l.a * n + l.c * a + l.tx, l.b * n + l.d * a + l.ty), this } bezierCurveTo (t, e, s, o, i, n, a) { this._tick++; let l = this._transform; return this._activePath.bezierCurveTo(l.a * t + l.c * e + l.tx, l.b * t + l.d * e + l.ty, l.a * s + l.c * o + l.tx, l.b * s + l.d * o + l.ty, l.a * i + l.c * n + l.tx, l.b * i + l.d * n + l.ty, a), this } closePath () { return this._tick++, this._activePath?.closePath(), this } ellipse (t, e, s, o) { return this._tick++, this._activePath.ellipse(t, e, s, o, this._transform.clone()), this } circle (t, e, s) { return this._tick++, this._activePath.circle(t, e, s, this._transform.clone()), this } path (t) { return this._tick++, this._activePath.addPath(t, this._transform.clone()), this } lineTo (t, e) { this._tick++; let s = this._transform; return this._activePath.lineTo(s.a * t + s.c * e + s.tx, s.b * t + s.d * e + s.ty), this } moveTo (t, e) { this._tick++; let s = this._transform, o = this._activePath.instructions, i = s.a * t + s.c * e + s.tx, n = s.b * t + s.d * e + s.ty; return o.length === 1 && o[0].action === "moveTo" ? (o[0].data[0] = i, o[0].data[1] = n, this) : (this._activePath.moveTo(i, n), this) } quadraticCurveTo (t, e, s, o, i) { this._tick++; let n = this._transform; return this._activePath.quadraticCurveTo(n.a * t + n.c * e + n.tx, n.b * t + n.d * e + n.ty, n.a * s + n.c * o + n.tx, n.b * s + n.d * o + n.ty, i), this } rect (t, e, s, o) { return this._tick++, this._activePath.rect(t, e, s, o, this._transform.clone()), this } roundRect (t, e, s, o, i) { return this._tick++, this._activePath.roundRect(t, e, s, o, i, this._transform.clone()), this } poly (t, e) { return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this } regularPoly (t, e, s, o, i = 0, n) { return this._tick++, this._activePath.regularPoly(t, e, s, o, i, n), this } roundPoly (t, e, s, o, i, n) { return this._tick++, this._activePath.roundPoly(t, e, s, o, i, n), this } roundShape (t, e, s, o) { return this._tick++, this._activePath.roundShape(t, e, s, o), this } filletRect (t, e, s, o, i) { return this._tick++, this._activePath.filletRect(t, e, s, o, i), this } chamferRect (t, e, s, o, i, n) { return this._tick++, this._activePath.chamferRect(t, e, s, o, i, n), this } star (t, e, s, o, i = 0, n = 0) { return this._tick++, this._activePath.star(t, e, s, o, i, n, this._transform.clone()), this } svg (t) { return this._tick++, ou(t, this), this } restore () { let t = this._stateStack.pop(); return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this } save () { return this._stateStack.push({ transform: this._transform.clone(), fillStyle: { ...this._fillStyle }, strokeStyle: { ...this._strokeStyle } }), this } getTransform () { return this._transform } resetTransform () { return this._transform.identity(), this } rotate (t) { return this._transform.rotate(t), this } scale (t, e = t) { return this._transform.scale(t, e), this } setTransform (t, e, s, o, i, n) { return t instanceof B ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, s, o, i, n), this) } transform (t, e, s, o, i, n) { return t instanceof B ? (this._transform.append(t), this) : (fv.set(t, e, s, o, i, n), this._transform.append(fv), this) } translate (t, e = t) { return this._transform.translate(t, e), this } clear () { return this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this } onUpdate () { this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0) } get bounds () { if (!this._boundsDirty) return this._bounds; let t = this._bounds; t.clear(); for (let e = 0; e < this.instructions.length; e++) { let s = this.instructions[e], o = s.action; if (o === "fill") { let i = s.data; t.addBounds(i.path.bounds) } else if (o === "texture") { let i = s.data; t.addFrame(i.dx, i.dy, i.dx + i.dw, i.dy + i.dh, i.transform) } if (o === "stroke") { let i = s.data, n = i.style.width / 2, a = i.path.bounds; t.addFrame(a.minX - n, a.minY - n, a.maxX + n, a.maxY + n) } } return t } containsPoint (t) { if (!this.bounds.containsPoint(t.x, t.y)) return !1; let e = this.instructions, s = !1; for (let o = 0; o < e.length; o++) { let i = e[o], n = i.data, a = n.path; if (!i.action || !a) continue; let l = n.style, h = a.shapePath.shapePrimitives; for (let u = 0; u < h.length; u++) { let d = h[u].shape; if (!l || !d) continue; let f = h[u].transform, p = f ? f.applyInverse(t, VS) : t; i.action === "fill" ? s = d.contains(p.x, p.y) : s = d.strokeContains(p.x, p.y, l.width); let g = n.hole; if (g) { let b = g.shapePath?.shapePrimitives; if (b) for (let _ = 0; _ < b.length; _++)b[_].shape.contains(p.x, p.y) && (s = !1) } if (s) return !0 } } return s } destroy (t = !1) { if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) { let s = typeof t == "boolean" ? t : t?.textureSource; this._fillStyle.texture && this._fillStyle.texture.destroy(s), this._strokeStyle.texture && this._strokeStyle.texture.destroy(s) } this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null } }, "_GraphicsContext"); V_.defaultFillStyle = { color: 16777215, alpha: 1, texture: E.WHITE, matrix: null, fill: null }; V_.defaultStrokeStyle = { width: 1, color: 16777215, alpha: 1, alignment: .5, miterLimit: 10, cap: "butt", join: "miter", texture: E.WHITE, matrix: null, fill: null }; Vt = V_ }); function Zi (r) { let t = [], e = 0; for (let s = 0; s < mv.length; s++) { let o = mv[s]; t[e++] = r[o] } return e = xv(r._fill, t, e), e = YS(r._stroke, t, e), t.join("-") } function xv (r, t, e) { return r && (t[e++] = r.color, t[e++] = r.alpha, t[e++] = r.fill?.uid), e } function YS (r, t, e) { return r && (e = xv(r, t, e), t[e++] = r.width, t[e++] = r.alignment, t[e++] = r.cap, t[e++] = r.join, t[e++] = r.miterLimit), e } var mv, au = m(() => { "use strict"; mv = ["_fontFamily", "_fontStyle", "_fontSize", "_fontVariant", "_fontWeight", "_breakWords", "_align", "_leading", "_letterSpacing", "_lineHeight", "_textBaseline", "_whiteSpace", "_wordWrap", "_wordWrapWidth", "_padding", "_cssOverrides", "_trim"]; c(Zi, "generateTextStyleKey"); c(xv, "addFillStyleKey"); c(YS, "addStokeStyleKey") }); function $S (r) { let t = r; if (typeof t.dropShadow == "boolean" && t.dropShadow) { let e = Ht.defaultDropShadow; r.dropShadow = { alpha: t.dropShadowAlpha ?? e.alpha, angle: t.dropShadowAngle ?? e.angle, blur: t.dropShadowBlur ?? e.blur, color: t.dropShadowColor ?? e.color, distance: t.dropShadowDistance ?? e.distance } } if (t.strokeThickness !== void 0) { w(G, "strokeThickness is now a part of stroke"); let e = t.stroke; r.stroke = { color: e, width: t.strokeThickness } } if (Array.isArray(t.fill)) { w(G, "gradient fill is now a fill pattern: `new FillGradient(...)`"); let e = new is(0, 0, 0, r.fontSize * 1.7), s = t.fill.map(o => j.shared.setValue(o).toNumber()); s.forEach((o, i) => { let n = t.fillGradientStops[i] ?? i / s.length; e.addColorStop(n, o) }), r.fill = { fill: e } } } var gv, Y_, Ht, as = m(() => { gv = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); $t(); lt(); Ba(); Fo(); nu(); au(); Y_ = c(class Ra extends gv.default { constructor(t = {}) { super(), $S(t); let e = { ...Ra.defaultTextStyle, ...t }; for (let s in e) { let o = s; this[o] = e[s] } this.update() } get align () { return this._align } set align (t) { this._align = t, this.update() } get breakWords () { return this._breakWords } set breakWords (t) { this._breakWords = t, this.update() } get dropShadow () { return this._dropShadow } set dropShadow (t) { t !== null && typeof t == "object" ? this._dropShadow = { ...Ra.defaultDropShadow, ...t } : this._dropShadow = t ? { ...Ra.defaultDropShadow } : null, this.update() } get fontFamily () { return this._fontFamily } set fontFamily (t) { this._fontFamily = t, this.update() } get fontSize () { return this._fontSize } set fontSize (t) { typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update() } get fontStyle () { return this._fontStyle } set fontStyle (t) { this._fontStyle = t, this.update() } get fontVariant () { return this._fontVariant } set fontVariant (t) { this._fontVariant = t, this.update() } get fontWeight () { return this._fontWeight } set fontWeight (t) { this._fontWeight = t, this.update() } get leading () { return this._leading } set leading (t) { this._leading = t, this.update() } get letterSpacing () { return this._letterSpacing } set letterSpacing (t) { this._letterSpacing = t, this.update() } get lineHeight () { return this._lineHeight } set lineHeight (t) { this._lineHeight = t, this.update() } get padding () { return this._padding } set padding (t) { this._padding = t, this.update() } get trim () { return this._trim } set trim (t) { this._trim = t, this.update() } get textBaseline () { return this._textBaseline } set textBaseline (t) { this._textBaseline = t, this.update() } get whiteSpace () { return this._whiteSpace } set whiteSpace (t) { this._whiteSpace = t, this.update() } get wordWrap () { return this._wordWrap } set wordWrap (t) { this._wordWrap = t, this.update() } get wordWrapWidth () { return this._wordWrapWidth } set wordWrapWidth (t) { this._wordWrapWidth = t, this.update() } get fill () { return this._originalFill } set fill (t) { t !== this._originalFill && (this._originalFill = t, this._fill = Te(t === 0 ? "black" : t, Vt.defaultFillStyle), this.update()) } get stroke () { return this._originalStroke } set stroke (t) { t !== this._originalStroke && (this._originalStroke = t, this._stroke = Te(t, Vt.defaultStrokeStyle), this.update()) } _generateKey () { return this._styleKey = Zi(this), this._styleKey } update () { this._styleKey = null, this.emit("update", this) } reset () { let t = Ra.defaultTextStyle; for (let e in t) this[e] = t[e] } get styleKey () { return this._styleKey || this._generateKey() } clone () { return new Ra({ align: this.align, breakWords: this.breakWords, dropShadow: this.dropShadow, fill: this._fill, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, leading: this.leading, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this._stroke, textBaseline: this.textBaseline, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth }) } destroy (t = !1) { if (this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture) { let s = typeof t == "boolean" ? t : t?.textureSource; this._fill?.texture && this._fill.texture.destroy(s), this._originalFill?.texture && this._originalFill.texture.destroy(s), this._stroke?.texture && this._stroke.texture.destroy(s), this._originalStroke?.texture && this._originalStroke.texture.destroy(s) } this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null } }, "_TextStyle"); Y_.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: "black", distance: 5 }; Y_.defaultTextStyle = { align: "left", breakWords: !1, dropShadow: null, fill: "black", fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", leading: 0, letterSpacing: 0, lineHeight: 0, padding: 0, stroke: null, textBaseline: "alphabetic", trim: !1, whiteSpace: "pre", wordWrap: !1, wordWrapWidth: 100 }; Ht = Y_; c($S, "convertV7Tov8Style") }); function Qi (r, t, e, s) { let o = jS; o.minX = 0, o.minY = 0, o.maxX = r.width / s | 0, o.maxY = r.height / s | 0; let i = gt.getOptimalTexture(o.width, o.height, s, !1); return i.source.uploadMethodId = "image", i.source.resource = r, i.source.alphaMode = "premultiply-alpha-on-upload", i.frame.width = t / s, i.frame.height = e / s, i.source.emit("update", i.source), i.updateUvs(), i } var jS, cu = m(() => { br(); te(); jS = new it; c(Qi, "getPo2TextureFromSource") }); function Pr (r) { let t = typeof r.fontSize == "number" ? `${r.fontSize}px` : r.fontSize, e = r.fontFamily; Array.isArray(r.fontFamily) || (e = r.fontFamily.split(",")); for (let s = e.length - 1; s >= 0; s--) { let o = e[s].trim(); !/([\"\'])[^\'\"]+\1/.test(o) && !KS.includes(o) && (o = `"${o}"`), e[s] = o } return `${r.fontStyle} ${r.fontVariant} ${r.fontWeight} ${t} ${e.join(",")}` } var KS, Ma = m(() => { "use strict"; KS = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]; c(Pr, "fontStringFromTextStyle") }); var $_, rr, Kt, Ji = m(() => {
          ft(); Ma(); $_ = { willReadFrequently: !0 }, rr = c(class O {
            static get experimentalLetterSpacingSupported () { let t = O._experimentalLetterSpacingSupported; if (t !== void 0) { let e = k.get().getCanvasRenderingContext2D().prototype; t = O._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e } return t } constructor(t, e, s, o, i, n, a, l, h) { this.text = t, this.style = e, this.width = s, this.height = o, this.lines = i, this.lineWidths = n, this.lineHeight = a, this.maxLineWidth = l, this.fontProperties = h } static measureText (t = " ", e, s = O._canvas, o = e.wordWrap) { let i = `${t}:${e.styleKey}`; if (O._measurementCache[i]) return O._measurementCache[i]; let n = Pr(e), a = O.measureFont(n); a.fontSize === 0 && (a.fontSize = e.fontSize, a.ascent = e.fontSize); let l = O.__context; l.font = n; let u = (o ? O._wordWrap(t, e, s) : t).split(/(?:\r\n|\r|\n)/), d = new Array(u.length), f = 0; for (let v = 0; v < u.length; v++) { let T = O._measureText(u[v], e.letterSpacing, l); d[v] = T, f = Math.max(f, T) } let p = e._stroke?.width || 0, g = f + p; e.dropShadow && (g += e.dropShadow.distance); let b = e.lineHeight || a.fontSize + p, _ = Math.max(b, a.fontSize + p * 2) + (u.length - 1) * (b + e.leading); return e.dropShadow && (_ += e.dropShadow.distance), new O(t, e, g, _, u, d, b + e.leading, f, a) } static _measureText (t, e, s) { let o = !1; O.experimentalLetterSpacingSupported && (O.experimentalLetterSpacing ? (s.letterSpacing = `${e}px`, s.textLetterSpacing = `${e}px`, o = !0) : (s.letterSpacing = "0px", s.textLetterSpacing = "0px")); let i = s.measureText(t).width; return i > 0 && (o ? i -= e : i += (O.graphemeSegmenter(t).length - 1) * e), i } static _wordWrap (t, e, s = O._canvas) { let o = s.getContext("2d", $_), i = 0, n = "", a = "", l = Object.create(null), { letterSpacing: h, whiteSpace: u } = e, d = O._collapseSpaces(u), f = O._collapseNewlines(u), p = !d, g = e.wordWrapWidth + h, b = O._tokenize(t); for (let _ = 0; _ < b.length; _++) { let y = b[_]; if (O._isNewline(y)) { if (!f) { a += O._addLine(n), p = !d, n = "", i = 0; continue } y = " " } if (d) { let T = O.isBreakingSpace(y), P = O.isBreakingSpace(n[n.length - 1]); if (T && P) continue } let v = O._getFromCache(y, h, l, o); if (v > g) if (n !== "" && (a += O._addLine(n), n = "", i = 0), O.canBreakWords(y, e.breakWords)) { let T = O.wordWrapSplit(y); for (let P = 0; P < T.length; P++) { let M = T[P], D = M, R = 1; for (; T[P + R];) { let C = T[P + R]; if (!O.canBreakChars(D, C, y, P, e.breakWords)) M += C; else break; D = C, R++ } P += R - 1; let F = O._getFromCache(M, h, l, o); F + i > g && (a += O._addLine(n), p = !1, n = "", i = 0), n += M, i += F } } else { n.length > 0 && (a += O._addLine(n), n = "", i = 0); let T = _ === b.length - 1; a += O._addLine(y, !T), p = !1, n = "", i = 0 } else v + i > g && (p = !1, a += O._addLine(n), n = "", i = 0), (n.length > 0 || !O.isBreakingSpace(y) || p) && (n += y, i += v) } return a += O._addLine(n, !1), a } static _addLine (t, e = !0) {
              return t = O._trimRight(t), t = e ? `${t}
`: t, t
            } static _getFromCache (t, e, s, o) { let i = s[t]; return typeof i != "number" && (i = O._measureText(t, e, o) + e, s[t] = i), i } static _collapseSpaces (t) { return t === "normal" || t === "pre-line" } static _collapseNewlines (t) { return t === "normal" } static _trimRight (t) { if (typeof t != "string") return ""; for (let e = t.length - 1; e >= 0; e--) { let s = t[e]; if (!O.isBreakingSpace(s)) break; t = t.slice(0, -1) } return t } static _isNewline (t) { return typeof t != "string" ? !1 : O._newlines.includes(t.charCodeAt(0)) } static isBreakingSpace (t, e) { return typeof t != "string" ? !1 : O._breakingSpaces.includes(t.charCodeAt(0)) } static _tokenize (t) { let e = [], s = ""; if (typeof t != "string") return e; for (let o = 0; o < t.length; o++) { let i = t[o], n = t[o + 1]; if (O.isBreakingSpace(i, n) || O._isNewline(i)) { s !== "" && (e.push(s), s = ""), e.push(i); continue } s += i } return s !== "" && e.push(s), e } static canBreakWords (t, e) { return e } static canBreakChars (t, e, s, o, i) { return !0 } static wordWrapSplit (t) { return O.graphemeSegmenter(t) } static measureFont (t) { if (O._fonts[t]) return O._fonts[t]; let e = O._context; e.font = t; let s = e.measureText(O.METRICS_STRING + O.BASELINE_SYMBOL), o = { ascent: s.actualBoundingBoxAscent, descent: s.actualBoundingBoxDescent, fontSize: s.actualBoundingBoxAscent + s.actualBoundingBoxDescent }; return O._fonts[t] = o, o } static clearMetrics (t = "") { t ? delete O._fonts[t] : O._fonts = {} } static get _canvas () { if (!O.__canvas) { let t; try { let e = new OffscreenCanvas(0, 0); if (e.getContext("2d", $_)?.measureText) return O.__canvas = e, e; t = k.get().createCanvas() } catch { t = k.get().createCanvas() } t.width = t.height = 10, O.__canvas = t } return O.__canvas } static get _context () { return O.__context || (O.__context = O._canvas.getContext("2d", $_)), O.__context }
          }, "_CanvasTextMetrics"); rr.METRICS_STRING = "|\xC9q\xC5"; rr.BASELINE_SYMBOL = "M"; rr.BASELINE_MULTIPLIER = 1.4; rr.HEIGHT_MULTIPLIER = 2; rr.graphemeSegmenter = (() => { if (typeof Intl?.Segmenter == "function") { let r = new Intl.Segmenter; return t => [...r.segment(t)].map(e => e.segment) } return r => [...r] })(); rr.experimentalLetterSpacing = !1; rr._fonts = {}; rr._newlines = [10, 13]; rr._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]; rr._measurementCache = {}; Kt = rr
        }); function cs (r, t) { if (r.texture === E.WHITE && !r.fill) return j.shared.setValue(r.color).toHex(); if (r.fill) { if (r.fill instanceof Tr) { let e = r.fill, s = t.createPattern(e.texture.source.resource, "repeat"), o = e.transform.copyTo(B.shared); return o.scale(e.texture.frame.width, e.texture.frame.height), s.setTransform(o), s } else if (r.fill instanceof is) { let e = r.fill; if (e.type === "linear") { let s = t.createLinearGradient(e.x0, e.y0, e.x1, e.y1); return e.gradientStops.forEach(o => { s.addColorStop(o.offset, j.shared.setValue(o.color).toHex()) }), s } } } else { let e = t.createPattern(r.texture.source.resource, "repeat"), s = r.matrix.copyTo(B.shared); return s.scale(r.texture.frame.width, r.texture.frame.height), e.setTransform(s), e } return U("FillStyle not recognised", r), "red" } var lu = m(() => { $t(); ot(); rt(); ut(); Ba(); iu(); c(cs, "getCanvasFillStyle") }); var ls, Up = m(() => { $t(); S(); wi(); Yi(); br(); bp(); lt(); as(); cu(); Ji(); Ma(); lu(); ls = class { constructor(t) { this._activeTextures = {}, this._renderer = t } getTextureSize (t, e, s) { let o = Kt.measureText(t || " ", s), i = Math.ceil(Math.ceil(Math.max(1, o.width) + s.padding * 2) * e), n = Math.ceil(Math.ceil(Math.max(1, o.height) + s.padding * 2) * e); return i = Math.ceil(i - 1e-6), n = Math.ceil(n - 1e-6), i = Fe(i), n = Fe(n), { width: i, height: n } } getTexture (t, e, s, o) { typeof t == "string" && (w("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), t = { text: t, style: s, resolution: e }), t.style instanceof Ht || (t.style = new Ht(t.style)); let { texture: i, canvasAndContext: n } = this.createTextureAndCanvas(t); return this._renderer.texture.initSource(i._source), ie.returnCanvasAndContext(n), i } createTextureAndCanvas (t) { let { text: e, style: s } = t, o = t.resolution ?? this._renderer.resolution, i = Kt.measureText(e || " ", s), n = Math.ceil(Math.ceil(Math.max(1, i.width) + s.padding * 2) * o), a = Math.ceil(Math.ceil(Math.max(1, i.height) + s.padding * 2) * o), l = ie.getOptimalCanvasAndContext(n, a), { canvas: h } = l; this.renderTextToCanvas(e, s, o, l); let u = Qi(h, n, a, o); if (s.trim) { let d = Yl(h, o); u.frame.copyFrom(d), u.updateUvs() } return { texture: u, canvasAndContext: l } } getManagedTexture (t) { let e = t._getKey(); if (this._activeTextures[e]) return this._increaseReferenceCount(e), this._activeTextures[e].texture; let { texture: s, canvasAndContext: o } = this.createTextureAndCanvas(t); return this._activeTextures[e] = { canvasAndContext: o, texture: s, usageCount: 1 }, s } _increaseReferenceCount (t) { this._activeTextures[t].usageCount++ } decreaseReferenceCount (t) { let e = this._activeTextures[t]; if (e.usageCount--, e.usageCount === 0) { ie.returnCanvasAndContext(e.canvasAndContext), gt.returnTexture(e.texture); let s = e.texture.source; s.resource = null, s.uploadMethodId = "unknown", s.alphaMode = "no-premultiply-alpha", this._activeTextures[t] = null } } getReferenceCount (t) { return this._activeTextures[t].usageCount } renderTextToCanvas (t, e, s, o) { let { canvas: i, context: n } = o, a = Pr(e), l = Kt.measureText(t || " ", e), h = l.lines, u = l.lineHeight, d = l.lineWidths, f = l.maxLineWidth, p = l.fontProperties, g = i.height; n.resetTransform(), n.scale(s, s); let b = e.padding * 2; if (n.clearRect(0, 0, l.width + 4 + b, l.height + 4 + b), e._stroke?.width) { let T = e._stroke; n.lineWidth = T.width, n.miterLimit = T.miterLimit, n.lineJoin = T.join, n.lineCap = T.cap } n.font = a; let _, y, v = e.dropShadow ? 2 : 1; for (let T = 0; T < v; ++T) { let P = e.dropShadow && T === 0, M = P ? Math.ceil(Math.max(1, g) + e.padding * 2) : 0, D = M * s; if (P) { n.fillStyle = "black", n.strokeStyle = "black"; let C = e.dropShadow, A = C.color, ct = C.alpha; n.shadowColor = j.shared.setValue(A).setAlpha(ct).toRgbaString(); let nt = C.blur * s, L = C.distance * s; n.shadowBlur = nt, n.shadowOffsetX = Math.cos(C.angle) * L, n.shadowOffsetY = Math.sin(C.angle) * L + D } else n.globalAlpha = e._fill?.alpha ?? 1, n.fillStyle = e._fill ? cs(e._fill, n) : null, e._stroke?.width && (n.strokeStyle = cs(e._stroke, n)), n.shadowColor = "black"; let R = (u - p.fontSize) / 2; u - p.fontSize < 0 && (R = 0); let F = e._stroke?.width ?? 0; for (let C = 0; C < h.length; C++)_ = F / 2, y = F / 2 + C * u + p.ascent + R, e.align === "right" ? _ += f - d[C] : e.align === "center" && (_ += (f - d[C]) / 2), e._stroke?.width && this._drawLetterSpacing(h[C], e, o, _ + e.padding, y + e.padding - M, !0), e._fill !== void 0 && this._drawLetterSpacing(h[C], e, o, _ + e.padding, y + e.padding - M) } } _drawLetterSpacing (t, e, s, o, i, n = !1) { let { context: a } = s, l = e.letterSpacing, h = !1; if (Kt.experimentalLetterSpacingSupported && (Kt.experimentalLetterSpacing ? (a.letterSpacing = `${l}px`, a.textLetterSpacing = `${l}px`, h = !0) : (a.letterSpacing = "0px", a.textLetterSpacing = "0px")), l === 0 || h) { n ? a.strokeText(t, o, i) : a.fillText(t, o, i); return } let u = o, d = Kt.graphemeSegmenter(t), f = a.measureText(t).width, p = 0; for (let g = 0; g < d.length; ++g) { let b = d[g]; n ? a.strokeText(b, u, i) : a.fillText(b, u, i); let _ = ""; for (let y = g + 1; y < d.length; ++y)_ += d[y]; p = a.measureText(_).width, u += f - p + l, f = p } } destroy () { this._activeTextures = null } }; c(ls, "CanvasTextSystem"); ls.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "canvasText" } }); var j_ = m(() => { S(); _p(); Up(); I.add(ls); I.add(os) }); var _v, Cr, uu = m(() => { _v = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); lt(); Cr = class extends _v.default { constructor() { super(...arguments), this.chars = Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100 } get font () { return w(G, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily } get pageTextures () { return w(G, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } get size () { return w(G, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize } get distanceFieldRange () { return w(G, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range } get distanceFieldType () { return w(G, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type } destroy (t = !1) { this.emit("destroy", this), this.removeAllListeners(); for (let e in this.chars) this.chars[e].texture.destroy(); this.chars = null, t && (this.pages.forEach(e => e.texture.destroy(!0)), this.pages = null) } }; c(Cr, "AbstractBitmapFont") }); function tn (r) { if (r === "") return []; typeof r == "string" && (r = [r]); let t = []; for (let e = 0, s = r.length; e < s; e++) { let o = r[e]; if (Array.isArray(o)) { if (o.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${o.length}.`); if (o[0].length === 0 || o[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter."); let i = o[0].charCodeAt(0), n = o[1].charCodeAt(0); if (n < i) throw new Error("[BitmapFont]: Invalid character range."); for (let a = i, l = n; a <= l; a++)t.push(String.fromCharCode(a)) } else t.push(...Array.from(o)) } if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters."); return t } var hu = m(() => { "use strict"; c(tn, "resolveCharacters") }); var us, Fp = m(() => {
          $t(); Gt(); Yi(); Ao(); rt(); lt(); Ji(); Ma(); lu(); uu(); hu(); us = class extends Cr {
            constructor(t) { super(), this.resolution = 1, this.pages = [], this._padding = 4, this._measureCache = Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = !1; let e = t, s = e.style.clone(); e.overrideFill && (s._fill.color = 16777215, s._fill.alpha = 1, s._fill.texture = E.WHITE, s._fill.fill = null); let o = s.fontSize; s.fontSize = this.baseMeasurementFontSize; let i = Pr(s); e.overrideSize ? s._stroke && (s._stroke.width *= this.baseRenderedFontSize / o) : s.fontSize = this.baseRenderedFontSize = o, this._style = s, this._skipKerning = e.skipKerning ?? !1, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, this.fontMetrics = Kt.measureFont(i), this.lineHeight = s.lineHeight || this.fontMetrics.fontSize || s.fontSize } ensureCharacters (t) {
              let e = tn(t).filter(b => !this._currentChars.includes(b)).filter((b, _, y) => y.indexOf(b) === _); if (!e.length) return; this._currentChars = [...this._currentChars, ...e]; let s; this._currentPageIndex === -1 ? s = this._nextPage() : s = this.pages[this._currentPageIndex]; let { canvas: o, context: i } = s.canvasAndContext, n = s.texture.source, a = this._style, l = this._currentX, h = this._currentY, u = this.baseRenderedFontSize / this.baseMeasurementFontSize, d = this._padding * u, f = a.fontStyle === "italic" ? 2 : 1, p = 0, g = !1; for (let b = 0; b < e.length; b++) {
                let _ = e[b], y = Kt.measureText(_, a, o, !1); y.lineHeight = y.height; let v = f * y.width * u, T = y.height * u, P = v + d * 2, M = T + d * 2; if (g = !1, _ !== `
`&& _ !== "\r" && _ !== "	" && _ !== " " && (g = !0, p = Math.ceil(Math.max(M, p))), l + P > 512 && (h += p, p = M, l = 0, h + p > 512)) { n.update(); let R = this._nextPage(); o = R.canvasAndContext.canvas, i = R.canvasAndContext.context, n = R.texture.source, h = 0 } let D = v / u - (a.dropShadow?.distance ?? 0) - (a._stroke?.width ?? 0); if (this.chars[_] = { id: _.codePointAt(0), xOffset: -this._padding, yOffset: -this._padding, xAdvance: D, kerning: {} }, g) { this._drawGlyph(i, y, l + d, h + d, u, a); let R = n.width * u, F = n.height * u, C = new H(l / R * n.width, h / F * n.height, P / R * n.width, M / F * n.height); this.chars[_].texture = new E({ source: n, frame: C }), l += Math.ceil(P) }
              } n.update(), this._currentX = l, this._currentY = h, this._skipKerning && this._applyKerning(e, i)
            } get pageTextures () { return w(G, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } _applyKerning (t, e) { let s = this._measureCache; for (let o = 0; o < t.length; o++) { let i = t[o]; for (let n = 0; n < this._currentChars.length; n++) { let a = this._currentChars[n], l = s[i]; l || (l = s[i] = e.measureText(i).width); let h = s[a]; h || (h = s[a] = e.measureText(a).width); let u = e.measureText(i + a).width, d = u - (l + h); d && (this.chars[i].kerning[a] = d), u = e.measureText(i + a).width, d = u - (l + h), d && (this.chars[a].kerning[i] = d) } } } _nextPage () { this._currentPageIndex++; let t = this.resolution, e = ie.getOptimalCanvasAndContext(512, 512, t); this._setupContext(e.context, this._style, t); let s = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), o = new E({ source: new jt({ resource: e.canvas, resolution: s, alphaMode: "premultiply-alpha-on-upload" }) }), i = { canvasAndContext: e, texture: o }; return this.pages[this._currentPageIndex] = i, i } _setupContext (t, e, s) { e.fontSize = this.baseRenderedFontSize, t.scale(s, s), t.font = Pr(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline; let o = e._stroke, i = o?.width ?? 0; if (o && (t.lineWidth = i, t.lineJoin = o.join, t.miterLimit = o.miterLimit, t.strokeStyle = cs(o, t)), e._fill && (t.fillStyle = cs(e._fill, t)), e.dropShadow) { let n = e.dropShadow, a = j.shared.setValue(n.color).toArray(), l = n.blur * s, h = n.distance * s; t.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${n.alpha})`, t.shadowBlur = l, t.shadowOffsetX = Math.cos(n.angle) * h, t.shadowOffsetY = Math.sin(n.angle) * h } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0 } _drawGlyph (t, e, s, o, i, n) { let a = e.text, l = e.fontProperties, u = (n._stroke?.width ?? 0) * i, d = s + u / 2, f = o - u / 2, p = l.descent * i, g = e.lineHeight * i; n.stroke && u && t.strokeText(a, d, f + g - p), n._fill && t.fillText(a, d, f + g - p) } destroy () { super.destroy(); for (let t = 0; t < this.pages.length; t++) { let { canvasAndContext: e, texture: s } = this.pages[t]; ie.returnCanvasAndContext(e), s.destroy(!0) } this.pages = null }
          }; c(us, "DynamicBitmapFont")
        }); function en (r, t, e) {
          let s = { width: 0, height: 0, offsetY: 0, scale: t.fontSize / e.baseMeasurementFontSize, lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }] }; s.offsetY = e.baseLineOffset; let o = s.lines[0], i = null, n = !0, a = { spaceWord: !1, width: 0, start: 0, index: 0, positions: [], chars: [] }, l = c(p => { let g = o.width; for (let b = 0; b < a.index; b++) { let _ = p.positions[b]; o.chars.push(p.chars[b]), o.charPositions.push(_ + g) } o.width += p.width, n = !1, a.width = 0, a.index = 0, a.chars.length = 0 }, "nextWord"), h = c(() => { let p = o.chars.length - 1, g = o.chars[p]; for (; g === " ";)o.width -= e.chars[g].xAdvance, g = o.chars[--p]; s.width = Math.max(s.width, o.width), o = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }, n = !0, s.lines.push(o), s.height += e.lineHeight }, "nextLine"), u = e.baseMeasurementFontSize / t.fontSize, d = t.letterSpacing * u, f = t.wordWrapWidth * u; for (let p = 0; p < r.length + 1; p++) {
            let g, b = p === r.length; b || (g = r[p]); let _ = e.chars[g] || e.chars[" "]; if (/(?:\s)/.test(g) || g === "\r" || g === `
`|| b) {
              if (!n && t.wordWrap && o.width + a.width - d > f ? (h(), l(a), b || o.charPositions.push(0)) : (a.start = o.width, l(a), b || o.charPositions.push(0)), g === "\r" || g === `
`) o.width !== 0 && h(); else if (!b) { let P = _.xAdvance + (_.kerning[i] || 0) + d; o.width += P, o.spaceWidth = P, o.spacesIndex.push(o.charPositions.length), o.chars.push(g) }
            } else { let T = _.kerning[i] || 0, P = _.xAdvance + T + d; a.positions[a.index++] = a.width + T, a.chars.push(g), a.width += P } i = g
          } return h(), t.align === "center" ? qS(s) : t.align === "right" ? ZS(s) : t.align === "justify" && QS(s), s
        } function qS (r) { for (let t = 0; t < r.lines.length; t++) { let e = r.lines[t], s = r.width / 2 - e.width / 2; for (let o = 0; o < e.charPositions.length; o++)e.charPositions[o] += s } } function ZS (r) { for (let t = 0; t < r.lines.length; t++) { let e = r.lines[t], s = r.width - e.width; for (let o = 0; o < e.charPositions.length; o++)e.charPositions[o] += s } } function QS (r) { let t = r.width; for (let e = 0; e < r.lines.length; e++) { let s = r.lines[e], o = 0, i = s.spacesIndex[o++], n = 0, a = s.spacesIndex.length, h = (t - s.width) / a; for (let u = 0; u < s.charPositions.length; u++)u === i && (i = s.spacesIndex[o++], n += h), s.charPositions[u] += n } } var du = m(() => { "use strict"; c(en, "getBitmapTextLayout"); c(qS, "alignCenter"); c(ZS, "alignRight"); c(QS, "alignJustify") }); var Ip, Br, Ga = m(() => { Ke(); lt(); as(); Fp(); du(); hu(); Ip = class { constructor() { this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = { chars: this.ALPHANUMERIC, resolution: 1, padding: 4, skipKerning: !1 } } getFont (t, e) { let s = `${e.fontFamily}-bitmap`, o = !0; if (e._fill.fill && (s += e._fill.fill.uid, o = !1), !tt.has(s)) { let n = new us({ style: e, overrideFill: o, overrideSize: !0, ...this.defaultOptions }); n.once("destroy", () => tt.remove(s)), tt.set(s, n) } let i = tt.get(s); return i.ensureCharacters?.(t), i } getLayout (t, e) { let s = this.getFont(t, e); return en(t.split(""), e, s) } measureText (t, e) { return this.getLayout(t, e) } install (...t) { let e = t[0]; typeof e == "string" && (e = { name: e, style: t[1], chars: t[2]?.chars, resolution: t[2]?.resolution, padding: t[2]?.padding, skipKerning: t[2]?.skipKerning }, w(G, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})")); let s = e?.name; if (!s) throw new Error("[BitmapFontManager] Property `name` is required."); e = { ...this.defaultOptions, ...e }; let o = e.style, i = o instanceof Ht ? o : new Ht(o), n = i._fill.fill !== null && i._fill.fill !== void 0, a = new us({ style: i, overrideFill: n, skipKerning: e.skipKerning, padding: e.padding, resolution: e.resolution, overrideSize: !1 }), l = tn(e.chars); return a.ensureCharacters(l.join("")), tt.set(`${s}-bitmap`, a), a.once("destroy", () => tt.remove(`${s}-bitmap`)), a } uninstall (t) { let e = `${t}-bitmap`, s = tt.get(e); s && (tt.remove(e), s.destroy()) } }; c(Ip, "BitmapFontManagerClass"); Br = new Ip }); var hs, Op = m(() => { Gt(); rt(); uu(); Ga(); hs = class extends Cr { constructor(t, e) { super(); let { textures: s, data: o } = t; Object.keys(o.pages).forEach(i => { let n = o.pages[parseInt(i, 10)], a = s[n.id]; this.pages.push({ texture: a }) }), Object.keys(o.chars).forEach(i => { let n = o.chars[i], { frame: a, source: l } = s[n.page], h = new H(n.x + a.x, n.y + a.y, n.width, n.height), u = new E({ source: l, frame: h }); this.chars[i] = { id: i.codePointAt(0), xOffset: n.xOffset, yOffset: n.yOffset, xAdvance: n.xAdvance, kerning: n.kerning ?? {}, texture: u } }), this.baseRenderedFontSize = o.fontSize, this.baseMeasurementFontSize = o.fontSize, this.fontMetrics = { ascent: 0, descent: 0, fontSize: o.fontSize }, this.baseLineOffset = o.baseLineOffset, this.lineHeight = o.lineHeight, this.fontFamily = o.fontFamily, this.distanceField = o.distanceField ?? { type: "none", range: 0 }, this.url = e } destroy () { super.destroy(); for (let t = 0; t < this.pages.length; t++) { let { texture: e } = this.pages[t]; e.destroy(!0) } this.pages = null } static install (t) { Br.install(t) } static uninstall (t) { Br.uninstall(t) } }; c(hs, "BitmapFont") }); var rn, kp = m(() => { "use strict"; rn = { test (r) { return typeof r == "string" && r.startsWith("info face=") }, parse (r) { let t = r.match(/^[a-z]+\s+.+$/gm), e = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] }; for (let d in t) { let f = t[d].match(/^[a-z]+/gm)[0], p = t[d].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), g = {}; for (let b in p) { let _ = p[b].split("="), y = _[0], v = _[1].replace(/"/gm, ""), T = parseFloat(v), P = isNaN(T) ? v : T; g[y] = P } e[f].push(g) } let s = { chars: {}, pages: [], lineHeight: 0, fontSize: 0, fontFamily: "", distanceField: null, baseLineOffset: 0 }, [o] = e.info, [i] = e.common, [n] = e.distanceField ?? []; n && (s.distanceField = { range: parseInt(n.distanceRange, 10), type: n.fieldType }), s.fontSize = parseInt(o.size, 10), s.fontFamily = o.face, s.lineHeight = parseInt(i.lineHeight, 10); let a = e.page; for (let d = 0; d < a.length; d++)s.pages.push({ id: parseInt(a[d].id, 10) || 0, file: a[d].file }); let l = {}; s.baseLineOffset = s.lineHeight - parseInt(i.base, 10); let h = e.char; for (let d = 0; d < h.length; d++) { let f = h[d], p = parseInt(f.id, 10), g = f.letter ?? f.char ?? String.fromCharCode(p); g === "space" && (g = " "), l[p] = g, s.chars[g] = { id: p, page: parseInt(f.page, 10) || 0, x: parseInt(f.x, 10), y: parseInt(f.y, 10), width: parseInt(f.width, 10), height: parseInt(f.height, 10), xOffset: parseInt(f.xoffset, 10), yOffset: parseInt(f.yoffset, 10), xAdvance: parseInt(f.xadvance, 10), kerning: {} } } let u = e.kerning || []; for (let d = 0; d < u.length; d++) { let f = parseInt(u[d].first, 10), p = parseInt(u[d].second, 10), g = parseInt(u[d].amount, 10); s.chars[l[p]].kerning[l[f]] = g } return s } } }); var Ua, Dp = m(() => { "use strict"; Ua = { test (r) { let t = r; return typeof t != "string" && "getElementsByTagName" in t && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null }, parse (r) { let t = { chars: {}, pages: [], lineHeight: 0, fontSize: 0, fontFamily: "", distanceField: null, baseLineOffset: 0 }, e = r.getElementsByTagName("info")[0], s = r.getElementsByTagName("common")[0], o = r.getElementsByTagName("distanceField")[0]; o && (t.distanceField = { type: o.getAttribute("fieldType"), range: parseInt(o.getAttribute("distanceRange"), 10) }); let i = r.getElementsByTagName("page"), n = r.getElementsByTagName("char"), a = r.getElementsByTagName("kerning"); t.fontSize = parseInt(e.getAttribute("size"), 10), t.fontFamily = e.getAttribute("face"), t.lineHeight = parseInt(s.getAttribute("lineHeight"), 10); for (let h = 0; h < i.length; h++)t.pages.push({ id: parseInt(i[h].getAttribute("id"), 10) || 0, file: i[h].getAttribute("file") }); let l = {}; t.baseLineOffset = t.lineHeight - parseInt(s.getAttribute("base"), 10); for (let h = 0; h < n.length; h++) { let u = n[h], d = parseInt(u.getAttribute("id"), 10), f = u.getAttribute("letter") ?? u.getAttribute("char") ?? String.fromCharCode(d); f === "space" && (f = " "), l[d] = f, t.chars[f] = { id: d, page: parseInt(u.getAttribute("page"), 10) || 0, x: parseInt(u.getAttribute("x"), 10), y: parseInt(u.getAttribute("y"), 10), width: parseInt(u.getAttribute("width"), 10), height: parseInt(u.getAttribute("height"), 10), xOffset: parseInt(u.getAttribute("xoffset"), 10), yOffset: parseInt(u.getAttribute("yoffset"), 10), xAdvance: parseInt(u.getAttribute("xadvance"), 10), kerning: {} } } for (let h = 0; h < a.length; h++) { let u = parseInt(a[h].getAttribute("first"), 10), d = parseInt(a[h].getAttribute("second"), 10), f = parseInt(a[h].getAttribute("amount"), 10); t.chars[l[d]].kerning[l[u]] = f } return t } } }); var Fa, Lp = m(() => { ft(); Dp(); Fa = { test (r) { return typeof r == "string" && r.includes("<font>") ? Ua.test(k.get().parseXML(r)) : !1 }, parse (r) { return Ua.parse(k.get().parseXML(r)) } } }); var JS, fu, pu, Hp = m(() => { pe(); xl(); ft(); S(); Wr(); Op(); kp(); Lp(); JS = [".xml", ".fnt"], fu = { extension: x.CacheParser, test: r => r instanceof hs, getCacheableAssets (r, t) { let e = {}; return r.forEach(s => { e[s] = t }), e[`${t.fontFamily}-bitmap`] = t, e } }, pu = { extension: { type: x.LoadParser, priority: mt.Normal }, test (r) { return JS.includes(At.extname(r).toLowerCase()) }, async testParse (r) { return rn.test(r) || Fa.test(r) }, async parse (r, t, e) { let s = rn.test(r) ? rn.parse(r) : Fa.parse(r), { src: o } = t, { pages: i } = s, n = []; for (let u = 0; u < i.length; ++u) { let d = i[u].file, f = At.join(At.dirname(o), d); f = Bo(f, o), n.push(f) } let a = await e.load(n), l = n.map(u => a[u]); return new hs({ data: s, textures: l }, o) }, async load (r, t) { return await (await k.get().fetch(r)).text() }, async unload (r, t, e) { await Promise.all(r.pages.map(s => e.unload(s.texture.source._sourceOrigin))), r.destroy() } } }); var Ee, mu = m(() => { lt(); It(); Fo(); Ee = class extends N { constructor(t) { t instanceof Vt && (t = { context: t }); let { context: e, roundPixels: s, ...o } = t || {}; super({ label: "Graphics", ...o }), this.canBundle = !0, this.renderPipeId = "graphics", this._roundPixels = 0, e ? this._context = e : this._context = this._ownedContext = new Vt, this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = s ?? !1 } set context (t) { t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate()) } get context () { return this._context } get bounds () { return this._context.bounds } addBounds (t) { t.addBounds(this._context.bounds) } containsPoint (t) { return this._context.containsPoint(t) } get roundPixels () { return !!this._roundPixels } set roundPixels (t) { this._roundPixels = t ? 1 : 0 } onViewUpdate () { this._didChangeId += 4096, this._didGraphicsUpdate = !0, !this.didViewUpdate && (this.didViewUpdate = !0, this.renderGroup && this.renderGroup.onChildViewUpdate(this)) } destroy (t) { this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === !0 || t?.context === !0) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t) } _callContextMethod (t, e) { return this.context[t](...e), this } setFillStyle (...t) { return this._callContextMethod("setFillStyle", t) } setStrokeStyle (...t) { return this._callContextMethod("setStrokeStyle", t) } fill (...t) { return this._callContextMethod("fill", t) } stroke (...t) { return this._callContextMethod("stroke", t) } texture (...t) { return this._callContextMethod("texture", t) } beginPath () { return this._callContextMethod("beginPath", []) } cut () { return this._callContextMethod("cut", []) } arc (...t) { return this._callContextMethod("arc", t) } arcTo (...t) { return this._callContextMethod("arcTo", t) } arcToSvg (...t) { return this._callContextMethod("arcToSvg", t) } bezierCurveTo (...t) { return this._callContextMethod("bezierCurveTo", t) } closePath () { return this._callContextMethod("closePath", []) } ellipse (...t) { return this._callContextMethod("ellipse", t) } circle (...t) { return this._callContextMethod("circle", t) } path (...t) { return this._callContextMethod("path", t) } lineTo (...t) { return this._callContextMethod("lineTo", t) } moveTo (...t) { return this._callContextMethod("moveTo", t) } quadraticCurveTo (...t) { return this._callContextMethod("quadraticCurveTo", t) } rect (...t) { return this._callContextMethod("rect", t) } roundRect (...t) { return this._callContextMethod("roundRect", t) } poly (...t) { return this._callContextMethod("poly", t) } regularPoly (...t) { return this._callContextMethod("regularPoly", t) } roundPoly (...t) { return this._callContextMethod("roundPoly", t) } roundShape (...t) { return this._callContextMethod("roundShape", t) } filletRect (...t) { return this._callContextMethod("filletRect", t) } chamferRect (...t) { return this._callContextMethod("chamferRect", t) } star (...t) { return this._callContextMethod("star", t) } svg (...t) { return this._callContextMethod("svg", t) } restore (...t) { return this._callContextMethod("restore", t) } save () { return this._callContextMethod("save", []) } getTransform () { return this.context.getTransform() } resetTransform () { return this._callContextMethod("resetTransform", []) } rotateTransform (...t) { return this._callContextMethod("rotate", t) } scaleTransform (...t) { return this._callContextMethod("scale", t) } setTransform (...t) { return this._callContextMethod("setTransform", t) } transform (...t) { return this._callContextMethod("transform", t) } translateTransform (...t) { return this._callContextMethod("translate", t) } clear () { return this._callContextMethod("clear", []) } get fillStyle () { return this._context.fillStyle } set fillStyle (t) { this._context.fillStyle = t } get strokeStyle () { return this._context.strokeStyle } set strokeStyle (t) { this._context.strokeStyle = t } clone (t = !1) { return t ? new Ee(this._context.clone()) : (this._ownedContext = null, new Ee(this._context)) } lineStyle (t, e, s) { w(G, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style."); let o = {}; return t && (o.width = t), e && (o.color = e), s && (o.alpha = s), this.context.strokeStyle = o, this } beginFill (t, e) { w(G, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."); let s = {}; return t && (s.color = t), e && (s.alpha = e), this.context.fillStyle = s, this } endFill () { w(G, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill(); let t = this.context.strokeStyle; return (t.width !== Vt.defaultStrokeStyle.width || t.color !== Vt.defaultStrokeStyle.color || t.alpha !== Vt.defaultStrokeStyle.alpha) && this.context.stroke(), this } drawCircle (...t) { return w(G, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t) } drawEllipse (...t) { return w(G, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t) } drawPolygon (...t) { return w(G, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t) } drawRect (...t) { return w(G, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t) } drawRoundedRect (...t) { return w(G, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t) } drawStar (...t) { return w(G, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t) } }; c(Ee, "Graphics") }); function xu () { return (!Np || Np?.isContextLost()) && (Np = k.get().createCanvas().getContext("webgl", {})), Np } var Np, Wp = m(() => { ft(); c(xu, "getTestContext") }); function gu () { if (!Xp) { Xp = "mediump"; let r = xu(); r && r.getShaderPrecisionFormat && (Xp = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision ? "highp" : "mediump") } return Xp } var Xp, zp = m(() => { Wp(); c(gu, "getMaxFragmentPrecision") }); function _u (r, t, e) {
          return t ? r : e ? (r = r.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${r}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${r}
        `} var Vp = m(() => { "use strict"; c(_u, "addProgramDefines") }); function bu (r, t, e) {
          let s = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision; if (r.substring(0, 9) !== "precision") {
            let o = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision; return o === "highp" && s !== "highp" && (o = "mediump"), `precision ${o} float;
${r}`
          } else if (s !== "highp" && r.substring(0, 15) === "precision highp") return r.replace("precision highp", "precision mediump"); return r
        } var Yp = m(() => { "use strict"; c(bu, "ensurePrecision") }); function yu (r, t) {
          return t ? `#version 300 es
${r}` : r
        } var $p = m(() => { "use strict"; c(yu, "insertVersion") }); function vu (r, { name: t = "pixi-program" }, e = !0) {
          t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex"; let s = e ? tT : eT; return s[t] ? (s[t]++, t += `-${s[t]}`) : s[t] = 1, r.indexOf("#define SHADER_NAME") !== -1 ? r : `${`#define SHADER_NAME ${t}`}
${r}`
        } var tT, eT, jp = m(() => { "use strict"; tT = {}, eT = {}; c(vu, "setProgramName") }); function Su (r, t) { return t ? r.replace("#version 300 es", "") : r } var Kp = m(() => { "use strict"; c(Su, "stripVersion") }); var K_, q_, bv, bt, xe = m(() => { zi(); zp(); Vp(); Yp(); $p(); jp(); Kp(); K_ = { stripVersion: Su, ensurePrecision: bu, addProgramDefines: _u, setProgramName: vu, insertVersion: yu }, q_ = Object.create(null), bv = c(class Z_ { constructor(t) { t = { ...Z_.defaultOptions, ...t }; let e = t.fragment.indexOf("#version 300 es") !== -1, s = { stripVersion: e, ensurePrecision: { requestedFragmentPrecision: t.preferredFragmentPrecision, requestedVertexPrecision: t.preferredVertexPrecision, maxSupportedVertexPrecision: "highp", maxSupportedFragmentPrecision: gu() }, setProgramName: { name: t.name }, addProgramDefines: e, insertVersion: e }, o = t.fragment, i = t.vertex; Object.keys(K_).forEach(n => { let a = s[n]; o = K_[n](o, a, !0), i = K_[n](i, a, !1) }), this.fragment = o, this.vertex = i, this._key = er(`${this.vertex}:${this.fragment}`, "gl-program") } destroy () { this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null } static from (t) { let e = `${t.vertex}:${t.fragment}`; return q_[e] || (q_[e] = new Z_(t)), q_[e] } }, "_GlProgram"); bv.defaultOptions = { preferredVertexPrecision: "highp", preferredFragmentPrecision: "mediump" }; bt = bv }); function De (r) { return yv[r] ?? yv.float32 } var yv, sn = m(() => { "use strict"; yv = { uint8x2: { size: 2, stride: 2, normalised: !1 }, uint8x4: { size: 4, stride: 4, normalised: !1 }, sint8x2: { size: 2, stride: 2, normalised: !1 }, sint8x4: { size: 4, stride: 4, normalised: !1 }, unorm8x2: { size: 2, stride: 2, normalised: !0 }, unorm8x4: { size: 4, stride: 4, normalised: !0 }, snorm8x2: { size: 2, stride: 2, normalised: !0 }, snorm8x4: { size: 4, stride: 4, normalised: !0 }, uint16x2: { size: 2, stride: 4, normalised: !1 }, uint16x4: { size: 4, stride: 8, normalised: !1 }, sint16x2: { size: 2, stride: 4, normalised: !1 }, sint16x4: { size: 4, stride: 8, normalised: !1 }, unorm16x2: { size: 2, stride: 4, normalised: !0 }, unorm16x4: { size: 4, stride: 8, normalised: !0 }, snorm16x2: { size: 2, stride: 4, normalised: !0 }, snorm16x4: { size: 4, stride: 8, normalised: !0 }, float16x2: { size: 2, stride: 4, normalised: !1 }, float16x4: { size: 4, stride: 8, normalised: !1 }, float32: { size: 1, stride: 4, normalised: !1 }, float32x2: { size: 2, stride: 8, normalised: !1 }, float32x3: { size: 3, stride: 12, normalised: !1 }, float32x4: { size: 4, stride: 16, normalised: !1 }, uint32: { size: 1, stride: 4, normalised: !1 }, uint32x2: { size: 2, stride: 8, normalised: !1 }, uint32x3: { size: 3, stride: 12, normalised: !1 }, uint32x4: { size: 4, stride: 16, normalised: !1 }, sint32: { size: 1, stride: 4, normalised: !1 }, sint32x2: { size: 2, stride: 8, normalised: !1 }, sint32x3: { size: 3, stride: 12, normalised: !1 }, sint32x4: { size: 4, stride: 16, normalised: !1 } }; c(De, "getAttributeInfoFromFormat") }); function Tu ({ source: r, entryPoint: t }) { let e = {}, s = r.indexOf(`fn ${t}`); if (s !== -1) { let o = r.indexOf("->", s); if (o !== -1) { let i = r.substring(s, o), n = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g, a; for (; (a = n.exec(i)) !== null;) { let l = rT[a[3]] ?? "float32"; e[a[2]] = { location: parseInt(a[1], 10), format: l, stride: De(l).stride, offset: 0, instance: !1, start: 0 } } } } return e } var rT, qp = m(() => { sn(); rT = { f32: "float32", "vec2<f32>": "float32x2", "vec3<f32>": "float32x3", "vec4<f32>": "float32x4", vec2f: "float32x2", vec3f: "float32x3", vec4f: "float32x4", i32: "sint32", "vec2<i32>": "sint32x2", "vec3<i32>": "sint32x3", "vec4<i32>": "sint32x4", u32: "uint32", "vec2<u32>": "uint32x2", "vec3<u32>": "uint32x3", "vec4<u32>": "uint32x4", bool: "uint32", "vec2<bool>": "uint32x2", "vec3<bool>": "uint32x3", "vec4<bool>": "uint32x4" }; c(Tu, "extractAttributesFromGpuProgram") }); function on (r) { let t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, e = /@group\((\d+)\)/, s = /@binding\((\d+)\)/, o = /var(<[^>]+>)? (\w+)/, i = /:\s*(\w+)/, n = /struct\s+(\w+)\s*{([^}]+)}/g, a = /(\w+)\s*:\s*([\w\<\>]+)/g, l = /struct\s+(\w+)/, h = r.match(t)?.map(d => ({ group: parseInt(d.match(e)[1], 10), binding: parseInt(d.match(s)[1], 10), name: d.match(o)[2], isUniform: d.match(o)[1] === "<uniform>", type: d.match(i)[1] })); if (!h) return { groups: [], structs: [] }; let u = r.match(n)?.map(d => { let f = d.match(l)[1], p = d.match(a).reduce((g, b) => { let [_, y] = b.split(":"); return g[_.trim()] = y.trim(), g }, {}); return p ? { name: f, members: p } : null }).filter(({ name: d }) => h.some(f => f.type === d)) ?? []; return { groups: h, structs: u } } var Zp = m(() => { "use strict"; c(on, "extractStructAndGroups") }); var ds, Qp = m(() => { "use strict"; ds = (r => (r[r.VERTEX = 1] = "VERTEX", r[r.FRAGMENT = 2] = "FRAGMENT", r[r.COMPUTE = 4] = "COMPUTE", r))(ds || {}) }); function Eu ({ groups: r }) { let t = []; for (let e = 0; e < r.length; e++) { let s = r[e]; t[s.group] || (t[s.group] = []), s.isUniform ? t[s.group].push({ binding: s.binding, visibility: ds.VERTEX | ds.FRAGMENT, buffer: { type: "uniform" } }) : s.type === "sampler" ? t[s.group].push({ binding: s.binding, visibility: ds.FRAGMENT, sampler: { type: "filtering" } }) : s.type === "texture_2d" && t[s.group].push({ binding: s.binding, visibility: ds.FRAGMENT, texture: { sampleType: "float", viewDimension: "2d", multisampled: !1 } }) } return t } var Jp = m(() => { Qp(); c(Eu, "generateGpuLayoutGroups") }); function Pu ({ groups: r }) { let t = []; for (let e = 0; e < r.length; e++) { let s = r[e]; t[s.group] || (t[s.group] = {}), t[s.group][s.name] = s.binding } return t } var tm = m(() => { "use strict"; c(Pu, "generateLayoutHash") }); function Cu (r, t) { let e = new Set, s = new Set, o = [...r.structs, ...t.structs].filter(n => e.has(n.name) ? !1 : (e.add(n.name), !0)), i = [...r.groups, ...t.groups].filter(n => { let a = `${n.name}-${n.binding}`; return s.has(a) ? !1 : (s.add(a), !0) }); return { structs: o, groups: i } } var em = m(() => { "use strict"; c(Cu, "removeStructAndGroupDuplicates") }); var Q_, ht, Pe = m(() => { zi(); qp(); Zp(); Jp(); tm(); em(); Q_ = Object.create(null), ht = class { constructor(t) { this._layoutKey = 0; let { fragment: e, vertex: s, layout: o, gpuLayout: i, name: n } = t; if (this.name = n, this.fragment = e, this.vertex = s, e.source === s.source) { let a = on(e.source); this.structsAndGroups = a } else { let a = on(s.source), l = on(e.source); this.structsAndGroups = Cu(a, l) } this.layout = o ?? Pu(this.structsAndGroups), this.gpuLayout = i ?? Eu(this.structsAndGroups), this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0, this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0, this._generateProgramKey() } _generateProgramKey () { let { vertex: t, fragment: e } = this, s = t.source + e.source + t.entryPoint + e.entryPoint; this._layoutKey = er(s, "program") } get attributeData () { return this._attributeData ?? (this._attributeData = Tu(this.vertex)), this._attributeData } destroy () { this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null } static from (t) { let e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`; return Q_[e] || (Q_[e] = new ht(t)), Q_[e] } }; c(ht, "GpuProgram") }); function Ia (r, t, e) { if (r) for (let s in r) { let o = s.toLocaleLowerCase(), i = t[o]; if (i) { let n = r[s]; s === "header" && (n = n.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && i.push(`//----${e}----//`), i.push(n) } else U(`${s} placement hook does not exist in shader`) } } var rm = m(() => { ut(); c(Ia, "addBits") }); function Oa (r) { let t = {}; return (r.match(sm)?.map(s => s.replace(/[{()}]/g, "")) ?? []).forEach(s => { t[s] = [] }), t } var sm, om = m(() => { "use strict"; sm = /\{\{(.*?)\}\}/g; c(Oa, "compileHooks") }); function vv (r, t) { let e, s = /@in\s+([^;]+);/g; for (; (e = s.exec(r)) !== null;)t.push(e[1]) } function ka (r, t, e = !1) {
          let s = []; vv(t, s), r.forEach(a => { a.header && vv(a.header, s) }); let o = s; e && o.sort(); let i = o.map((a, l) => `       @location(${l}) ${a},`).join(`
`), n = t.replace(/@in\s+[^;]+;\s*/g, ""); return n = n.replace("{{in}}", `
${i}
`), n
        } var im = m(() => { "use strict"; c(vv, "extractInputs"); c(ka, "compileInputs") }); function Sv (r, t) { let e, s = /@out\s+([^;]+);/g; for (; (e = s.exec(r)) !== null;)t.push(e[1]) } function sT (r) { let e = /\b(\w+)\s*:/g.exec(r); return e ? e[1] : "" } function oT (r) { let t = /@.*?\s+/g; return r.replace(t, "") } function Bu (r, t) {
          let e = []; Sv(t, e), r.forEach(l => { l.header && Sv(l.header, e) }); let s = 0, o = e.sort().map(l => l.indexOf("builtin") > -1 ? l : `@location(${s++}) ${l}`).join(`,
`), i = e.sort().map(l => `       var ${oT(l)};`).join(`
`), n = `return VSOutput(
                ${e.sort().map(l => ` ${sT(l)}`).join(`,
`)});`, a = t.replace(/@out\s+[^;]+;\s*/g, ""); return a = a.replace("{{struct}}", `
${o}
`), a = a.replace("{{start}}", `
${i}
`), a = a.replace("{{return}}", `
${n}
`), a
        } var nm = m(() => { "use strict"; c(Sv, "extractOutputs"); c(sT, "extractVariableName"); c(oT, "stripVariable"); c(Bu, "compileOutputs") }); function Da (r, t) {
          let e = r; for (let s in t) {
            let o = t[s]; o.join(`
`).length ? e = e.replace(`{{${s}}}`, `//-----${s} START-----//
${o.join(`
`)}
//----${s} FINISH----//`) : e = e.replace(`{{${s}}}`, "")
          } return e
        } var am = m(() => { "use strict"; c(Da, "injectBits") }); function Au ({ template: r, bits: t }) { let e = Tv(r, t); if (Io[e]) return Io[e]; let { vertex: s, fragment: o } = nT(r, t); return Io[e] = Ev(s, o, t), Io[e] } function wu ({ template: r, bits: t }) { let e = Tv(r, t); return Io[e] || (Io[e] = Ev(r.vertex, r.fragment, t)), Io[e] } function nT (r, t) { let e = t.map(n => n.vertex).filter(n => !!n), s = t.map(n => n.fragment).filter(n => !!n), o = ka(e, r.vertex, !0); o = Bu(e, o); let i = ka(s, r.fragment, !0); return { vertex: o, fragment: i } } function Tv (r, t) { return t.map(e => (J_.has(e) || J_.set(e, iT++), J_.get(e))).sort((e, s) => e - s).join("-") + r.vertex + r.fragment } function Ev (r, t, e) { let s = Oa(r), o = Oa(t); return e.forEach(i => { Ia(i.vertex, s, i.name), Ia(i.fragment, o, i.name) }), { vertex: Da(r, s), fragment: Da(t, o) } } var Io, J_, iT, cm = m(() => { rm(); om(); im(); nm(); am(); Io = Object.create(null), J_ = new Map, iT = 0; c(Au, "compileHighShader"); c(wu, "compileHighShaderGl"); c(nT, "compileInputsAndOutputs"); c(Tv, "generateCacheId"); c(Ev, "compileBits") }); var Ru, Mu, Gu, Uu, lm = m(() => {
          "use strict"; Ru = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, Mu = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`, Gu = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, Uu = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`}); var Fu, tb, Iu, um = m(() => {
            "use strict"; Fu = {
              name: "global-uniforms-bit", vertex: {
                header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}
            }, tb = {
              name: "global-uniforms-ubo-bit", vertex: {
                header: `
          uniform globalUniforms {
            mat3 uProjectionMatrix;
            mat3 uWorldTransformMatrix;
            vec4 uWorldColorAlpha;
            vec2 uResolution;
          };
        `}
            }, Iu = {
              name: "global-uniforms-bit", vertex: {
                header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}
            }
          }); function Ce ({ bits: r, name: t }) { let e = Au({ template: { fragment: Mu, vertex: Ru }, bits: [Fu, ...r] }); return ht.from({ name: t, vertex: { source: e.vertex, entryPoint: "main" }, fragment: { source: e.fragment, entryPoint: "main" } }) } function Be ({ bits: r, name: t }) { return new bt({ name: t, ...wu({ template: { vertex: Gu, fragment: Uu }, bits: [Iu, ...r] }) }) } var sr = m(() => { xe(); Pe(); cm(); lm(); um(); c(Ce, "compileHighShaderGpuProgram"); c(Be, "compileHighShaderGlProgram") }); var fs, ps, Oo = m(() => {
            "use strict"; fs = {
              name: "color-bit", vertex: {
                header: `
            @in aColor: vec4<f32>;
        `, main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}
            }, ps = {
              name: "color-bit", vertex: {
                header: `
            in vec4 aColor;
        `, main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}
            }
          }); function aT (r) {
            let t = []; if (r === 1) t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;"); else { let e = 0; for (let s = 0; s < r; s++)t.push(`@group(1) @binding(${e++}) var textureSource${s + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${s + 1}: sampler;`) } return t.join(`
`)
          } function cT (r) {
            let t = []; if (r === 1) t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);"); else { t.push("switch vTextureId {"); for (let e = 0; e < r; e++)e === r - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}"); t.push("}") } return t.join(`
`)
          } function ms (r) {
            return eb[r] || (eb[r] = {
              name: "texture-batch-bit", vertex: {
                header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `, main: `
                vTextureId = aTextureIdAndRound.y;
            `, end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `}, fragment: {
                header: `
                @in @interpolate(flat) vTextureId: u32;
    
                ${aT(16)}
            `, main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${cT(16)}
            `}
            }), eb[r]
          } function lT (r) {
            let t = []; for (let e = 0; e < r; e++)e > 0 && t.push("else"), e < r - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}"); return t.join(`
`)
          } function xs (r) {
            return rb[r] || (rb[r] = {
              name: "texture-batch-bit", vertex: {
                header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `, main: `
                vTextureId = aTextureIdAndRound.y;
            `, end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `}, fragment: {
                header: `
                in float vTextureId;
    
                uniform sampler2D uTextures[${r}];
              
            `, main: `
    
                ${lT(16)}
            `}
            }), rb[r]
          } var eb, rb, ko = m(() => { "use strict"; eb = {}; c(aT, "generateBindingSrc"); c(cT, "generateSampleSrc"); c(ms, "generateTextureBatchBit"); rb = {}; c(lT, "generateSampleGlSrc"); c(xs, "generateTextureBatchBitGl") }); var Ae, we, or = m(() => {
            "use strict"; Ae = {
              name: "round-pixels-bit", vertex: {
                header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}
            }, we = {
              name: "round-pixels-bit", vertex: {
                header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}
            }
          }); var Pv, gs, La = m(() => { Ze(); Ot(); Pv = new Int32Array(16); for (let r = 0; r < 16; r++)Pv[r] = r; gs = new et({ uTextures: { value: Pv, type: "i32", size: 16 } }, { isStatic: !0 }) }); var yt, Re = m(() => { "use strict"; yt = (r => (r[r.WEBGL = 1] = "WEBGL", r[r.WEBGPU = 2] = "WEBGPU", r[r.BOTH = 3] = "BOTH", r))(yt || {}) }); var Cv, dt, Me = m(() => { Cv = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); xe(); _r(); Pe(); Re(); Ot(); dt = class extends Cv.default { constructor(t) { super(), this._uniformBindMap = Object.create(null), this._ownedBindGroups = []; let { gpuProgram: e, glProgram: s, groups: o, resources: i, compatibleRenderers: n, groupMap: a } = t; this.gpuProgram = e, this.glProgram = s, n === void 0 && (n = 0, e && (n |= yt.WEBGPU), s && (n |= yt.WEBGL)), this.compatibleRenderers = n; let l = {}; if (!i && !o && (i = {}), i && o) throw new Error("[Shader] Cannot have both resources and groups"); if (!e && o && !a) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead."); if (!e && o && a) for (let h in a) for (let u in a[h]) { let d = a[h][u]; l[d] = { group: h, binding: u, name: d } } else if (e && o && !a) { let h = e.structsAndGroups.groups; a = {}, h.forEach(u => { a[u.group] = a[u.group] || {}, a[u.group][u.binding] = u.name, l[u.name] = u }) } else if (i) { if (e) { let h = e.structsAndGroups.groups; a = {}, h.forEach(u => { a[u.group] = a[u.group] || {}, a[u.group][u.binding] = u.name, l[u.name] = u }) } else { a = {}, o = { 99: new Rt }, this._ownedBindGroups.push(o[99]); let h = 0; for (let u in i) l[u] = { group: 99, binding: h, name: u }, a[99] = a[99] || {}, a[99][h] = u, h++ } o = {}; for (let h in i) { let u = h, d = i[h]; !d.source && !d._resourceType && (d = new et(d)); let f = l[u]; f && (o[f.group] || (o[f.group] = new Rt, this._ownedBindGroups.push(o[f.group])), o[f.group].setResource(d, f.binding)) } } this.groups = o, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(o, l) } addResource (t, e, s) { var o, i; (o = this._uniformBindMap)[e] || (o[e] = {}), (i = this._uniformBindMap[e])[s] || (i[s] = t), this.groups[e] || (this.groups[e] = new Rt, this._ownedBindGroups.push(this.groups[e])) } _buildResourceAccessor (t, e) { let s = {}; for (let o in e) { let i = e[o]; Object.defineProperty(s, i.name, { get () { return t[i.group].getResource(i.binding) }, set (n) { t[i.group].setResource(n, i.binding) } }) } return s } destroy (t = !1) { this.emit("destroy", this), t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach(e => { e.destroy() }), this._ownedBindGroups = null, this.resources = null, this.groups = null } static from (t) { let { gpu: e, gl: s, ...o } = t, i, n; return e && (i = ht.from(e)), s && (n = bt.from(s)), new dt({ gpuProgram: i, glProgram: n, ...o }) } }; c(dt, "Shader") }); var Ou, ku, hm = m(() => {
            "use strict"; Ou = {
              name: "local-uniform-msdf-bit", vertex: {
                header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `, main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `, end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}, fragment: {
                header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `, main: ` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `}
            }, ku = {
              name: "local-uniform-msdf-bit", vertex: {
                header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `, main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `, end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}, fragment: {
                header: `
            uniform float uDistance;
         `, main: ` 
            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `}
            }
          }); var Du, Lu, dm = m(() => {
            "use strict"; Du = {
              name: "msdf-bit", fragment: {
                header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}
            }, Lu = {
              name: "msdf-bit", fragment: {
                header: `
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}
            }
          }); var Do, fm = m(() => { ot(); Ze(); sr(); Oo(); ko(); or(); La(); Me(); Ot(); hm(); dm(); Do = class extends dt { constructor() { let t = new et({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new B, type: "mat3x3<f32>" }, uDistance: { value: 4, type: "f32" }, uRound: { value: 0, type: "f32" } }), e = Ce({ name: "sdf-shader", bits: [fs, ms(16), Ou, Du, Ae] }), s = Be({ name: "sdf-shader", bits: [ps, xs(16), ku, Lu, we] }); super({ glProgram: s, gpuProgram: e, resources: { localUniforms: t, batchSamplers: gs } }) } }; c(Do, "SdfShader") }); function Bv (r, t) { t.groupTransform = r.groupTransform, t.groupColorAlpha = r.groupColorAlpha, t.groupColor = r.groupColor, t.groupBlendMode = r.groupBlendMode, t.globalDisplayStatus = r.globalDisplayStatus, t.groupTransform = r.groupTransform, t.localDisplayStatus = r.localDisplayStatus, t.groupAlpha = r.groupAlpha, t._roundPixels = r._roundPixels } var _s, pm = m(() => { Ke(); S(); Jt(); mu(); fm(); Ga(); du(); _s = class { constructor(t) { this._gpuBitmapText = {}, this._renderer = t } validateRenderable (t) { let e = this._getGpuBitmapText(t); return t._didTextUpdate && (t._didTextUpdate = !1, this._updateContext(t, e)), this._renderer.renderPipes.graphics.validateRenderable(e) } addRenderable (t, e) { let s = this._getGpuBitmapText(t); Bv(t, s), t._didTextUpdate && (t._didTextUpdate = !1, this._updateContext(t, s)), this._renderer.renderPipes.graphics.addRenderable(s, e), s.context.customShader && this._updateDistanceField(t) } destroyRenderable (t) { this._destroyRenderableByUid(t.uid) } _destroyRenderableByUid (t) { Y.return(this._gpuBitmapText[t]), this._gpuBitmapText[t] = null } updateRenderable (t) { let e = this._getGpuBitmapText(t); Bv(t, e), this._renderer.renderPipes.graphics.updateRenderable(e), e.context.customShader && this._updateDistanceField(t) } _updateContext (t, e) { let { context: s } = e, o = Br.getFont(t.text, t._style); s.clear(), o.distanceField.type !== "none" && (s.customShader || (this._sdfShader || (this._sdfShader = new Do), s.customShader = this._sdfShader)); let i = Array.from(t.text), n = t._style, a = (n._stroke?.width || 0) / 2; a += o.baseLineOffset; let l = en(i, n, o), h = 0, u = n.padding, d = l.scale; s.translate(-t._anchor._x * l.width - u, -t._anchor._y * (l.height + l.offsetY) - u).scale(d, d); let f = n._fill.color; for (let p = 0; p < l.lines.length; p++) { let g = l.lines[p]; for (let b = 0; b < g.charPositions.length; b++) { let _ = i[h++], y = o.chars[_]; y?.texture && s.texture(y.texture, f || "black", Math.round(g.charPositions[b] + y.xOffset), Math.round(a + y.yOffset)) } a += o.lineHeight } } _getGpuBitmapText (t) { return this._gpuBitmapText[t.uid] || this.initGpuText(t) } initGpuText (t) { let e = Y.get(Ee); return this._gpuBitmapText[t.uid] = e, this._updateContext(t, e), t.on("destroyed", () => { this.destroyRenderable(t) }), this._gpuBitmapText[t.uid] } _updateDistanceField (t) { let e = this._getGpuBitmapText(t).context, s = t._style.fontFamily, o = tt.get(`${s}-bitmap`), { a: i, b: n, c: a, d: l } = t.groupTransform, h = Math.sqrt(i * i + n * n), u = Math.sqrt(a * a + l * l), d = (Math.abs(h) + Math.abs(u)) / 2, f = o.baseRenderedFontSize / t._style.fontSize, p = t.resolution ?? this._renderer.resolution, g = d * o.distanceField.range * (1 / f) * p; e.customShader.resources.localUniforms.uniforms.uDistance = g } destroy () { for (let t in this._gpuBitmapText) this._destroyRenderableByUid(t); this._gpuBitmapText = null, this._sdfShader?.destroy(!0), this._sdfShader = null, this._renderer = null } }; c(_s, "BitmapTextPipe"); _s.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "bitmapText" }; c(Bv, "syncWithProxy") }); var sb = m(() => { S(); Hp(); pm(); I.add(_s, pu, fu) }); var bs, mm = m(() => { S(); rt(); ga(); Jt(); Ca(); bs = class { constructor(t) { this._gpuText = Object.create(null), this._renderer = t } validateRenderable (t) { let e = this._getGpuText(t), s = t._getKey(); return e.textureNeedsUploading ? (e.textureNeedsUploading = !1, !0) : e.currentKey !== s } addRenderable (t) { let s = this._getGpuText(t).batchableSprite; t._didTextUpdate && this._updateText(t), this._renderer.renderPipes.batch.addToBatch(s) } updateRenderable (t) { let s = this._getGpuText(t).batchableSprite; t._didTextUpdate && this._updateText(t), s.batcher.updateElement(s) } destroyRenderable (t) { this._destroyRenderableById(t.uid) } _destroyRenderableById (t) { let e = this._gpuText[t]; this._renderer.htmlText.decreaseReferenceCount(e.currentKey), Y.return(e.batchableSprite), this._gpuText[t] = null } _updateText (t) { let e = t._getKey(), s = this._getGpuText(t), o = s.batchableSprite; s.currentKey !== e && this._updateGpuText(t).catch(n => { console.error(n) }), t._didTextUpdate = !1; let i = t._style.padding; mr(o.bounds, t._anchor, o.texture, i) } async _updateGpuText (t) { t._didTextUpdate = !1; let e = this._getGpuText(t); if (e.generatingTexture) return; let s = t._getKey(); this._renderer.htmlText.decreaseReferenceCount(e.currentKey), e.generatingTexture = !0, e.currentKey = s; let o = t.resolution ?? this._renderer.resolution, i = await this._renderer.htmlText.getManagedTexture(t.text, o, t._style, t._getKey()), n = e.batchableSprite; n.texture = e.texture = i, e.generatingTexture = !1, e.textureNeedsUploading = !0, t.onViewUpdate(); let a = t._style.padding; mr(n.bounds, t._anchor, n.texture, a) } _getGpuText (t) { return this._gpuText[t.uid] || this.initGpuText(t) } initGpuText (t) { let e = { texture: E.EMPTY, currentKey: "--", batchableSprite: Y.get(Oe), textureNeedsUploading: !1, generatingTexture: !1 }, s = e.batchableSprite; return s.renderable = t, s.texture = E.EMPTY, s.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, s.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuText[t.uid] = e, t.on("destroyed", () => { this.destroyRenderable(t) }), e } destroy () { for (let t in this._gpuText) this._destroyRenderableById(t); this._gpuText = null, this._renderer = null } }; c(bs, "HTMLTextPipe"); bs.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "htmlText" } }); function Hu () { let { userAgent: r } = k.get().getNavigator(); return /^((?!chrome|android).)*safari/i.test(r) } var xm = m(() => { ft(); c(Hu, "isSafari") }); var Nu, Wu, Ar, Xu = m(() => { "use strict"; Nu = "http://www.w3.org/2000/svg", Wu = "http://www.w3.org/1999/xhtml", Ar = class { constructor() { this.svgRoot = document.createElementNS(Nu, "svg"), this.foreignObject = document.createElementNS(Nu, "foreignObject"), this.domElement = document.createElementNS(Wu, "div"), this.styleElement = document.createElementNS(Wu, "style"), this.image = new Image; let { foreignObject: t, svgRoot: e, styleElement: s, domElement: o } = this; t.setAttribute("width", "10000"), t.setAttribute("height", "10000"), t.style.overflow = "hidden", e.appendChild(t), t.appendChild(s), t.appendChild(o) } }; c(Ar, "HTMLTextRenderData") }); function zu (r) { let t = r._stroke, e = r._fill, o = [`div { ${[`color: ${j.shared.setValue(e.color).toHex()}`, `font-size: ${r.fontSize}px`, `font-family: ${r.fontFamily}`, `font-weight: ${r.fontWeight}`, `font-style: ${r.fontStyle}`, `font-variant: ${r.fontVariant}`, `letter-spacing: ${r.letterSpacing}px`, `text-align: ${r.align}`, `padding: ${r.padding}px`, `white-space: ${r.whiteSpace === "pre" && r.wordWrap ? "pre-wrap" : r.whiteSpace}`, ...r.lineHeight ? [`line-height: ${r.lineHeight}px`] : [], ...r.wordWrap ? [`word-wrap: ${r.breakWords ? "break-all" : "break-word"}`, `max-width: ${r.wordWrapWidth}px`] : [], ...t ? [Mv(t)] : [], ...r.dropShadow ? [Rv(r.dropShadow)] : [], ...r.cssOverrides].join(";")} }`]; return uT(r.tagStyles, o), o.join(" ") } function Rv (r) { let t = j.shared.setValue(r.color).setAlpha(r.alpha).toHexa(), e = Math.round(Math.cos(r.angle) * r.distance), s = Math.round(Math.sin(r.angle) * r.distance), o = `${e}px ${s}px`; return r.blur > 0 ? `text-shadow: ${o} ${r.blur}px ${t}` : `text-shadow: ${o} ${t}` } function Mv (r) { return [`-webkit-text-stroke-width: ${r.width}px`, `-webkit-text-stroke-color: ${j.shared.setValue(r.color).toHex()}`, `text-stroke-width: ${r.width}px`, `text-stroke-color: ${j.shared.setValue(r.color).toHex()}`, "paint-order: stroke"].join(";") } function uT (r, t) { for (let e in r) { let s = r[e], o = []; for (let i in s) wv[i] ? o.push(wv[i](s[i])) : Av[i] && o.push(Av[i].replace("{{VALUE}}", s[i])); t.push(`${e} { ${o.join(";")} }`) } } var Av, wv, gm = m(() => { $t(); c(zu, "textStyleToCSS"); c(Rv, "dropShadowToCSS"); c(Mv, "strokeToCSS"); Av = { fontSize: "font-size: {{VALUE}}px", fontFamily: "font-family: {{VALUE}}", fontWeight: "font-weight: {{VALUE}}", fontStyle: "font-style: {{VALUE}}", fontVariant: "font-variant: {{VALUE}}", letterSpacing: "letter-spacing: {{VALUE}}px", align: "text-align: {{VALUE}}", padding: "padding: {{VALUE}}px", whiteSpace: "white-space: {{VALUE}}", lineHeight: "line-height: {{VALUE}}px", wordWrapWidth: "max-width: {{VALUE}}px" }, wv = { fill: r => `color: ${j.shared.setValue(r).toHex()}`, breakWords: r => `word-wrap: ${r ? "break-all" : "break-word"}`, stroke: Mv, dropShadow: Rv }; c(uT, "tagStyleToCSS") }); var ue, Ha = m(() => { ut(); as(); au(); gm(); ue = class extends Ht { constructor(t = {}) { super(t), this._cssOverrides = [], this.cssOverrides ?? (this.cssOverrides = t.cssOverrides), this.tagStyles = t.tagStyles ?? {} } set cssOverrides (t) { this._cssOverrides = t instanceof Array ? t : [t], this.update() } get cssOverrides () { return this._cssOverrides } _generateKey () { return this._styleKey = Zi(this) + this._cssOverrides.join("-"), this._styleKey } update () { this._cssStyle = null, super.update() } clone () { return new ue({ align: this.align, breakWords: this.breakWords, dropShadow: this.dropShadow, fill: this._fill, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this._stroke, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth, cssOverrides: this.cssOverrides }) } get cssStyle () { return this._cssStyle || (this._cssStyle = zu(this)), this._cssStyle } addOverride (...t) { let e = t.filter(s => !this.cssOverrides.includes(s)); e.length > 0 && (this.cssOverrides.push(...e), this.update()) } removeOverride (...t) { let e = t.filter(s => this.cssOverrides.includes(s)); e.length > 0 && (this.cssOverrides = this.cssOverrides.filter(s => !e.includes(s)), this.update()) } set fill (t) { typeof t != "string" && typeof t != "number" && U("[HTMLTextStyle] only color fill is not supported by HTMLText"), super.fill = t } set stroke (t) { t && typeof t != "string" && typeof t != "number" && U("[HTMLTextStyle] only color stroke is not supported by HTMLText"), super.stroke = t } }; c(ue, "HTMLTextStyle") }); function Vu (r, t) { let e = t.fontFamily, s = [], o = {}, i = /font-family:([^;"\s]+)/g, n = r.match(i); function a (l) { o[l] || (s.push(l), o[l] = !0) } if (c(a, "addFontFamily"), Array.isArray(e)) for (let l = 0; l < e.length; l++)a(e[l]); else a(e); n && n.forEach(l => { let h = l.split(":")[1].trim(); a(h) }); for (let l in t.tagStyles) { let h = t.tagStyles[l].fontFamily; a(h) } return s } var _m = m(() => { "use strict"; c(Vu, "extractFontFamilies") }); async function Yu (r) { let e = await (await k.get().fetch(r)).blob(), s = new FileReader; return await new Promise((i, n) => { s.onloadend = () => i(s.result), s.onerror = n, s.readAsDataURL(e) }) } var bm = m(() => { ft(); c(Yu, "loadFontAsBase64") }); async function Na (r, t) {
            let e = await Yu(t); return `@font-face {
        font-family: "${r.fontFamily}";
        src: url('${e}');
        font-weight: ${r.fontWeight};
        font-style: ${r.fontStyle};
    }`} var ym = m(() => { bm(); c(Na, "loadFontCSS") }); async function $u (r, t, e) {
          let s = r.filter(o => tt.has(`${o}-and-url`)).map((o, i) => { if (!nn.has(o)) { let { url: n } = tt.get(`${o}-and-url`); i === 0 ? nn.set(o, Na(t, n)) : nn.set(o, Na({ fontWeight: e.fontWeight, fontStyle: e.fontStyle, fontFamily: o }, n)) } return nn.get(o) }); return (await Promise.all(s)).join(`
`)
        } var nn, vm = m(() => { Ke(); ym(); nn = new Map; c($u, "getFontCss") }); function ju (r, t, e, s, o) { let { domElement: i, styleElement: n, svgRoot: a } = o; i.innerHTML = `<style>${t.cssStyle}</style><div>${r}</div>`, i.setAttribute("style", `transform: scale(${e});transform-origin: top left; display: inline-block`), n.textContent = s; let { width: l, height: h } = o.image; return a.setAttribute("width", l.toString()), a.setAttribute("height", h.toString()), new XMLSerializer().serializeToString(a) } var Sm = m(() => { "use strict"; c(ju, "getSVGUrl") }); function Ku (r, t) { let e = ie.getOptimalCanvasAndContext(r.width, r.height, t), { context: s } = e; return s.clearRect(0, 0, r.width, r.height), s.drawImage(r, 0, 0), ie.returnCanvasAndContext(e), e.canvas } var Tm = m(() => { Yi(); c(Ku, "getTemporaryCanvasFromImage") }); function qu (r, t, e) { return new Promise(async s => { e && await new Promise(o => setTimeout(o, 100)), r.onload = () => { s() }, r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`, r.crossOrigin = "anonymous" }) } var Em = m(() => { "use strict"; c(qu, "loadSVGImage") }); function an (r, t, e, s) { s = s || Gv || (Gv = new Ar); let { domElement: o, styleElement: i, svgRoot: n } = s; o.innerHTML = `<style>${t.cssStyle}</style><div>${r}</div>`, o.setAttribute("style", "transform-origin: top left; display: inline-block"), e && (i.textContent = e), document.body.appendChild(n); let a = o.getBoundingClientRect(); n.remove(); let l = Kt.measureFont(t.fontStyle).descent; return { width: a.width, height: a.height + l } } var Gv, Zu = m(() => { Ji(); Xu(); c(an, "measureHtmlText") }); var wr, Pm = m(() => { S(); br(); Re(); xm(); ut(); Jt(); cu(); Xu(); Ha(); _m(); vm(); Sm(); Tm(); Em(); Zu(); wr = class { constructor(t) { this._activeTextures = {}, this._renderer = t, this._createCanvas = t.type === yt.WEBGPU } getTexture (t) { return this._buildTexturePromise(t.text, t.resolution, t.style) } getManagedTexture (t, e, s, o) { if (this._activeTextures[o]) return this._increaseReferenceCount(o), this._activeTextures[o].promise; let i = this._buildTexturePromise(t, e, s).then(n => (this._activeTextures[o].texture = n, n)); return this._activeTextures[o] = { texture: null, promise: i, usageCount: 1 }, i } async _buildTexturePromise (t, e, s) { let o = Y.get(Ar), i = Vu(t, s), n = await $u(i, s, ue.defaultTextStyle), a = an(t, s, n, o), l = Math.ceil(Math.ceil(Math.max(1, a.width) + s.padding * 2) * e), h = Math.ceil(Math.ceil(Math.max(1, a.height) + s.padding * 2) * e), u = o.image; u.width = l | 0, u.height = h | 0; let d = ju(t, s, e, n, o); await qu(u, d, Hu() && i.length > 0); let f = u; this._createCanvas && (f = Ku(u, e)); let p = Qi(f, u.width, u.height, e); return this._createCanvas && this._renderer.texture.initSource(p.source), Y.return(o), p } _increaseReferenceCount (t) { this._activeTextures[t].usageCount++ } decreaseReferenceCount (t) { let e = this._activeTextures[t]; e && (e.usageCount--, e.usageCount === 0 && (e.texture ? this._cleanUp(e) : e.promise.then(s => { e.texture = s, this._cleanUp(e) }).catch(() => { U("HTMLTextSystem: Failed to clean texture") }), this._activeTextures[t] = null)) } _cleanUp (t) { gt.returnTexture(t.texture), t.texture.source.resource = null, t.texture.source.uploadMethodId = "unknown" } getReferenceCount (t) { return this._activeTextures[t].usageCount } destroy () { this._activeTextures = null } }; c(wr, "HTMLTextSystem"); wr.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "htmlText" }; wr.defaultFontOptions = { fontFamily: "Arial", fontStyle: "normal", fontWeight: "normal" } }); var ob = m(() => { S(); mm(); Pm(); I.add(wr); I.add(bs) }); var Uv, qt, Rr = m(() => { xr(); qe(); wo(); lt(); Uv = c(class Fv extends oe { constructor(...t) { let e = t[0] ?? {}; e instanceof Float32Array && (w(G, "use new MeshGeometry({ positions, uvs, indices }) instead"), e = { positions: e, uvs: t[1], indices: t[2] }), e = { ...Fv.defaultOptions, ...e }; let s = e.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), o = e.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), i = e.indices || new Uint32Array([0, 1, 2, 0, 2, 3]), n = e.shrinkBuffersToFit, a = new _t({ data: s, label: "attribute-mesh-positions", shrinkToFit: n, usage: K.VERTEX | K.COPY_DST }), l = new _t({ data: o, label: "attribute-mesh-uvs", shrinkToFit: n, usage: K.VERTEX | K.COPY_DST }), h = new _t({ data: i, label: "index-mesh-buffer", shrinkToFit: n, usage: K.INDEX | K.COPY_DST }); super({ attributes: { aPosition: { buffer: a, format: "float32x2", stride: 2 * 4, offset: 0 }, aUV: { buffer: l, format: "float32x2", stride: 2 * 4, offset: 0 } }, indexBuffer: h, topology: e.topology }), this.batchMode = "auto" } get positions () { return this.attributes.aPosition.buffer.data } set positions (t) { this.attributes.aPosition.buffer.data = t } get uvs () { return this.attributes.aUV.buffer.data } set uvs (t) { this.attributes.aUV.buffer.data = t } get indices () { return this.indexBuffer.data } set indices (t) { this.indexBuffer.data = t } }, "_MeshGeometry"); Uv.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: !1 }; qt = Uv }); var Mr, Qu, ys, Lo = m(() => {
          "use strict"; Mr = {
            name: "local-uniform-bit", vertex: {
              header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `, main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `, end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}
          }, Qu = { ...Mr, vertex: { ...Mr.vertex, header: Mr.vertex.header.replace("group(1)", "group(2)") } }, ys = {
            name: "local-uniform-bit", vertex: {
              header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `, main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `, end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}
          }
        }); var Ju, th, Cm = m(() => {
          "use strict"; Ju = {
            name: "tiling-bit", vertex: {
              header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `, main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `}, fragment: {
              header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `, main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}
          }, th = {
            name: "tiling-bit", vertex: {
              header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `, main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `}, fragment: {
              header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `, main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `}
          }
        }); var ib, nb, Ho, Bm = m(() => { ot(); sr(); Lo(); or(); Me(); Ot(); rt(); Cm(); Ho = class extends dt { constructor() { ib ?? (ib = Ce({ name: "tiling-sprite-shader", bits: [Mr, Ju, Ae] })), nb ?? (nb = Be({ name: "tiling-sprite-shader", bits: [ys, th, we] })); let t = new et({ uMapCoord: { value: new B, type: "mat3x3<f32>" }, uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" }, uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" }, uTextureTransform: { value: new B, type: "mat3x3<f32>" }, uSizeAnchor: { value: new Float32Array([100, 100, .5, .5]), type: "vec4<f32>" } }); super({ glProgram: nb, gpuProgram: ib, resources: { localUniforms: new et({ uTransformMatrix: { value: new B, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), tilingUniforms: t, uTexture: E.EMPTY.source, uSampler: E.EMPTY.source.style } }) } updateUniforms (t, e, s, o, i, n) { let a = this.resources.tilingUniforms, l = n.width, h = n.height, u = n.textureMatrix, d = a.uniforms.uTextureTransform; d.set(s.a * l / t, s.b * l / e, s.c * h / t, s.d * h / e, s.tx / t, s.ty / e), d.invert(), a.uniforms.uMapCoord = u.mapCoord, a.uniforms.uClampFrame = u.uClampFrame, a.uniforms.uClampOffset = u.uClampOffset, a.uniforms.uTextureTransform = d, a.uniforms.uSizeAnchor[0] = t, a.uniforms.uSizeAnchor[1] = e, a.uniforms.uSizeAnchor[2] = o, a.uniforms.uSizeAnchor[3] = i, n && (this.resources.uTexture = n.source, this.resources.uSampler = n.source.style) } }; c(Ho, "TilingSpriteShader") }); var No, Am = m(() => { Rr(); No = class extends qt { constructor() { super({ positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), indices: new Uint32Array([0, 1, 2, 0, 2, 3]) }) } }; c(No, "QuadGeometry") }); function eh (r, t) { let e = r.anchor.x, s = r.anchor.y; t[0] = -e * r.width, t[1] = -s * r.height, t[2] = (1 - e) * r.width, t[3] = -s * r.height, t[4] = (1 - e) * r.width, t[5] = (1 - s) * r.height, t[6] = -e * r.width, t[7] = (1 - s) * r.height } var wm = m(() => { "use strict"; c(eh, "setPositions") }); function rh (r, t, e, s) { let o = 0, i = r.length / (t || 2), n = s.a, a = s.b, l = s.c, h = s.d, u = s.tx, d = s.ty; for (e *= t; o < i;) { let f = r[e], p = r[e + 1]; r[e] = n * f + l * p + u, r[e + 1] = a * f + h * p + d, e += t, o++ } } var Rm = m(() => { "use strict"; c(rh, "applyMatrix") }); function sh (r, t) { let e = r.texture, s = e.frame.width, o = e.frame.height, i = 0, n = 0; r._applyAnchorToTexture && (i = r.anchor.x, n = r.anchor.y), t[0] = t[6] = -i, t[2] = t[4] = 1 - i, t[1] = t[3] = -n, t[5] = t[7] = 1 - n; let a = B.shared; a.copyFrom(r._tileTransform.matrix), a.tx /= r.width, a.ty /= r.height, a.invert(), a.scale(r.width / s, r.height / o), rh(t, 2, 0, a) } var Mm = m(() => { ot(); Rm(); c(sh, "setUvs") }); var Gm, vs, Um = m(() => { S(); Se(); Re(); Xi(); Pa(); Rr(); Bm(); Am(); wm(); Mm(); Gm = new No, vs = class { constructor(t) { this._tilingSpriteDataHash = Object.create(null), this._renderer = t } validateRenderable (t) { let e = this._getTilingSpriteData(t), s = e.canBatch; this._updateCanBatch(t); let o = e.canBatch; if (o && o === s) { let { batchableMesh: i } = e; if (i.texture._source !== t.texture._source) return !i.batcher.checkAndUpdateTexture(i, t.texture) } return s !== o } addRenderable (t, e) { let s = this._renderer.renderPipes.batch; this._updateCanBatch(t); let o = this._getTilingSpriteData(t), { geometry: i, canBatch: n } = o; if (n) { o.batchableMesh || (o.batchableMesh = new Ie); let a = o.batchableMesh; t._didTilingSpriteUpdate && (t._didTilingSpriteUpdate = !1, this._updateBatchableMesh(t), a.geometry = i, a.mesh = t, a.texture = t._texture), a.roundPixels = this._renderer._roundPixels | t._roundPixels, s.addToBatch(a) } else s.break(e), o.shader || (o.shader = new Ho), this.updateRenderable(t), e.add(t) } execute (t) { let { shader: e } = this._tilingSpriteDataHash[t.uid]; e.groups[0] = this._renderer.globalUniforms.bindGroup; let s = e.resources.localUniforms.uniforms; s.uTransformMatrix = t.groupTransform, s.uRound = this._renderer._roundPixels | t._roundPixels, tr(t.groupColorAlpha, s.uColor, 0), this._renderer.encoder.draw({ geometry: Gm, shader: e, state: Pt.default2d }) } updateRenderable (t) { let e = this._getTilingSpriteData(t), { canBatch: s } = e; if (s) { let { batchableMesh: o } = e; t._didTilingSpriteUpdate && this._updateBatchableMesh(t), o.batcher.updateElement(o) } else if (t._didTilingSpriteUpdate) { let { shader: o } = e; o.updateUniforms(t.width, t.height, t._tileTransform.matrix, t.anchor.x, t.anchor.y, t.texture) } t._didTilingSpriteUpdate = !1 } destroyRenderable (t) { let e = this._getTilingSpriteData(t); e.batchableMesh = null, e.shader?.destroy(), this._tilingSpriteDataHash[t.uid] = null } _getTilingSpriteData (t) { return this._tilingSpriteDataHash[t.uid] || this._initTilingSpriteData(t) } _initTilingSpriteData (t) { let e = new qt({ indices: Gm.indices, positions: Gm.positions.slice(), uvs: Gm.uvs.slice() }); return this._tilingSpriteDataHash[t.uid] = { canBatch: !0, renderable: t, geometry: e }, t.on("destroyed", () => { this.destroyRenderable(t) }), this._tilingSpriteDataHash[t.uid] } _updateBatchableMesh (t) { let e = this._getTilingSpriteData(t), { geometry: s } = e, o = t.texture.source.style; o.addressMode !== "repeat" && (o.addressMode = "repeat", o.update()), sh(t, s.uvs), eh(t, s.positions) } destroy () { for (let t in this._tilingSpriteDataHash) this.destroyRenderable(this._tilingSpriteDataHash[t].renderable); this._tilingSpriteDataHash = null, this._renderer = null } _updateCanBatch (t) { let e = this._getTilingSpriteData(t), s = t.texture, o = !0; return this._renderer.type === yt.WEBGL && (o = this._renderer.context.supports.nonPowOf2wrapping), e.canBatch = s.textureMatrix.isSimple && (o || s.source.isPowerOfTwo), e.canBatch } }; c(vs, "TilingSpritePipe"); vs.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "tilingSprite" } }); var ab = m(() => { S(); Um(); I.add(vs) }); var Iv, cn, oh = m(() => { lt(); Rr(); Iv = c(class Ov extends qt { constructor(...t) { super({}); let e = t[0] ?? {}; typeof e == "number" && (w(G, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), e = { width: e, height: t[1], verticesX: t[2], verticesY: t[3] }), this.build(e) } build (t) { t = { ...Ov.defaultOptions, ...t }, this.verticesX = this.verticesX ?? t.verticesX, this.verticesY = this.verticesY ?? t.verticesY, this.width = this.width ?? t.width, this.height = this.height ?? t.height; let e = this.verticesX * this.verticesY, s = [], o = [], i = [], n = this.verticesX - 1, a = this.verticesY - 1, l = this.width / n, h = this.height / a; for (let d = 0; d < e; d++) { let f = d % this.verticesX, p = d / this.verticesX | 0; s.push(f * l, p * h), o.push(f / n, p / a) } let u = n * a; for (let d = 0; d < u; d++) { let f = d % n, p = d / n | 0, g = p * this.verticesX + f, b = p * this.verticesX + f + 1, _ = (p + 1) * this.verticesX + f, y = (p + 1) * this.verticesX + f + 1; i.push(g, b, _, b, y, _) } this.buffers[0].data = new Float32Array(s), this.buffers[1].data = new Float32Array(o), this.indexBuffer.data = new Uint32Array(i), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update() } }, "_PlaneGeometry"); Iv.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 }; cn = Iv }); var kv, Le, ih = m(() => { oh(); kv = c(class Dv extends cn { constructor(t = {}) { t = { ...Dv.defaultOptions, ...t }, super({ width: t.width, height: t.height, verticesX: 4, verticesY: 4 }), this.update(t) } update (t) { this.width = t.width ?? this.width, this.height = t.height ?? this.height, this._originalWidth = t.originalWidth ?? this._originalWidth, this._originalHeight = t.originalHeight ?? this._originalHeight, this._leftWidth = t.leftWidth ?? this._leftWidth, this._rightWidth = t.rightWidth ?? this._rightWidth, this._topHeight = t.topHeight ?? this._topHeight, this._bottomHeight = t.bottomHeight ?? this._bottomHeight, this.updateUvs(), this.updatePositions() } updatePositions () { let t = this.positions, e = this._leftWidth + this._rightWidth, s = this.width > e ? 1 : this.width / e, o = this._topHeight + this._bottomHeight, i = this.height > o ? 1 : this.height / o, n = Math.min(s, i); t[9] = t[11] = t[13] = t[15] = this._topHeight * n, t[17] = t[19] = t[21] = t[23] = this.height - this._bottomHeight * n, t[25] = t[27] = t[29] = t[31] = this.height, t[2] = t[10] = t[18] = t[26] = this._leftWidth * n, t[4] = t[12] = t[20] = t[28] = this.width - this._rightWidth * n, t[6] = t[14] = t[22] = t[30] = this.width, this.getBuffer("aPosition").update() } updateUvs () { let t = this.uvs; t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1; let e = 1 / this._originalWidth, s = 1 / this._originalHeight; t[2] = t[10] = t[18] = t[26] = e * this._leftWidth, t[9] = t[11] = t[13] = t[15] = s * this._topHeight, t[4] = t[12] = t[20] = t[28] = 1 - e * this._rightWidth, t[17] = t[19] = t[21] = t[23] = 1 - s * this._bottomHeight, this.getBuffer("aUV").update() } }, "_NineSliceGeometry"); kv.defaultOptions = { width: 100, height: 100, leftWidth: 10, topHeight: 10, rightWidth: 10, bottomHeight: 10, originalWidth: 100, originalHeight: 100 }; Le = kv }); var Ss, Fm = m(() => { S(); Jt(); Pa(); ih(); Ss = class { constructor(t) { this._gpuSpriteHash = Object.create(null), this._renderer = t } addRenderable (t, e) { let s = this._getGpuSprite(t); t._didSpriteUpdate && this._updateBatchableSprite(t, s), this._renderer.renderPipes.batch.addToBatch(s) } updateRenderable (t) { let e = this._gpuSpriteHash[t.uid]; t._didSpriteUpdate && this._updateBatchableSprite(t, e), e.batcher.updateElement(e) } validateRenderable (t) { let e = t._texture, s = this._getGpuSprite(t); return s.texture._source !== e._source ? !s.batcher.checkAndUpdateTexture(s, e) : !1 } destroyRenderable (t) { let e = this._gpuSpriteHash[t.uid]; Y.return(e), this._gpuSpriteHash[t.uid] = null } _updateBatchableSprite (t, e) { t._didSpriteUpdate = !1, e.geometry.update(t), e.texture = t._texture } _getGpuSprite (t) { return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t) } _initGPUSprite (t) { let e = new Ie; return e.geometry = new Le, e.mesh = t, e.texture = t._texture, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t.on("destroyed", () => { this.destroyRenderable(t) }), e } destroy () { for (let t in this._gpuSpriteHash) this._gpuSpriteHash[t].geometry.destroy(); this._gpuSpriteHash = null, this._renderer = null } }; c(Ss, "NineSliceSpritePipe"); Ss.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "nineSliceSprite" } }); var cb = m(() => { S(); Fm(); I.add(Ss) }); var Ts, Im = m(() => { S(); Ts = class { constructor(t) { this._renderer = t } push (t, e, s) { this._renderer.renderPipes.batch.break(s), s.add({ renderPipeId: "filter", canBundle: !1, action: "pushFilter", container: e, filterEffect: t }) } pop (t, e, s) { this._renderer.renderPipes.batch.break(s), s.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } execute (t) { t.action === "pushFilter" ? this._renderer.filter.push(t) : t.action === "popFilter" && this._renderer.filter.pop() } destroy () { this._renderer = null } }; c(Ts, "FilterPipe"); Ts.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "filter" } }); function nh (r, t) { return t.clear(), ah(r, t), t.isValid || t.set(0, 0, 0, 0), r.isRenderGroupRoot ? t.applyMatrix(r.renderGroup.localTransform) : t.applyMatrix(r.renderGroup.worldTransform), t } function ah (r, t) { if (r.localDisplayStatus !== 7 || !r.measurable) return; let e = !!r.effects.length, s = t; if ((r.isRenderGroupRoot || e) && (s = ee.get().clear()), r.boundsArea) t.addRect(r.boundsArea, r.worldTransform); else { if (r.renderPipeId) { let i = r.bounds; s.addFrame(i.minX, i.minY, i.maxX, i.maxY, r.groupTransform) } let o = r.children; for (let i = 0; i < o.length; i++)ah(o[i], s) } if (e) { let o = !1; for (let i = 0; i < r.effects.length; i++)r.effects[i].addBounds && (o || (o = !0, s.applyMatrix(r.renderGroup.worldTransform)), r.effects[i].addBounds(s, !0)); o && (s.applyMatrix(r.renderGroup.worldTransform.copyTo(hT).invert()), t.addBounds(s, r.relativeGroupTransform)), t.addBounds(s), ee.return(s) } else r.isRenderGroupRoot && (t.addBounds(s, r.relativeGroupTransform), ee.return(s)) } var hT, Om = m(() => { ot(); vi(); hT = new B; c(nh, "getFastGlobalBounds"); c(ah, "_getGlobalBoundsRecursive") }); function ch (r, t) { t.clear(); let e = t.matrix; for (let s = 0; s < r.length; s++) { let o = r[s]; o.globalDisplayStatus < 7 || (t.matrix = o.worldTransform, o.addBounds(t)) } return t.matrix = e, t } var km = m(() => { "use strict"; c(ch, "getGlobalRenderableBounds") }); var dT, Es, Dm = m(() => { S(); ot(); ce(); _r(); wo(); Ot(); rt(); br(); Re(); te(); Om(); km(); ut(); dT = new oe({ attributes: { aPosition: { buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), location: 0, format: "float32x2", stride: 2 * 4, offset: 0 } }, indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]) }), Es = class { constructor(t) { this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new et({ uInputSize: { value: new Float32Array(4), type: "vec4<f32>" }, uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" }, uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" } }), this._globalFilterBindGroup = new Rt({}), this.renderer = t } get activeBackTexture () { return this._activeFilterData?.backTexture } push (t) { let e = this.renderer, s = t.filterEffect.filters; this._filterStack[this._filterStackIndex] || (this._filterStack[this._filterStackIndex] = this._getFilterData()); let o = this._filterStack[this._filterStackIndex]; if (this._filterStackIndex++, s.length === 0) { o.skip = !0; return } let i = o.bounds; t.renderables ? ch(t.renderables, i) : t.filterEffect.filterArea ? (i.clear(), i.addRect(t.filterEffect.filterArea), i.applyMatrix(t.container.worldTransform)) : nh(t.container, i); let n = e.renderTarget.rootRenderTarget.colorTexture.source, a = n._resolution, l = 0, h = n.antialias, u = !1, d = !1; for (let p = 0; p < s.length; p++) { let g = s[p]; if (a = Math.min(a, g.resolution), l += g.padding, g.antialias !== "inherit" && (g.antialias === "on" ? h = !0 : h = !1), !!!(g.compatibleRenderers & e.type)) { d = !1; break } if (g.blendRequired && !(e.backBuffer?.useBackBuffer ?? !0)) { U("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), d = !1; break } d = g.enabled || d, u = u || g.blendRequired } if (!d) { o.skip = !0; return } let f = e.renderTarget.rootViewPort; if (i.scale(a).fitBounds(0, f.width, 0, f.height).scale(1 / a).pad(l).ceil(), !i.isPositive) { o.skip = !0; return } o.skip = !1, o.bounds = i, o.blendRequired = u, o.container = t.container, o.filterEffect = t.filterEffect, o.previousRenderSurface = e.renderTarget.renderSurface, o.inputTexture = gt.getOptimalTexture(i.width, i.height, a, h), e.renderTarget.bind(o.inputTexture, !0), e.globalUniforms.push({ offset: i }) } pop () { let t = this.renderer; this._filterStackIndex--; let e = this._filterStack[this._filterStackIndex]; if (e.skip) return; this._activeFilterData = e; let s = e.inputTexture, o = e.bounds, i = E.EMPTY; if (t.renderTarget.finishRenderPass(), e.blendRequired) { let a = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null, l = t.renderTarget.getRenderTarget(e.previousRenderSurface); i = this.getBackTexture(l, o, a) } e.backTexture = i; let n = e.filterEffect.filters; if (this._globalFilterBindGroup.setResource(s.source.style, 2), this._globalFilterBindGroup.setResource(i.source, 3), t.globalUniforms.pop(), n.length === 1) n[0].apply(this, s, e.previousRenderSurface, !1), gt.returnTexture(s); else { let a = e.inputTexture, l = gt.getOptimalTexture(o.width, o.height, a.source._resolution, !1), h = 0; for (h = 0; h < n.length - 1; ++h) { n[h].apply(this, a, l, !0); let d = a; a = l, l = d } n[h].apply(this, a, e.previousRenderSurface, !1), gt.returnTexture(a), gt.returnTexture(l) } e.blendRequired && gt.returnTexture(i) } getBackTexture (t, e, s) { let o = t.colorTexture.source._resolution, i = gt.getOptimalTexture(e.width, e.height, o, !1), n = e.minX, a = e.minY; s && (n -= s.minX, a -= s.minY), n = Math.floor(n * o), a = Math.floor(a * o); let l = Math.ceil(e.width * o), h = Math.ceil(e.height * o); return this.renderer.renderTarget.copyToTexture(t, i, { x: n, y: a }, { width: l, height: h }, { x: 0, y: 0 }), i } applyFilter (t, e, s, o) { let i = this.renderer, n = this._filterStack[this._filterStackIndex], a = n.bounds, l = V.shared, u = n.previousRenderSurface === s, d = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution, f = this._filterStackIndex - 1; for (; f > 0 && this._filterStack[f].skip;)--f; f > 0 && (d = this._filterStack[f].inputTexture.source._resolution); let p = this._filterGlobalUniforms, g = p.uniforms, b = g.uOutputFrame, _ = g.uInputSize, y = g.uInputPixel, v = g.uInputClamp, T = g.uGlobalFrame, P = g.uOutputTexture; if (u) { let R = this._filterStackIndex; for (; R > 0;) { R--; let F = this._filterStack[this._filterStackIndex - 1]; if (!F.skip) { l.x = F.bounds.minX, l.y = F.bounds.minY; break } } b[0] = a.minX - l.x, b[1] = a.minY - l.y } else b[0] = 0, b[1] = 0; b[2] = e.frame.width, b[3] = e.frame.height, _[0] = e.source.width, _[1] = e.source.height, _[2] = 1 / _[0], _[3] = 1 / _[1], y[0] = e.source.pixelWidth, y[1] = e.source.pixelHeight, y[2] = 1 / y[0], y[3] = 1 / y[1], v[0] = .5 * y[2], v[1] = .5 * y[3], v[2] = e.frame.width * _[2] - .5 * y[2], v[3] = e.frame.height * _[3] - .5 * y[3]; let M = this.renderer.renderTarget.rootRenderTarget.colorTexture; T[0] = l.x * d, T[1] = l.y * d, T[2] = M.source.width * d, T[3] = M.source.height * d; let D = this.renderer.renderTarget.getRenderTarget(s); if (i.renderTarget.bind(s, !!o), s instanceof E ? (P[0] = s.frame.width, P[1] = s.frame.height) : (P[0] = D.width, P[1] = D.height), P[2] = D.isRoot ? -1 : 1, p.update(), i.renderPipes.uniformBatch) { let R = i.renderPipes.uniformBatch.getUboResource(p); this._globalFilterBindGroup.setResource(R, 0) } else this._globalFilterBindGroup.setResource(p, 0); this._globalFilterBindGroup.setResource(e.source, 1), this._globalFilterBindGroup.setResource(e.source.style, 2), t.groups[0] = this._globalFilterBindGroup, i.encoder.draw({ geometry: dT, shader: t, state: t._state, topology: "triangle-list" }), i.type === yt.WEBGL && i.renderTarget.finishRenderPass() } _getFilterData () { return { skip: !1, inputTexture: null, bounds: new it, container: null, filterEffect: null, blendRequired: !1, previousRenderSurface: null } } calculateSpriteMatrix (t, e) { let s = this._activeFilterData, o = t.set(s.inputTexture._source.width, 0, 0, s.inputTexture._source.height, s.bounds.minX, s.bounds.minY), i = e.worldTransform.copyTo(B.shared); return i.invert(), o.prepend(i), o.scale(1 / e.texture.frame.width, 1 / e.texture.frame.height), o.translate(e.anchor.x, e.anchor.y), o } }; c(Es, "FilterSystem"); Es.extension = { type: [x.WebGLSystem, x.WebGPUSystem], name: "filter" } }); var lb = m(() => { S(); Im(); Dm(); I.add(Es); I.add(Ts) }); var fT = {}; var Lv = m(() => { Ay(); __(); My(); jf(); op(); O_(); D_(); j_(); sb(); ob(); ab(); cb(); lb() }); var pT = {}; var Hv = m(() => { __(); jf(); op(); O_(); D_(); j_(); sb(); ob(); ab(); cb(); lb() }); var Nv, Nt, ir = m(() => { xe(); Pe(); Me(); Se(); Nv = c(class ub extends dt { constructor(t) { t = { ...ub.defaultOptions, ...t }, super(t), this.enabled = !0, this._state = Pt.for2d(), this.padding = t.padding, typeof t.antialias == "boolean" ? this.antialias = t.antialias ? "on" : "off" : this.antialias = t.antialias, this.resolution = t.resolution, this.blendRequired = t.blendRequired, this.addResource("uTexture", 0, 1) } apply (t, e, s, o) { t.applyFilter(this, e, s, o) } get blendMode () { return this._state.blendMode } set blendMode (t) { this._state.blendMode = t } static from (t) { let { gpu: e, gl: s, ...o } = t, i, n; return e && (i = ht.from(e)), s && (n = bt.from(s)), new ub({ gpuProgram: i, glProgram: n, ...o }) } }, "_Filter"); Nv.defaultOptions = { blendMode: "normal", resolution: 1, padding: 0, antialias: "off", blendRequired: !1 }; Nt = Nv }); function Rn () { if (typeof fh == "boolean") return fh; try { fh = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0 } catch { fh = !1 } return fh } var fh, ph = m(() => { "use strict"; c(Rn, "unsafeEvalSupported") }); var mT, xT, db = m(() => { mT = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1), xT = Ct(Tt("/node_modules/earcut?_v=2.2.4&_env=prod"), 1) }); var Ut, Wo = m(() => { "use strict"; Ut = (r => (r[r.NONE = 0] = "NONE", r[r.COLOR = 16384] = "COLOR", r[r.STENCIL = 1024] = "STENCIL", r[r.DEPTH = 256] = "DEPTH", r[r.COLOR_DEPTH = 16640] = "COLOR_DEPTH", r[r.COLOR_STENCIL = 17408] = "COLOR_STENCIL", r[r.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", r[r.ALL = 17664] = "ALL", r))(Ut || {}) }); var Gr, mh = m(() => { "use strict"; Gr = class { constructor(t) { this.items = [], this._name = t } emit (t, e, s, o, i, n, a, l) { let { name: h, items: u } = this; for (let d = 0, f = u.length; d < f; d++)u[d][h](t, e, s, o, i, n, a, l); return this } add (t) { return t[this._name] && (this.remove(t), this.items.push(t)), this } remove (t) { let e = this.items.indexOf(t); return e !== -1 && this.items.splice(e, 1), this } contains (t) { return this.items.indexOf(t) !== -1 } removeAll () { return this.items.length = 0, this } destroy () { this.removeAll(), this.items = null, this._name = null } get empty () { return this.items.length === 0 } get name () { return this._name } }; c(Gr, "SystemRunner") }); var Xv, gT, zv, nr, Mn = m(() => { $t(); It(); ph(); lt(); db(); Wo(); mh(); Xv = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1), gT = ["init", "destroy", "contextChange", "resolutionChange", "reset", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"], zv = c(class Vv extends Xv.default { constructor(t) { super(), this.runners = Object.create(null), this.renderPipes = Object.create(null), this._initOptions = {}, this._systemsHash = Object.create(null), this.type = t.type, this.name = t.name; let e = [...gT, ...t.runners ?? []]; this._addRunners(...e), this._addSystems(t.systems), this._addPipes(t.renderPipes, t.renderPipeAdaptors), this._unsafeEvalCheck() } async init (t = {}) { for (let e in this._systemsHash) t = { ...this._systemsHash[e].constructor.defaultOptions, ...t }; t = { ...Vv.defaultOptions, ...t }, this._roundPixels = t.roundPixels ? 1 : 0; for (let e = 0; e < this.runners.init.items.length; e++)await this.runners.init.items[e].init(t); this._initOptions = t } render (t, e) { let s = t; if (s instanceof N && (s = { container: s }, e && (w(G, "passing a second argument is deprecated, please use render options instead"), s.target = e.renderTexture)), s.target || (s.target = this.view.renderTarget), s.target === this.view.renderTarget && (this._lastObjectRendered = s.container, s.clearColor = this.background.colorRgba), s.clearColor) { let o = Array.isArray(s.clearColor) && s.clearColor.length === 4; s.clearColor = o ? s.clearColor : j.shared.setValue(s.clearColor).toArray() } s.transform || (s.container.updateLocalTransform(), s.transform = s.container.localTransform), this.runners.prerender.emit(s), this.runners.renderStart.emit(s), this.runners.render.emit(s), this.runners.renderEnd.emit(s), this.runners.postrender.emit(s) } resize (t, e, s) { this.view.resize(t, e, s), this.emit("resize", this.view.screen.width, this.view.screen.height) } clear (t = {}) { let e = this; t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = Ut.ALL); let { clear: s, clearColor: o, target: i } = t; j.shared.setValue(o ?? this.background.colorRgba), e.renderTarget.clear(i, s, j.shared.toArray()) } get resolution () { return this.view.resolution } set resolution (t) { this.view.resolution = t, this.runners.resolutionChange.emit(t) } get width () { return this.view.texture.frame.width } get height () { return this.view.texture.frame.height } get canvas () { return this.view.canvas } get lastObjectRendered () { return this._lastObjectRendered } get renderingToScreen () { return this.renderTarget.renderingToScreen } get screen () { return this.view.screen } _addRunners (...t) { t.forEach(e => { this.runners[e] = new Gr(e) }) } _addSystems (t) { let e; for (e in t) { let s = t[e]; this._addSystem(s.value, s.name) } } _addSystem (t, e) { let s = new t(this); if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`); this[e] = s, this._systemsHash[e] = s; for (let o in this.runners) this.runners[o].add(s); return this } _addPipes (t, e) { let s = e.reduce((o, i) => (o[i.name] = i.value, o), {}); t.forEach(o => { let i = o.value, n = o.name, a = s[n]; this.renderPipes[n] = new i(this, a ? new a : null) }) } destroy (t = !1) { this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach(e => { e.destroy() }), this._systemsHash = null, this.renderPipes = null } generateTexture (t) { return this.textureGenerator.generateTexture(t) } get roundPixels () { return !!this._roundPixels } _unsafeEvalCheck () { if (!Rn()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } }, "_AbstractRenderer"); zv.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: !1, roundPixels: !1 }; nr = zv }); var Bs, Xm = m(() => { S(); ot(); va(); Ze(); sr(); Oo(); ko(); Lo(); or(); Me(); Ot(); Bs = class { init () { let t = new et({ uTransformMatrix: { value: new B, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), e = Ce({ name: "graphics", bits: [fs, ms(16), Qu, Ae] }); this.shader = new dt({ gpuProgram: e, resources: { localUniforms: t } }) } execute (t, e) { let s = e.context, o = s.customShader || this.shader, i = t.renderer, n = i.graphicsContext, { geometry: a, instructions: l } = n.getContextRenderData(s), h = i.encoder; h.setPipelineFromGeometryProgramAndState(a, o.gpuProgram, t.state), h.setGeometry(a); let u = i.globalUniforms.bindGroup; h.setBindGroup(0, u, o.gpuProgram); let d = i.renderPipes.uniformBatch.getUniformBindGroup(o.resources.localUniforms, !0); h.setBindGroup(2, d, o.gpuProgram); let f = l.instructions; for (let p = 0; p < l.instructionSize; p++) { let g = f[p]; if (o.groups[1] = g.bindGroup, !g.gpuBindGroup) { let b = g.textures; g.bindGroup = Zr(b.textures, b.count), g.gpuBindGroup = i.bindGroup.getBindGroup(g.bindGroup, o.gpuProgram, 1) } h.setBindGroup(1, g.bindGroup, o.gpuProgram), h.renderPassEncoder.drawIndexed(g.size, 1, g.start) } } destroy () { this.shader.destroy(!0), this.shader = null } }; c(Bs, "GpuGraphicsAdaptor"); Bs.extension = { type: [x.WebGPUPipesAdaptor], name: "graphics" } }); var xh, gh, _h = m(() => {
          "use strict"; xh = {
            name: "texture-bit", vertex: {
              header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `, main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `}, fragment: {
              header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `, main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `}
          }, gh = {
            name: "texture-bit", vertex: {
              header: `
            uniform mat3 uTextureMatrix;
        `, main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `}, fragment: {
              header: `
        uniform sampler2D uTexture;

         
        `, main: `
            outColor = texture(uTexture, vUV);
        `}
          }
        }); var As, zm = m(() => { S(); ot(); sr(); Lo(); or(); _h(); Me(); rt(); ut(); As = class { init () { let t = Ce({ name: "mesh", bits: [Mr, xh, Ae] }); this._shader = new dt({ gpuProgram: t, resources: { uTexture: E.EMPTY._source, uSampler: E.EMPTY._source.style, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new B } } } }) } execute (t, e) { let s = t.renderer, o = e._shader; if (!o) o = this._shader, o.resources.uTexture = e.texture.source, o.resources.uSampler = e.texture.source.style, o.resources.textureUniforms.uniforms.uTextureMatrix = e.texture.textureMatrix.mapCoord; else if (!o.gpuProgram) { U("Mesh shader has no gpuProgram", e.shader); return } let i = o.gpuProgram; if (i.autoAssignGlobalUniforms && (o.groups[0] = s.globalUniforms.bindGroup), i.autoAssignLocalUniforms) { let n = t.localUniforms; o.groups[1] = s.renderPipes.uniformBatch.getUniformBindGroup(n, !0) } s.encoder.draw({ geometry: e._geometry, shader: o, state: e.state }) } destroy () { this._shader.destroy(!0), this._shader = null } }; c(As, "GpuMeshAdapter"); As.extension = { type: [x.WebGPUPipesAdaptor], name: "mesh" } }); var Vm, ws, Ym = m(() => { S(); sr(); Oo(); ko(); or(); Me(); Se(); Ze(); va(); Vm = Pt.for2d(), ws = class { init () { let t = Ce({ name: "batch", bits: [fs, ms(16), Ae] }); this._shader = new dt({ gpuProgram: t, groups: {} }) } start (t, e) { let s = t.renderer, o = s.encoder, i = this._shader.gpuProgram; this._geometry = e, o.setGeometry(e), Vm.blendMode = "normal", s.pipeline.getPipeline(e, i, Vm); let n = s.globalUniforms.bindGroup; o.resetBindGroup(1), o.setBindGroup(0, n, i) } execute (t, e) { let s = this._shader.gpuProgram, o = t.renderer, i = o.encoder; if (!e.bindGroup) { let l = e.textures; e.bindGroup = Zr(l.textures, l.count) } Vm.blendMode = e.blendMode; let n = o.bindGroup.getBindGroup(e.bindGroup, s, 1), a = o.pipeline.getPipeline(this._geometry, s, Vm); e.bindGroup._touch(o.textureGC.count), i.setPipeline(a), i.renderPassEncoder.setBindGroup(1, n), i.renderPassEncoder.drawIndexed(e.size, 1, e.start) } destroy () { this._shader.destroy(!0), this._shader = null } }; c(ws, "GpuBatchAdaptor"); ws.extension = { type: [x.WebGPUPipesAdaptor], name: "batch" } }); var Rs, $m = m(() => { S(); Rs = class { constructor(t) { this._renderer = t } addRenderable (t, e) { this._renderer.renderPipes.batch.break(e), e.add(t) } execute (t) { t.isRenderable && t.render(this._renderer) } destroy () { this._renderer = null } }; c(Rs, "CustomRenderPipe"); Rs.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "customRender" } }); function Gn (r, t) { let e = r.instructionSet, s = e.instructions; for (let o = 0; o < e.instructionSize; o++) { let i = s[o]; t[i.renderPipeId].execute(i) } } var bh = m(() => { "use strict"; c(Gn, "executeInstructions") }); var Ms, jm = m(() => { S(); bh(); Ms = class { constructor(t) { this._renderer = t } addRenderGroup (t, e) { this._renderer.renderPipes.batch.break(e), e.add(t) } execute (t) { t.isRenderable && (this._renderer.globalUniforms.push({ worldTransformMatrix: t.worldTransform, worldColor: t.worldColorAlpha }), Gn(t, this._renderer.renderPipes), this._renderer.globalUniforms.pop()) } destroy () { this._renderer = null } }; c(Ms, "RenderGroupPipe"); Ms.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "renderGroup" } }); function yh (r, t) { let e = r.root, s = r.instructionSet; s.reset(), t.batch.buildStart(s), t.blendMode.buildStart(), t.colorMask.buildStart(), e.sortableChildren && e.sortChildren(), Yv(e, s, t, !0), t.batch.buildEnd(s), t.blendMode.buildEnd(s) } function Gs (r, t, e) { r.globalDisplayStatus < 7 || !r.includeInBuild || (r.sortableChildren && r.sortChildren(), r.isSimple ? _T(r, t, e) : Yv(r, t, e, !1)) } function _T (r, t, e) { if (r.renderPipeId && (e.blendMode.setBlendMode(r, r.groupBlendMode, t), r.didViewUpdate = !1, e[r.renderPipeId].addRenderable(r, t)), !r.isRenderGroupRoot) { let s = r.children, o = s.length; for (let i = 0; i < o; i++)Gs(s[i], t, e) } } function Yv (r, t, e, s) { if (!s && r.isRenderGroupRoot) e.renderGroup.addRenderGroup(r.renderGroup, t); else { for (let n = 0; n < r.effects.length; n++) { let a = r.effects[n]; e[a.pipe].push(a, r, t) } let o = r.renderPipeId; o && (e.blendMode.setBlendMode(r, r.groupBlendMode, t), r.didViewUpdate = !1, e[o].addRenderable(r, t)); let i = r.children; if (i.length) for (let n = 0; n < i.length; n++)Gs(i[n], t, e); for (let n = r.effects.length - 1; n >= 0; n--) { let a = r.effects[n]; e[a.pipe].pop(a, r, t) } } } var Wa = m(() => { "use strict"; c(yh, "buildInstructions"); c(Gs, "collectAllRenderables"); c(_T, "collectAllRenderablesSimple"); c(Yv, "collectAllRenderablesAdvanced") }); function Xa (r, t = []) { t.push(r); for (let e = 0; e < r.renderGroupChildren.length; e++)Xa(r.renderGroupChildren[e], t); return t } var Km = m(() => { "use strict"; c(Xa, "collectRenderGroups") }); function za (r, t, e) { let s = r >> 16 & 255, o = r >> 8 & 255, i = r & 255, n = t >> 16 & 255, a = t >> 8 & 255, l = t & 255, h = s + (n - s) * e, u = o + (a - o) * e, d = i + (l - i) * e; return (h << 16) + (u << 8) + d } var qm = m(() => { "use strict"; c(za, "mixHexColors") }); function Ya (r, t) { return r === Va || t === Va ? r + t - Va : za(r, t, .5) } function fb (r, t, e) { let s = (e >> 24 & 255) / 255, o = t * s * 255, i = ((r & 255) << 16) + (r & 65280) + (r >> 16 & 255), n = e & 16777215, a; return i === Va || n === Va ? a = i + n - Va : a = za(i, n, .5), a + (o << 24) } var Va, Zm = m(() => { qm(); Va = 16777215; c(Ya, "mixColors"); c(fb, "mixStandardAnd32BitColors") }); function $a (r, t = !1) { Qm(r); let e = r.childrenToUpdate, s = r.updateTick; r.updateTick++; for (let o in e) { let i = e[o], n = i.list, a = i.index; for (let l = 0; l < a; l++)vh(n[l], s, 0); i.index = 0 } if (t) for (let o = 0; o < r.renderGroupChildren.length; o++)$a(r.renderGroupChildren[o], t) } function Qm (r) { let t = r.root, e; if (r.renderGroupParent) { let s = r.renderGroupParent; r.worldTransform.appendFrom(t.relativeGroupTransform, s.worldTransform), r.worldColor = Ya(t.groupColor, s.worldColor), e = t.groupAlpha * s.worldAlpha } else r.worldTransform.copyFrom(t.localTransform), r.worldColor = t.localColor, e = t.localAlpha; e = e < 0 ? 0 : e > 1 ? 1 : e, r.worldAlpha = e, r.worldColorAlpha = r.worldColor + ((e * 255 | 0) << 24) } function vh (r, t, e) { if (t === r.updateTick) return; r.updateTick = t, r.didChange = !1; let s = r.localTransform; r.updateLocalTransform(); let o = r.parent; if (o && !o.isRenderGroupRoot ? (e = e | r._updateFlags, r.relativeGroupTransform.appendFrom(s, o.relativeGroupTransform), e && $v(r, o, e)) : (e = r._updateFlags, r.relativeGroupTransform.copyFrom(s), e && $v(r, bT, e)), !r.isRenderGroupRoot) { let i = r.children, n = i.length; for (let l = 0; l < n; l++)vh(i[l], t, e); let a = r.renderGroup; r.renderPipeId && !a.structureDidChange && a.updateRenderable(r) } } function $v (r, t, e) { if (e & Si) { r.groupColor = Ya(r.localColor, t.groupColor); let s = r.localAlpha * t.groupAlpha; s = s < 0 ? 0 : s > 1 ? 1 : s, r.groupAlpha = s, r.groupColorAlpha = r.groupColor + ((s * 255 | 0) << 24) } e & ua && (r.groupBlendMode = r.localBlendMode === "inherit" ? t.groupBlendMode : r.localBlendMode), e & To && (r.globalDisplayStatus = r.localDisplayStatus & t.globalDisplayStatus), r._updateFlags = 0 } var bT, Jm = m(() => { It(); Zm(); bT = new N; c($a, "updateRenderGroupTransforms"); c(Qm, "updateRenderGroupTransform"); c(vh, "updateTransformAndChildren"); c($v, "updateColorBlendVisibility") }); function Sh (r, t) { let { list: e, index: s } = r.childrenRenderablesToUpdate, o = !1; for (let i = 0; i < s; i++) { let n = e[i]; if (o = t[n.renderPipeId].validateRenderable(n), o) break } return r.structureDidChange = o, o } var tx = m(() => { "use strict"; c(Sh, "validateRenderables") }); function vT (r) { let { list: t, index: e } = r.childrenRenderablesToUpdate; for (let s = 0; s < e; s++) { let o = t[s]; o.didViewUpdate && r.updateRenderable(o) } } var yT, Us, ex = m(() => { S(); ot(); Wa(); Km(); bh(); Jm(); tx(); yT = new B, Us = class { constructor(t) { this._renderer = t } render ({ container: t, transform: e }) { t.isRenderGroup = !0; let s = t.parent, o = t.renderGroup.renderGroupParent; t.parent = null, t.renderGroup.renderGroupParent = null; let i = this._renderer, n = Xa(t.renderGroup, []), a = yT; e && (a = a.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(e)); let l = i.renderPipes; for (let h = 0; h < n.length; h++) { let u = n[h]; u.runOnRender(), u.instructionSet.renderPipes = l, u.structureDidChange || Sh(u, l), $a(u), u.structureDidChange ? (u.structureDidChange = !1, yh(u, l)) : vT(u), u.childrenRenderablesToUpdate.index = 0, i.renderPipes.batch.upload(u.instructionSet) } i.globalUniforms.start({ worldTransformMatrix: e ? t.renderGroup.localTransform : t.renderGroup.worldTransform, worldColor: t.renderGroup.worldColorAlpha }), Gn(t.renderGroup, l), l.uniformBatch && l.uniformBatch.renderEnd(), e && t.renderGroup.localTransform.copyFrom(a), t.parent = s, t.renderGroup.renderGroupParent = o } destroy () { this._renderer = null } }; c(Us, "RenderGroupSystem"); Us.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "renderGroup" }; c(vT, "updateRenderables") }); var Fs, rx = m(() => { S(); Jt(); Ca(); Fs = class { constructor(t) { this._gpuSpriteHash = Object.create(null), this._renderer = t } addRenderable (t, e) { let s = this._getGpuSprite(t); t._didSpriteUpdate && this._updateBatchableSprite(t, s), this._renderer.renderPipes.batch.addToBatch(s) } updateRenderable (t) { let e = this._gpuSpriteHash[t.uid]; t._didSpriteUpdate && this._updateBatchableSprite(t, e), e.batcher.updateElement(e) } validateRenderable (t) { let e = t._texture, s = this._getGpuSprite(t); return s.texture._source !== e._source ? !s.batcher.checkAndUpdateTexture(s, e) : !1 } destroyRenderable (t) { let e = this._gpuSpriteHash[t.uid]; Y.return(e), this._gpuSpriteHash[t.uid] = null } _updateBatchableSprite (t, e) { t._didSpriteUpdate = !1, e.bounds = t.bounds, e.texture = t._texture } _getGpuSprite (t) { return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t) } _initGPUSprite (t) { let e = Y.get(Oe); return e.renderable = t, e.texture = t._texture, e.bounds = t.bounds, e.roundPixels = this._renderer._roundPixels | t._roundPixels, this._gpuSpriteHash[t.uid] = e, t._didSpriteUpdate = !1, t.on("destroyed", () => { this.destroyRenderable(t) }), e } destroy () { for (let t in this._gpuSpriteHash) Y.return(this._gpuSpriteHash[t]); this._gpuSpriteHash = null, this._renderer = null } }; c(Fs, "SpritePipe"); Fs.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "sprite" } }); var Is, sx = m(() => { S(); Se(); Bl(); Ml(); Is = class { constructor(t, e) { this.state = Pt.for2d(), this._batches = Object.create(null), this._geometries = Object.create(null), this.renderer = t, this._adaptor = e, this._adaptor.init(this) } buildStart (t) { if (!this._batches[t.uid]) { let e = new Ui; this._batches[t.uid] = e, this._geometries[e.uid] = new gr } this._activeBatch = this._batches[t.uid], this._activeGeometry = this._geometries[this._activeBatch.uid], this._activeBatch.begin() } addToBatch (t) { this._activeBatch.add(t) } break (t) { this._activeBatch.break(t) } buildEnd (t) { let e = this._activeBatch, s = this._activeGeometry; e.finish(t), s.indexBuffer.setDataWithSize(e.indexBuffer, e.indexSize, !0), s.buffers[0].setDataWithSize(e.attributeBuffer.float32View, e.attributeSize, !1) } upload (t) { let e = this._batches[t.uid], s = this._geometries[e.uid]; e.dirty && (e.dirty = !1, s.buffers[0].update(e.attributeSize * 4)) } execute (t) { if (t.action === "startBatch") { let e = t.batcher, s = this._geometries[e.uid]; this._adaptor.start(this, s) } this._adaptor.execute(this, t) } destroy () { this.state = null, this.renderer = null, this._adaptor.destroy(), this._adaptor = null; for (let t in this._batches) this._batches[t].destroy(); this._batches = null; for (let t in this._geometries) this._geometries[t].destroy(); this._geometries = null } }; c(Is, "BatcherPipe"); Is.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "batch" } }); var Th, ox = m(() => {
          Th = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha; 
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * uAlpha * clip);

    finalColor = original;
}
`}); var Eh, ix = m(() => {
            Eh = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`}); var ja, nx = m(() => {
              ja = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,  
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;

     var clip = step(3.5,
        step(maskClamp.x, filterUv.x) +
        step(maskClamp.y, filterUv.y) +
        step(filterUv.x, maskClamp.z) +
        step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    
    var npmAlpha = 0.0;

    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);

    var a = (alphaMul * mask.r) * clip;

    return vec4(source.rgb, source.a) * a;
}`}); var Xo, ax = m(() => { ot(); xe(); Pe(); Ot(); yl(); ir(); ox(); ix(); nx(); Xo = class extends Nt { constructor(t) { let { sprite: e, ...s } = t, o = new pr(e.texture), i = new et({ uFilterMatrix: { value: new B, type: "mat3x3<f32>" }, uMaskClamp: { value: o.uClampFrame, type: "vec4<f32>" }, uAlpha: { value: 1, type: "f32" } }), n = ht.from({ vertex: { source: ja, entryPoint: "mainVertex" }, fragment: { source: ja, entryPoint: "mainFragment" } }), a = bt.from({ vertex: Eh, fragment: Th, name: "mask-filter" }); super({ ...s, gpuProgram: n, glProgram: a, resources: { filterUniforms: i, uMaskTexture: e.texture.source } }), this.sprite = e, this._textureMatrix = o } apply (t, e, s, o) { this._textureMatrix.texture = this.sprite.texture, t.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, e, s, o) } }; c(Xo, "MaskFilter") }); var ST, cx, Os, lx = m(() => { S(); aa(); ax(); te(); vo(); Wa(); zr(); Jt(); rt(); br(); ST = new it, cx = class extends Ue { constructor() { super({ filters: [new Xo({ sprite: new wt(E.EMPTY) })] }) } get sprite () { return this.filters[0].sprite } set sprite (t) { this.filters[0].sprite = t } }; c(cx, "AlphaMaskEffect"); Os = class { constructor(t) { this._activeMaskStage = [], this._renderer = t } push (t, e, s) { let o = this._renderer; if (o.renderPipes.batch.break(s), s.add({ renderPipeId: "alphaMask", action: "pushMaskBegin", mask: t, canBundle: !1, maskedContainer: e }), t.renderMaskToTexture) { let i = t.mask; i.includeInBuild = !0, Gs(i, s, o.renderPipes), i.includeInBuild = !1 } o.renderPipes.batch.break(s), s.add({ renderPipeId: "alphaMask", action: "pushMaskEnd", mask: t, maskedContainer: e, canBundle: !1 }) } pop (t, e, s) { this._renderer.renderPipes.batch.break(s), s.add({ renderPipeId: "alphaMask", action: "popMaskEnd", mask: t, canBundle: !1 }) } execute (t) { let e = this._renderer, s = t.mask.renderMaskToTexture; if (t.action === "pushMaskBegin") { let o = Y.get(cx); if (s) { t.mask.mask.measurable = !0; let i = Ye(t.mask.mask, !0, ST); t.mask.mask.measurable = !1, i.ceil(); let n = gt.getOptimalTexture(i.width, i.height, 1, !1); e.renderTarget.push(n, !0), e.globalUniforms.push({ offset: i, worldColor: 4294967295 }); let a = o.sprite; a.texture = n, a.worldTransform.tx = i.minX, a.worldTransform.ty = i.minY, this._activeMaskStage.push({ filterEffect: o, maskedContainer: t.maskedContainer, filterTexture: n }) } else o.sprite = t.mask.mask, this._activeMaskStage.push({ filterEffect: o, maskedContainer: t.maskedContainer }) } else if (t.action === "pushMaskEnd") { let o = this._activeMaskStage[this._activeMaskStage.length - 1]; s && (e.renderTarget.pop(), e.globalUniforms.pop()), e.filter.push({ renderPipeId: "filter", action: "pushFilter", container: o.maskedContainer, filterEffect: o.filterEffect, canBundle: !1 }) } else if (t.action === "popMaskEnd") { e.filter.pop(); let o = this._activeMaskStage.pop(); s && gt.returnTexture(o.filterTexture), Y.return(o.filterEffect) } } destroy () { this._renderer = null, this._activeMaskStage = null } }; c(Os, "AlphaMaskPipe"); Os.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "alphaMask" } }); var ks, ux = m(() => { S(); ks = class { constructor(t) { this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = t } buildStart () { this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15 } push (t, e, s) { this._renderer.renderPipes.batch.break(s); let i = this._colorStack; i[this._colorStackIndex] = i[this._colorStackIndex - 1] & t.mask; let n = this._colorStack[this._colorStackIndex]; n !== this._currentColor && (this._currentColor = n, s.add({ renderPipeId: "colorMask", colorMask: n, canBundle: !1 })), this._colorStackIndex++ } pop (t, e, s) { this._renderer.renderPipes.batch.break(s); let i = this._colorStack; this._colorStackIndex--; let n = i[this._colorStackIndex - 1]; n !== this._currentColor && (this._currentColor = n, s.add({ renderPipeId: "colorMask", colorMask: n, canBundle: !1 })) } execute (t) { this._renderer.colorMask.setMask(t.colorMask) } destroy () { this._colorStack = null } }; c(ks, "ColorMaskPipe"); ks.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "colorMask" } }); var Ds, hx = m(() => { S(); Wa(); Wo(); Jr(); Ds = class { constructor(t) { this._maskStackHash = {}, this._maskHash = new WeakMap, this._renderer = t } push (t, e, s) { var o; let i = t, n = this._renderer; n.renderPipes.batch.break(s), n.renderPipes.blendMode.setBlendMode(i.mask, "none", s), s.add({ renderPipeId: "stencilMask", action: "pushMaskBegin", mask: t, canBundle: !1 }); let a = i.mask; a.includeInBuild = !0, this._maskHash.has(i) || this._maskHash.set(i, { instructionsStart: 0, instructionsLength: 0 }); let l = this._maskHash.get(i); l.instructionsStart = s.instructionSize, Gs(a, s, n.renderPipes), a.includeInBuild = !1, n.renderPipes.batch.break(s), s.add({ renderPipeId: "stencilMask", action: "pushMaskEnd", mask: t, canBundle: !1 }); let h = s.instructionSize - l.instructionsStart - 1; l.instructionsLength = h; let u = n.renderTarget.renderTarget.uid; (o = this._maskStackHash)[u] ?? (o[u] = 0) } pop (t, e, s) { let o = t, i = this._renderer; i.renderPipes.batch.break(s), i.renderPipes.blendMode.setBlendMode(o.mask, "none", s), s.add({ renderPipeId: "stencilMask", action: "popMaskBegin", canBundle: !1 }); let n = this._maskHash.get(t); for (let a = 0; a < n.instructionsLength; a++)s.instructions[s.instructionSize++] = s.instructions[n.instructionsStart++]; s.add({ renderPipeId: "stencilMask", action: "popMaskEnd", canBundle: !1 }) } execute (t) { var e; let s = this._renderer, o = s.renderTarget.renderTarget.uid, i = (e = this._maskStackHash)[o] ?? (e[o] = 0); t.action === "pushMaskBegin" ? (s.renderTarget.ensureDepthStencil(), s.stencil.setStencilMode(xt.RENDERING_MASK_ADD, i), i++, s.colorMask.setMask(0)) : t.action === "pushMaskEnd" ? (s.stencil.setStencilMode(xt.MASK_ACTIVE, i), s.colorMask.setMask(15)) : t.action === "popMaskBegin" ? (s.colorMask.setMask(0), i !== 0 ? s.stencil.setStencilMode(xt.RENDERING_MASK_REMOVE, i) : (s.renderTarget.clear(null, Ut.STENCIL), s.stencil.setStencilMode(xt.DISABLED, i)), i--) : t.action === "popMaskEnd" && (s.stencil.setStencilMode(xt.MASK_ACTIVE, i), s.colorMask.setMask(15)), this._maskStackHash[o] = i } destroy () { this._renderer = null, this._maskStackHash = null, this._maskHash = null } }; c(Ds, "StencilMaskPipe"); Ds.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "stencilMask" } }); var pb, Ph, dx = m(() => { $t(); S(); pb = c(class jv { constructor() { this.clearBeforeRender = !0, this._backgroundColor = new j(0), this.color = this._backgroundColor, this.alpha = 1 } init (t) { t = { ...jv.defaultOptions, ...t }, this.clearBeforeRender = t.clearBeforeRender, this.color = t.background || t.backgroundColor || this._backgroundColor, this.alpha = t.backgroundAlpha, this._backgroundColor.setAlpha(t.backgroundAlpha) } get color () { return this._backgroundColor } set color (t) { this._backgroundColor.setValue(t) } get alpha () { return this._backgroundColor.alpha } set alpha (t) { this._backgroundColor.setAlpha(t) } get colorRgba () { return this._backgroundColor.toArray() } destroy () { } }, "_BackgroundSystem"); pb.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "background", priority: 0 }; pb.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 }; Ph = pb }); var Ch, Ls, fx = m(() => { S(); aa(); ut(); Ch = {}; I.handle(x.BlendMode, r => { if (!r.name) throw new Error("BlendMode extension must have a name property"); Ch[r.name] = r.ref }, r => { delete Ch[r.name] }); Ls = class { constructor(t) { this._isAdvanced = !1, this._filterHash = Object.create(null), this._renderer = t } setBlendMode (t, e, s) { if (this._activeBlendMode === e) { this._isAdvanced && this._renderableList.push(t); return } this._activeBlendMode = e, this._isAdvanced && this._endAdvancedBlendMode(s), this._isAdvanced = !!Ch[e], this._isAdvanced && (this._beginAdvancedBlendMode(s), this._renderableList.push(t)) } _beginAdvancedBlendMode (t) { this._renderer.renderPipes.batch.break(t); let e = this._activeBlendMode; if (!Ch[e]) { U(`Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`); return } this._filterHash[e] || (this._filterHash[e] = new Ue({ filters: [new Ch[e]] })); let s = { renderPipeId: "filter", action: "pushFilter", renderables: [], filterEffect: this._filterHash[e], canBundle: !1 }; this._renderableList = s.renderables, t.add(s) } _endAdvancedBlendMode (t) { this._renderableList = null, this._renderer.renderPipes.batch.break(t), t.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } buildStart () { this._isAdvanced = !1 } buildEnd (t) { this._isAdvanced && this._endAdvancedBlendMode(t) } destroy () { this._renderer = null, this._renderableList = null; for (let t in this._filterHash) this._filterHash[t].destroy(); this._filterHash = null } }; c(Ls, "BlendModePipe"); Ls.extension = { type: [x.WebGLPipes, x.WebGPUPipes, x.CanvasPipes], name: "blendMode" } }); var mb, xb, Bh, px = m(() => { S(); It(); rt(); mb = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, xb = c(class Kv { constructor(t) { this._renderer = t } _normalizeOptions (t, e = {}) { return t instanceof N || t instanceof E ? { target: t, ...e } : { ...e, ...t } } async image (t) { let e = new Image; return e.src = await this.base64(t), e } async base64 (t) { t = this._normalizeOptions(t, Kv.defaultImageOptions); let { format: e, quality: s } = t, o = this.canvas(t); if (o.toBlob !== void 0) return new Promise((i, n) => { o.toBlob(a => { if (!a) { n(new Error("ICanvas.toBlob failed!")); return } let l = new FileReader; l.onload = () => i(l.result), l.onerror = n, l.readAsDataURL(a) }, mb[e], s) }); if (o.toDataURL !== void 0) return o.toDataURL(mb[e], s); if (o.convertToBlob !== void 0) { let i = await o.convertToBlob({ type: mb[e], quality: s }); return new Promise((n, a) => { let l = new FileReader; l.onload = () => n(l.result), l.onerror = a, l.readAsDataURL(i) }) } throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented") } canvas (t) { t = this._normalizeOptions(t); let e = t.target, s = this._renderer; if (e instanceof E) return s.texture.generateCanvas(e); let o = s.textureGenerator.generateTexture(t), i = s.texture.generateCanvas(o); return o.destroy(), i } pixels (t) { t = this._normalizeOptions(t); let e = t.target, s = this._renderer, o = e instanceof E ? e : s.textureGenerator.generateTexture(t), i = s.texture.getPixels(o); return e instanceof N && o.destroy(), i } texture (t) { return t = this._normalizeOptions(t), t.target instanceof E ? t.target : this._renderer.textureGenerator.generateTexture(t) } download (t) { t = this._normalizeOptions(t); let e = this.canvas(t), s = document.createElement("a"); s.download = t.filename ?? "image.png", s.href = e.toDataURL("image/png"), document.body.appendChild(s), s.click(), document.body.removeChild(s) } log (t) { let e = t.width ?? 200; t = this._normalizeOptions(t); let s = this.canvas(t), o = s.toDataURL(); console.log(`[Pixi Texture] ${s.width}px ${s.height}px`); let i = ["font-size: 1px;", `padding: ${e}px 300px;`, `background: url(${o}) no-repeat;`, "background-size: contain;"].join(" "); console.log("%c ", i) } destroy () { this._renderer = null } }, "_ExtractSystem"); xb.extension = { type: [x.WebGLSystem, x.WebGPUSystem], name: "extract" }; xb.defaultImageOptions = { format: "png", quality: 1 }; Bh = xb }); var zo, mx = m(() => { Lt(); rt(); zo = class extends E { static create (t) { return new E({ source: new J(t) }) } resize (t, e, s) { return this.source.resize(t, e, s), this } }; c(zo, "RenderTexture") }); var TT, ET, PT, Hs, xx = m(() => { $t(); S(); ot(); Gt(); te(); ca(); It(); mx(); TT = new H, ET = new it, PT = [0, 0, 0, 0], Hs = class { constructor(t) { this._renderer = t } generateTexture (t) { t instanceof N && (t = { target: t, frame: void 0, textureSourceOptions: {}, resolution: void 0 }); let e = t.resolution || this._renderer.resolution, s = t.antialias || this._renderer.view.antialias, o = t.target, i = t.clearColor; i ? i = Array.isArray(i) && i.length === 4 ? i : j.shared.setValue(i).toArray() : i = PT; let n = t.frame?.copyTo(TT) || Dr(o, ET).rectangle; n.width = Math.max(n.width, 1 / e) | 0, n.height = Math.max(n.height, 1 / e) | 0; let a = zo.create({ ...t.textureSourceOptions, width: n.width, height: n.height, resolution: e, antialias: s }), l = B.shared.translate(-n.x, -n.y); return this._renderer.render({ container: o, transform: l, target: a, clearColor: i }), a } destroy () { this._renderer = null } }; c(Hs, "GenerateTextureSystem"); Hs.extension = { type: [x.WebGLSystem, x.WebGPUSystem], name: "textureGenerator" } }); var Ns, gx = m(() => { S(); ot(); ce(); Xi(); _r(); Re(); Ot(); Ns = class { constructor(t) { this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = t } reset () { this._stackIndex = 0; for (let t = 0; t < this._activeUniforms.length; t++)this._uniformsPool.push(this._activeUniforms[t]); for (let t = 0; t < this._activeBindGroups.length; t++)this._bindGroupPool.push(this._activeBindGroups[t]); this._activeUniforms.length = 0, this._activeBindGroups.length = 0 } start (t) { this.reset(), this.push(t) } bind ({ size: t, projectionMatrix: e, worldTransformMatrix: s, worldColor: o, offset: i }) { let n = this._renderer.renderTarget.renderTarget, a = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : { projectionData: n, worldTransformMatrix: new B, worldColor: 4294967295, offset: new V }, l = { projectionMatrix: e || this._renderer.renderTarget.projectionMatrix, resolution: t || n.size, worldTransformMatrix: s || a.worldTransformMatrix, worldColor: o || a.worldColor, offset: i || a.offset, bindGroup: null }, h = this._uniformsPool.pop() || this._createUniforms(); this._activeUniforms.push(h); let u = h.uniforms; u.uProjectionMatrix = l.projectionMatrix, u.uResolution = l.resolution, u.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix), u.uWorldTransformMatrix.tx -= l.offset.x, u.uWorldTransformMatrix.ty -= l.offset.y, tr(l.worldColor, u.uWorldColorAlpha, 0), h.update(); let d; this._renderer.renderPipes.uniformBatch ? d = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(h, !1) : (d = this._bindGroupPool.pop() || new Rt, this._activeBindGroups.push(d), d.setResource(h, 0)), l.bindGroup = d, this._currentGlobalUniformData = l } push (t) { this.bind(t), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData } pop () { this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === yt.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update() } get bindGroup () { return this._currentGlobalUniformData.bindGroup } get uniformGroup () { return this._currentGlobalUniformData.bindGroup.resources[0] } _createUniforms () { return new et({ uProjectionMatrix: { value: new B, type: "mat3x3<f32>" }, uWorldTransformMatrix: { value: new B, type: "mat3x3<f32>" }, uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }, { isStatic: !0 }) } destroy () { this._renderer = null } }; c(Ns, "GlobalUniformSystem"); Ns.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "globalUniforms" } }); function wh (r) {
          if (!qv) {
            if (k.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
              let t = [`%c  %c  %c  %c  %c PixiJS %c v${Ah} (${r}) http://www.pixijs.com/

`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"]; globalThis.console.log(...t)
            } else globalThis.console && globalThis.console.log(`PixiJS ${Ah} - ${r} - http://www.pixijs.com/`); qv = !0
          }
        } var qv, Ah, _x = m(() => { ft(); qv = !1, Ah = "8.1.1"; c(wh, "sayHello") }); var Ur, bx = m(() => { S(); _x(); Re(); Ur = class { constructor(t) { this._renderer = t } init (t) { if (t.hello) { let e = this._renderer.name; this._renderer.type === yt.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`), wh(e) } } }; c(Ur, "HelloSystem"); Ur.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "hello", priority: -2 }; Ur.defaultOptions = { hello: !1 } }); var gb, Ka, yx = m(() => { S(); gb = c(class Zv { constructor(t) { this._renderer = t, this.count = 0, this.checkCount = 0 } init (t) { t = { ...Zv.defaultOptions, ...t }, this.checkCountMax = t.textureGCCheckCountMax, this.maxIdle = t.textureGCAMaxIdle, this.active = t.textureGCActive } postrender () { this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run()))) } run () { let t = this._renderer.texture.managedTextures; for (let e = 0; e < t.length; e++) { let s = t[e]; s.autoGarbageCollect && s.resource && s._touched > -1 && this.count - s._touched > this.maxIdle && (s._touched = -1, s.unload()) } } destroy () { this._renderer = null } }, "_TextureGCSystem"); gb.extension = { type: [x.WebGLSystem, x.WebGPUSystem], name: "textureGC" }; gb.defaultOptions = { textureGCActive: !0, textureGCAMaxIdle: 60 * 60, textureGCCheckCountMax: 600 }; Ka = gb; I.add(Ka) }); var Qv, Vo, Rh = m(() => { Wt(); Lt(); rt(); Qv = c(class Jv { constructor(t = {}) { if (this.uid = Z("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, t = { ...Jv.defaultOptions, ...t }, this.stencil = t.stencil, this.depth = t.depth, this.isRoot = t.isRoot, typeof t.colorTextures == "number") { this._managedColorTextures = !0; for (let e = 0; e < t.colorTextures; e++)this.colorTextures.push(new J({ width: t.width, height: t.height, resolution: t.resolution, antialias: t.antialias })) } else { this.colorTextures = [...t.colorTextures.map(s => s.source)]; let e = this.colorTexture.source; this.resize(e.width, e.height, e._resolution) } this.colorTexture.source.on("resize", this.onSourceResize, this), (t.depthStencilTexture || this.stencil) && (t.depthStencilTexture instanceof E || t.depthStencilTexture instanceof J ? this.depthStencilTexture = t.depthStencilTexture.source : this.ensureDepthStencilTexture()) } get size () { let t = this._size; return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t } get width () { return this.colorTexture.source.width } get height () { return this.colorTexture.source.height } get pixelWidth () { return this.colorTexture.source.pixelWidth } get pixelHeight () { return this.colorTexture.source.pixelHeight } get resolution () { return this.colorTexture.source._resolution } get colorTexture () { return this.colorTextures[0] } onSourceResize (t) { this.resize(t.width, t.height, t._resolution, !0) } ensureDepthStencilTexture () { this.depthStencilTexture || (this.depthStencilTexture = new J({ width: this.width, height: this.height, resolution: this.resolution, format: "depth24plus-stencil8", autoGenerateMipmaps: !1, antialias: !1, mipLevelCount: 1 })) } resize (t, e, s = this.resolution, o = !1) { this.dirtyId++, this.colorTextures.forEach((i, n) => { o && n === 0 || i.source.resize(t, e, s) }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, s) } destroy () { this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach(t => { t.destroy() }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture) } }, "_RenderTarget"); Qv.defaultOptions = { width: 0, height: 0, resolution: 1, colorTextures: 1, stencil: !1, depth: !1, antialias: !1, isRoot: !1 }; Vo = Qv }); function Un (r, t) { if (!qa.has(r)) { let e = new E({ source: new se({ resource: r, ...t }) }), s = c(() => { qa.get(r) === e && qa.delete(r) }, "onDestroy"); e.once("destroy", s), e.source.once("destroy", s), qa.set(r, e) } return qa.get(r) } function _b (r) { return qa.has(r) } var qa, Mh = m(() => { Mi(); rt(); qa = new Map; c(Un, "getCanvasTexture"); c(_b, "hasCachedCanvasTexture") }); var bb, Gh, vx = m(() => { ft(); S(); Gt(); lt(); Rh(); Mh(); bb = c(class t0 { get resolution () { return this.texture.source._resolution } set resolution (t) { this.texture.source.resize(this.texture.source.width, this.texture.source.height, t) } init (t) { t = { ...t0.defaultOptions, ...t }, t.view && (w(G, "ViewSystem.view has been renamed to ViewSystem.canvas"), t.canvas = t.view), this.screen = new H(0, 0, t.width, t.height), this.canvas = t.canvas || k.get().createCanvas(), this.antialias = !!t.antialias, this.texture = Un(this.canvas, t), this.renderTarget = new Vo({ colorTextures: [this.texture], depth: !!t.depth, isRoot: !0 }), this.texture.source.transparent = t.backgroundAlpha < 1, this.multiView = !!t.multiView, this.autoDensity && (this.canvas.style.width = `${this.texture.width}px`, this.canvas.style.height = `${this.texture.height}px`), this.resolution = t.resolution } resize (t, e, s) { this.texture.source.resize(t, e, s), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height, this.autoDensity && (this.canvas.style.width = `${t}px`, this.canvas.style.height = `${e}px`) } destroy (t = !1) { (typeof t == "boolean" ? t : !!t?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas) } }, "_ViewSystem"); bb.extension = { type: [x.WebGLSystem, x.WebGPUSystem, x.CanvasSystem], name: "view", priority: 0 }; bb.defaultOptions = { width: 1280, height: 800, autoDensity: !1, antialias: !1 }; Gh = bb }); var Fn, In, Uh = m(() => { $m(); jm(); ex(); rx(); sx(); lx(); ux(); hx(); dx(); fx(); px(); xx(); gx(); bx(); yx(); vx(); Fn = [Ph, Ns, Ur, Gh, Us, Ka, Hs, Bh], In = [Ls, Is, Fs, Ms, Os, Ds, ks, Rs] }); var Ws, Sx = m(() => { S(); Ws = class { constructor(t) { this._hash = Object.create(null), this._renderer = t } contextChange (t) { this._gpu = t } getBindGroup (t, e, s) { return t._updateKey(), this._hash[t._key] || this._createBindGroup(t, e, s) } _createBindGroup (t, e, s) { let o = this._gpu.device, i = e.layout[s], n = [], a = this._renderer; for (let u in i) { let d = t.resources[u] ?? t.resources[i[u]], f; if (d._resourceType === "uniformGroup") { let p = d; a.ubo.updateUniformGroup(p); let g = p.buffer; f = { buffer: a.buffer.getGPUBuffer(g), offset: 0, size: g.descriptor.size } } else if (d._resourceType === "buffer") { let p = d; f = { buffer: a.buffer.getGPUBuffer(p), offset: 0, size: p.descriptor.size } } else if (d._resourceType === "bufferResource") { let p = d; f = { buffer: a.buffer.getGPUBuffer(p.buffer), offset: p.offset, size: p.size } } else if (d._resourceType === "textureSampler") { let p = d; f = a.texture.getGpuSampler(p) } else if (d._resourceType === "textureSource") { let p = d; f = a.texture.getGpuSource(p).createView({}) } n.push({ binding: i[u], resource: f }) } let l = a.shader.getProgramData(e).bindGroups[s], h = o.createBindGroup({ layout: l, entries: n }); return this._hash[t._key] = h, h } destroy () { for (let t of Object.keys(this._hash)) this._hash[t] = null; this._hash = null, this._renderer = null } }; c(Ws, "BindGroupSystem"); Ws.extension = { type: [x.WebGPUSystem], name: "bindGroup" } }); var Xs, Tx = m(() => { S(); Al(); Xs = class { constructor() { this._gpuBuffers = Object.create(null), this._managedBuffers = [] } contextChange (t) { this._gpu = t } getGPUBuffer (t) { return this._gpuBuffers[t.uid] || this.createGPUBuffer(t) } updateBuffer (t) { let e = this._gpuBuffers[t.uid] || this.createGPUBuffer(t), s = t.data; return t._updateID && s && (t._updateID = 0, this._gpu.device.queue.writeBuffer(e, 0, s.buffer, 0, (t._updateSize || s.byteLength) + 3 & -4)), e } destroyAll () { for (let t in this._gpuBuffers) this._gpuBuffers[t].destroy(); this._gpuBuffers = {} } createGPUBuffer (t) { this._gpuBuffers[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this)); let e = this._gpu.device.createBuffer(t.descriptor); return t._updateID = 0, t.data && (Ro(t.data.buffer, e.getMappedRange()), e.unmap()), this._gpuBuffers[t.uid] = e, this._managedBuffers.push(t), e } onBufferChange (t) { this._gpuBuffers[t.uid].destroy(), t._updateID = 0, this._gpuBuffers[t.uid] = this.createGPUBuffer(t) } onBufferDestroy (t) { this._managedBuffers.splice(this._managedBuffers.indexOf(t), 1), this._destroyBuffer(t) } destroy () { this._managedBuffers.forEach(t => this._destroyBuffer(t)), this._managedBuffers = null, this._gpuBuffers = null } _destroyBuffer (t) { this._gpuBuffers[t.uid].destroy(), t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[t.uid] = null } }; c(Xs, "GpuBufferSystem"); Xs.extension = { type: [x.WebGPUSystem], name: "buffer" } }); var zs, Ex = m(() => { S(); zs = class { constructor(t) { this._colorMaskCache = 15, this._renderer = t } setMask (t) { this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.pipeline.setColorMask(t)) } destroy () { this._renderer = null, this._colorMaskCache = null } }; c(zs, "GpuColorMaskSystem"); zs.extension = { type: [x.WebGPUSystem], name: "colorMask" } }); var Fr, Px = m(() => { S(); Fr = class { constructor(t) { this._renderer = t } async init (t) { return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(t).then(e => { this.gpu = e, this._renderer.runners.contextChange.emit(this.gpu) }), this._initPromise) } contextChange (t) { this._renderer.gpu = t } async _createDeviceAndAdaptor (t) { let e = await navigator.gpu.requestAdapter({ powerPreference: t.powerPreference, forceFallbackAdapter: t.forceFallbackAdapter }), s = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(i => e.features.has(i)), o = await e.requestDevice({ requiredFeatures: s }); return { adapter: e, device: o } } destroy () { this.gpu = null, this._renderer = null } }; c(Fr, "GpuDeviceSystem"); Fr.extension = { type: [x.WebGPUSystem], name: "device" }; Fr.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 } }); var Vs, Cx = m(() => { S(); Vs = class { constructor(t) { this._boundBindGroup = Object.create(null), this._boundVertexBuffer = Object.create(null), this._renderer = t } renderStart () { this.commandFinished = new Promise(t => { this._resolveCommandFinished = t }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder() } beginRenderPass (t) { this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor) } endRenderPass () { this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null } setViewport (t) { this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1) } setPipelineFromGeometryProgramAndState (t, e, s, o) { let i = this._renderer.pipeline.getPipeline(t, e, s, o); this.setPipeline(i) } setPipeline (t) { this._boundPipeline !== t && (this._boundPipeline = t, this.renderPassEncoder.setPipeline(t)) } _setVertexBuffer (t, e) { this._boundVertexBuffer[t] !== e && (this._boundVertexBuffer[t] = e, this.renderPassEncoder.setVertexBuffer(t, this._renderer.buffer.updateBuffer(e))) } _setIndexBuffer (t) { if (this._boundIndexBuffer === t) return; this._boundIndexBuffer = t; let e = t.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32"; this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(t), e) } resetBindGroup (t) { this._boundBindGroup[t] = null } setBindGroup (t, e, s) { if (this._boundBindGroup[t] === e) return; this._boundBindGroup[t] = e, e._touch(this._renderer.textureGC.count); let o = this._renderer.bindGroup.getBindGroup(e, s, t); this.renderPassEncoder.setBindGroup(t, o) } setGeometry (t) { for (let e in t.attributes) { let s = t.attributes[e]; this._setVertexBuffer(s.location, s.buffer) } t.indexBuffer && this._setIndexBuffer(t.indexBuffer) } _setShaderBindGroups (t, e) { for (let s in t.groups) { let o = t.groups[s]; e || this._syncBindGroup(o), this.setBindGroup(s, o, t.gpuProgram) } } _syncBindGroup (t) { for (let e in t.resources) { let s = t.resources[e]; s.isUniformGroup && this._renderer.ubo.updateUniformGroup(s) } } draw (t) { let { geometry: e, shader: s, state: o, topology: i, size: n, start: a, instanceCount: l, skipSync: h } = t; this.setPipelineFromGeometryProgramAndState(e, s.gpuProgram, o, i), this.setGeometry(e), this._setShaderBindGroups(s, h), e.indexBuffer ? this.renderPassEncoder.drawIndexed(n || e.indexBuffer.data.length, l || e.instanceCount, a || 0) : this.renderPassEncoder.draw(n || e.getSize(), l || e.instanceCount, a || 0) } finishRenderPass () { this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null) } postrender () { this.finishRenderPass(), this._gpu.device.queue.submit([this.commandEncoder.finish()]), this._resolveCommandFinished(), this.commandEncoder = null } restoreRenderPass () { let t = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]); this.renderPassEncoder = this.commandEncoder.beginRenderPass(t); let e = this._boundPipeline, s = { ...this._boundVertexBuffer }, o = this._boundIndexBuffer, i = { ...this._boundBindGroup }; this._clearCache(); let n = this._renderer.renderTarget.viewport; this.renderPassEncoder.setViewport(n.x, n.y, n.width, n.height, 0, 1), this.setPipeline(e); for (let a in s) this._setVertexBuffer(a, s[a]); for (let a in i) this.setBindGroup(a, i[a], null); this._setIndexBuffer(o) } _clearCache () { for (let t = 0; t < 16; t++)this._boundBindGroup[t] = null, this._boundVertexBuffer[t] = null; this._boundIndexBuffer = null, this._boundPipeline = null } destroy () { this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null } contextChange (t) { this._gpu = t } }; c(Vs, "GpuEncoderSystem"); Vs.extension = { type: [x.WebGPUSystem], name: "encoder", priority: 1 } }); var Ys, Bx = m(() => { S(); Jr(); Ys = class { constructor(t) { this._renderTargetStencilState = Object.create(null), this._renderer = t, t.renderTarget.onRenderTargetChange.add(this) } onRenderTargetChange (t) { let e = this._renderTargetStencilState[t.uid]; e || (e = this._renderTargetStencilState[t.uid] = { stencilMode: xt.DISABLED, stencilReference: 0 }), this._activeRenderTarget = t, this.setStencilMode(e.stencilMode, e.stencilReference) } setStencilMode (t, e) { let s = this._renderTargetStencilState[this._activeRenderTarget.uid]; s.stencilMode = t, s.stencilReference = e; let o = this._renderer; o.pipeline.setStencilMode(t), o.encoder.renderPassEncoder.setStencilReference(e) } destroy () { this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null } }; c(Ys, "GpuStencilSystem"); Ys.extension = { type: [x.WebGPUSystem], name: "stencil" } }); var Ir, Fh = m(() => { ph(); xr(); qe(); Ir = class { constructor(t) { this._syncFunctionHash = Object.create(null), this._adaptor = t, this._systemCheck() } _systemCheck () { if (!Rn()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } ensureUniformGroup (t) { let e = this.getUniformGroupData(t); t.buffer || (t.buffer = new _t({ data: new Float32Array(e.layout.size / 4), usage: K.UNIFORM | K.COPY_DST })) } getUniformGroupData (t) { return this._syncFunctionHash[t._signature] || this._initUniformGroup(t) } _initUniformGroup (t) { let e = t._signature, s = this._syncFunctionHash[e]; if (!s) { let o = Object.keys(t.uniformStructures).map(a => t.uniformStructures[a]), i = this._adaptor.createUboElements(o), n = this._generateUboSync(i.uboElements); s = this._syncFunctionHash[e] = { layout: i, syncFunction: n } } return this._syncFunctionHash[e] } _generateUboSync (t) { return this._adaptor.generateUboSync(t) } syncUniformGroup (t, e, s) { let o = this.getUniformGroupData(t); return t.buffer || (t.buffer = new _t({ data: new Float32Array(o.layout.size / 4), usage: K.UNIFORM | K.COPY_DST })), e || (e = t.buffer.data), s || (s = 0), o.syncFunction(t.uniforms, e, s), !0 } updateUniformGroup (t) { if (t.isStatic && !t._dirtyId) return !1; t._dirtyId = 0; let e = this.syncUniformGroup(t); return t.buffer.update(), e } destroy () { this._syncFunctionHash = null } }; c(Ir, "UboSystem") }); function Ih (r) { let t = r.map(s => ({ data: s, offset: 0, size: 0 })), e = 0; for (let s = 0; s < t.length; s++) { let o = t[s], i = Yo[o.data.type].size, n = Yo[o.data.type].align; if (!Yo[o.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${o.data.type}`); o.data.size > 1 && (i = Math.max(i, n) * o.data.size), e = Math.ceil(e / n) * n, o.size = i, o.offset = e, e += i } return e = Math.ceil(e / 16) * 16, { uboElements: t, size: e } } var Yo, Oh = m(() => { "use strict"; Yo = { i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, f16: { align: 2, size: 2 }, "vec2<i32>": { align: 8, size: 8 }, "vec2<u32>": { align: 8, size: 8 }, "vec2<f32>": { align: 8, size: 8 }, "vec2<f16>": { align: 4, size: 4 }, "vec3<i32>": { align: 16, size: 12 }, "vec3<u32>": { align: 16, size: 12 }, "vec3<f32>": { align: 16, size: 12 }, "vec3<f16>": { align: 8, size: 6 }, "vec4<i32>": { align: 16, size: 16 }, "vec4<u32>": { align: 16, size: 16 }, "vec4<f32>": { align: 16, size: 16 }, "vec4<f16>": { align: 8, size: 8 }, "mat2x2<f32>": { align: 8, size: 16 }, "mat2x2<f16>": { align: 4, size: 8 }, "mat3x2<f32>": { align: 8, size: 24 }, "mat3x2<f16>": { align: 4, size: 12 }, "mat4x2<f32>": { align: 8, size: 32 }, "mat4x2<f16>": { align: 4, size: 16 }, "mat2x3<f32>": { align: 16, size: 32 }, "mat2x3<f16>": { align: 8, size: 16 }, "mat3x3<f32>": { align: 16, size: 48 }, "mat3x3<f16>": { align: 8, size: 24 }, "mat4x3<f32>": { align: 16, size: 64 }, "mat4x3<f16>": { align: 8, size: 32 }, "mat2x4<f32>": { align: 16, size: 32 }, "mat2x4<f16>": { align: 8, size: 16 }, "mat3x4<f32>": { align: 16, size: 48 }, "mat3x4<f16>": { align: 8, size: 24 }, "mat4x4<f32>": { align: 16, size: 64 }, "mat4x4<f16>": { align: 8, size: 32 } }; c(Ih, "createUboElementsWGSL") }); var He, kh = m(() => {
          "use strict"; He = [{
            type: "mat3x3<f32>", test: r => r.value.a !== void 0, ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `, uniform: ` 
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `}, {
            type: "vec4<f32>", test: r => r.type === "vec4<f32>" && r.size === 1 && r.value.width !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `}, {
            type: "vec2<f32>", test: r => r.type === "vec2<f32>" && r.size === 1 && r.value.x !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `}, {
            type: "vec4<f32>", test: r => r.type === "vec4<f32>" && r.size === 1 && r.value.red !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `}, {
            type: "vec3<f32>", test: r => r.type === "vec3<f32>" && r.size === 1 && r.value.red !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `}]
        }); function On (r, t, e, s) {
          let o = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `], i = 0; for (let a = 0; a < r.length; a++) {
            let l = r[a], h = l.data.name, u = !1, d = 0; for (let f = 0; f < He.length; f++)if (He[f].test(l.data)) { d = l.offset / 4, o.push(`name = "${h}";`, `offset += ${d - i};`, He[f][t] || He[f].ubo), u = !0; break } if (!u) if (l.data.size > 1) d = l.offset / 4, o.push(e(l, d - i)); else {
              let f = s[l.data.type]; d = l.offset / 4, o.push(`
                    v = uv.${h};
                    offset += ${d - i};
                    ${f};
                `)
            } i = d
          } let n = o.join(`
`); return new Function("uv", "data", "offset", n)
        } var Dh = m(() => { kh(); c(On, "createUboSyncFunction") }); function Za (r, t) {
          return `
        for (let i = 0; i < ${r * t}; i++) {
            data[offset + (((i / ${r})|0) * 4) + (i % ${r})] = v[i];
        }
    `} var Qa, Lh, Hh = m(() => {
            "use strict"; c(Za, "loopMatrix"); Qa = {
              f32: `
        data[offset] = v;`, i32: `
        data[offset] = v;`, "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`, "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`, "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`, "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`, "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`, "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`, "mat3x2<f32>": Za(3, 2), "mat4x2<f32>": Za(4, 2), "mat2x3<f32>": Za(2, 3), "mat4x3<f32>": Za(4, 3), "mat2x4<f32>": Za(2, 4), "mat3x4<f32>": Za(3, 4)
            }, Lh = {
              ...Qa, "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `}
          }); function Nh (r, t) {
            let { size: e, align: s } = Yo[r.data.type], o = (s - e) / 4; return `
         v = uv.${r.data.name};
         ${t !== 0 ? `offset += ${t};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${r.data.size * (e / 4)}; i++)
         {
             for(var j = 0; j < ${e / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${o !== 0 ? `arrayOffset += ${o};` : ""}
         }
     `} var Ax = m(() => { Oh(); c(Nh, "generateArraySyncWGSL") }); function Wh (r) { return On(r, "uboWgsl", Nh, Lh) } var wx = m(() => { Dh(); Hh(); Ax(); c(Wh, "createUboSyncFunctionWGSL") }); var $s, Rx = m(() => { S(); Fh(); Oh(); wx(); $s = class extends Ir { constructor() { super({ createUboElements: Ih, generateUboSync: Wh }) } }; c($s, "GpuUboSystem"); $s.extension = { type: [x.WebGPUSystem], name: "ubo" } }); var e0, Ne, Ja = m(() => { e0 = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); Wt(); Ne = class extends e0.default { constructor({ buffer: t, offset: e, size: s }) { super(), this.uid = Z("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = Z("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = t, this.offset = e | 0, this.size = s, this.buffer.on("change", this.onBufferChange, this) } onBufferChange () { this._resourceId = Z("resource"), this.emit("change", this) } destroy (t = !1) { this.destroyed = !0, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null } }; c(Ne, "BufferResource") }); var $o, Mx = m(() => { "use strict"; $o = class { constructor({ minUniformOffsetAlignment: t }) { this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = t, this.data = new Float32Array(65535) } clear () { this.byteIndex = 0 } addEmptyGroup (t) { if (t > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${t * 4}`); let e = this.byteIndex, s = e + t * 4; if (s = Math.ceil(s / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, s > this.data.length * 4) throw new Error("UniformBufferBatch: ubo batch got too big"); return this.byteIndex = s, e } addGroup (t) { let e = this.addEmptyGroup(t.length); for (let s = 0; s < t.length; s++)this.data[e / 4 + s] = t[s]; return e } destroy () { this._buffer.destroy(), this._buffer = null, this.data = null } }; c($o, "UboBatch") }); var jo, js, Gx = m(() => { S(); xr(); Ja(); qe(); Mx(); _r(); jo = 128, js = class { constructor(t) { this._bindGroupHash = Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = t, this._batchBuffer = new $o({ minUniformOffsetAlignment: jo }); let e = 256 / jo; for (let s = 0; s < e; s++) { let o = K.UNIFORM | K.COPY_DST; s === 0 && (o |= K.COPY_SRC), this._buffers.push(new _t({ data: this._batchBuffer.data, usage: o })) } } renderEnd () { this._uploadBindGroups(), this._resetBindGroups() } _resetBindGroups () { for (let t in this._bindGroupHash) this._bindGroupHash[t] = null; this._batchBuffer.clear() } getUniformBindGroup (t, e) { if (!e && this._bindGroupHash[t.uid]) return this._bindGroupHash[t.uid]; this._renderer.ubo.ensureUniformGroup(t); let s = t.buffer.data, o = this._batchBuffer.addEmptyGroup(s.length); return this._renderer.ubo.syncUniformGroup(t, this._batchBuffer.data, o / 4), this._bindGroupHash[t.uid] = this._getBindGroup(o / jo), this._bindGroupHash[t.uid] } getUboResource (t) { this._renderer.ubo.updateUniformGroup(t); let e = t.buffer.data, s = this._batchBuffer.addGroup(e); return this._getBufferResource(s / jo) } getArrayBindGroup (t) { let e = this._batchBuffer.addGroup(t); return this._getBindGroup(e / jo) } getArrayBufferResource (t) { let s = this._batchBuffer.addGroup(t) / jo; return this._getBufferResource(s) } _getBufferResource (t) { if (!this._bufferResources[t]) { let e = this._buffers[t % 2]; this._bufferResources[t] = new Ne({ buffer: e, offset: (t / 2 | 0) * 256, size: jo }) } return this._bufferResources[t] } _getBindGroup (t) { if (!this._bindGroups[t]) { let e = new Rt({ 0: this._getBufferResource(t) }); this._bindGroups[t] = e } return this._bindGroups[t] } _uploadBindGroups () { let t = this._renderer.buffer, e = this._buffers[0]; e.update(this._batchBuffer.byteIndex), t.updateBuffer(e); let s = this._renderer.gpu.device.createCommandEncoder(); for (let o = 1; o < this._buffers.length; o++) { let i = this._buffers[o]; s.copyBufferToBuffer(t.getGPUBuffer(e), jo, t.getGPUBuffer(i), 0, this._batchBuffer.byteIndex) } this._renderer.gpu.device.queue.submit([s.finish()]) } destroy () { for (let t = 0; t < this._bindGroups.length; t++)this._bindGroups[t].destroy(); this._bindGroups = null, this._bindGroupHash = null; for (let t = 0; t < this._buffers.length; t++)this._buffers[t].destroy(); this._buffers = null; for (let t = 0; t < this._bufferResources.length; t++)this._bufferResources[t].destroy(); this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null } }; c(js, "GpuUniformBatchPipe"); js.extension = { type: [x.WebGPUPipes], name: "uniformBatch" } }); function kn (r, t) { for (let e in r.attributes) { let s = r.attributes[e], o = t[e]; o ? (s.location ?? (s.location = o.location), s.format ?? (s.format = o.format), s.offset ?? (s.offset = o.offset), s.instance ?? (s.instance = o.instance)) : U(`Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`) } CT(r) } function CT (r) { let { buffers: t, attributes: e } = r, s = {}, o = {}; for (let i in t) { let n = t[i]; s[n.uid] = 0, o[n.uid] = 0 } for (let i in e) { let n = e[i]; s[n.buffer.uid] += De(n.format).stride } for (let i in e) { let n = e[i]; n.stride ?? (n.stride = s[n.buffer.uid]), n.start ?? (n.start = o[n.buffer.uid]), o[n.buffer.uid] += De(n.format).stride } } var Xh = m(() => { ut(); sn(); c(kn, "ensureAttributes"); c(CT, "ensureStartAndStride") }); var We, zh = m(() => { Jr(); We = []; We[xt.NONE] = void 0; We[xt.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }; We[xt.RENDERING_MASK_ADD] = { stencilFront: { compare: "equal", passOp: "increment-clamp" }, stencilBack: { compare: "equal", passOp: "increment-clamp" } }; We[xt.RENDERING_MASK_REMOVE] = { stencilFront: { compare: "equal", passOp: "decrement-clamp" }, stencilBack: { compare: "equal", passOp: "decrement-clamp" } }; We[xt.MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "equal", passOp: "keep" }, stencilBack: { compare: "equal", passOp: "keep" } } }); function AT (r, t, e, s, o) { return r << 24 | t << 16 | e << 10 | s << 5 | o } function wT (r, t, e, s) { return e << 6 | r << 3 | s << 1 | t } var BT, Ks, Ux = m(() => { S(); Xh(); Jr(); zi(); zh(); BT = { "point-list": 0, "line-list": 1, "line-strip": 2, "triangle-list": 3, "triangle-strip": 4 }; c(AT, "getGraphicsStateKey"); c(wT, "getGlobalStateKey"); Ks = class { constructor(t) { this._moduleCache = Object.create(null), this._bufferLayoutsCache = Object.create(null), this._pipeCache = Object.create(null), this._pipeStateCaches = Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = t } contextChange (t) { this._gpu = t, this.setStencilMode(xt.DISABLED), this._updatePipeHash() } setMultisampleCount (t) { this._multisampleCount !== t && (this._multisampleCount = t, this._updatePipeHash()) } setRenderTarget (t) { this._multisampleCount = t.msaaSamples, this._depthStencilAttachment = t.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash() } setColorMask (t) { this._colorMask !== t && (this._colorMask = t, this._updatePipeHash()) } setStencilMode (t) { this._stencilMode !== t && (this._stencilMode = t, this._stencilState = We[t], this._updatePipeHash()) } setPipeline (t, e, s, o) { let i = this.getPipeline(t, e, s); o.setPipeline(i) } getPipeline (t, e, s, o) { t._layoutKey || (kn(t, e.attributeData), this._generateBufferKey(t)), o = o || t.topology; let i = AT(t._layoutKey, e._layoutKey, s.data, s._blendModeId, BT[o]); return this._pipeCache[i] ? this._pipeCache[i] : (this._pipeCache[i] = this._createPipeline(t, e, s, o), this._pipeCache[i]) } _createPipeline (t, e, s, o) { let i = this._gpu.device, n = this._createVertexBufferLayouts(t), a = this._renderer.state.getColorTargets(s); a[0].writeMask = this._stencilMode === xt.RENDERING_MASK_ADD ? 0 : this._colorMask; let l = this._renderer.shader.getProgramData(e).pipeline, h = { vertex: { module: this._getModule(e.vertex.source), entryPoint: e.vertex.entryPoint, buffers: n }, fragment: { module: this._getModule(e.fragment.source), entryPoint: e.fragment.entryPoint, targets: a }, primitive: { topology: o, cullMode: s.cullMode }, layout: l, multisample: { count: this._multisampleCount }, label: "PIXI Pipeline" }; return this._depthStencilAttachment && (h.depthStencil = { ...this._stencilState, format: "depth24plus-stencil8", depthWriteEnabled: s.depthTest, depthCompare: s.depthTest ? "less" : "always" }), i.createRenderPipeline(h) } _getModule (t) { return this._moduleCache[t] || this._createModule(t) } _createModule (t) { let e = this._gpu.device; return this._moduleCache[t] = e.createShaderModule({ code: t }), this._moduleCache[t] } _generateBufferKey (t) { let e = [], s = 0, o = Object.keys(t.attributes).sort(); for (let n = 0; n < o.length; n++) { let a = t.attributes[o[n]]; e[s++] = a.location, e[s++] = a.offset, e[s++] = a.format, e[s++] = a.stride } let i = e.join(""); return t._layoutKey = er(i, "geometry"), t._layoutKey } _createVertexBufferLayouts (t) { if (this._bufferLayoutsCache[t._layoutKey]) return this._bufferLayoutsCache[t._layoutKey]; let e = []; return t.buffers.forEach(s => { let o = { arrayStride: 0, stepMode: "vertex", attributes: [] }, i = o.attributes; for (let n in t.attributes) { let a = t.attributes[n]; a.buffer === s && (o.arrayStride = a.stride, o.stepMode = a.instance ? "instance" : "vertex", i.push({ shaderLocation: a.location, offset: a.offset, format: a.format })) } i.length && e.push(o) }), this._bufferLayoutsCache[t._layoutKey] = e, e } _updatePipeHash () { let t = wT(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment); this._pipeStateCaches[t] || (this._pipeStateCaches[t] = Object.create(null)), this._pipeCache = this._pipeStateCaches[t] } destroy () { this._renderer = null, this._bufferLayoutsCache = null } }; c(Ks, "PipelineSystem"); Ks.extension = { type: [x.WebGPUSystem], name: "pipeline" } }); function Vh (r, t, e, s, o, i) { let n = i ? 1 : -1; return r.identity(), r.a = 1 / s * 2, r.d = n * (1 / o * 2), r.tx = -1 - t * r.a, r.ty = -n - e * r.d, r } var Fx = m(() => { "use strict"; c(Vh, "calculateProjection") }); function Yh (r) { let t = r.colorTexture.source.resource; return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t) } var Ix = m(() => { "use strict"; c(Yh, "isRenderingToScreen") }); var Or, $h = m(() => { ot(); Gt(); Wo(); Fx(); mh(); Mi(); Lt(); rt(); Mh(); Ix(); Rh(); Or = class { constructor(t) { this.rootViewPort = new H, this.viewport = new H, this.onRenderTargetChange = new Gr("onRenderTargetChange"), this.projectionMatrix = new B, this.defaultClearColor = [0, 0, 0, 0], this._renderSurfaceToRenderTargetHash = new Map, this._gpuRenderTargetHash = Object.create(null), this._renderTargetStack = [], this._renderer = t } finishRenderPass () { this.adaptor.finishRenderPass(this.renderTarget) } renderStart ({ target: t, clear: e, clearColor: s, frame: o }) { this._renderTargetStack.length = 0, this.push(t, e, s, o), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = Yh(this.rootRenderTarget) } bind (t, e = !0, s, o) { let i = this.getRenderTarget(t), n = this.renderTarget !== i; this.renderTarget = i, this.renderSurface = t; let a = this.getGpuRenderTarget(i); (i.pixelWidth !== a.width || i.pixelHeight !== a.height) && (this.adaptor.resizeGpuRenderTarget(i), a.width = i.pixelWidth, a.height = i.pixelHeight); let l = i.colorTexture, h = this.viewport, u = l.pixelWidth, d = l.pixelHeight; if (!o && t instanceof E && (o = t.frame), o) { let f = l._resolution; h.x = o.x * f + .5 | 0, h.y = o.y * f + .5 | 0, h.width = o.width * f + .5 | 0, h.height = o.height * f + .5 | 0 } else h.x = 0, h.y = 0, h.width = u, h.height = d; return Vh(this.projectionMatrix, 0, 0, h.width / l.resolution, h.height / l.resolution, !i.isRoot), this.adaptor.startRenderPass(i, e, s, h), n && this.onRenderTargetChange.emit(i), i } clear (t, e = Ut.ALL, s) { e && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(t || this.renderTarget, e, s, this.viewport)) } contextChange () { this._gpuRenderTargetHash = Object.create(null) } push (t, e = Ut.ALL, s, o) { let i = this.bind(t, e, s, o); return this._renderTargetStack.push({ renderTarget: i, frame: o }), i } pop () { this._renderTargetStack.pop(); let t = this._renderTargetStack[this._renderTargetStack.length - 1]; this.bind(t.renderTarget, !1, null, t.frame) } getRenderTarget (t) { return t.isTexture && (t = t.source), this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t) } copyToTexture (t, e, s, o, i) { s.x < 0 && (o.width += s.x, i.x -= s.x, s.x = 0), s.y < 0 && (o.height += s.y, i.y -= s.y, s.y = 0); let { pixelWidth: n, pixelHeight: a } = t; return o.width = Math.min(o.width, n - s.x), o.height = Math.min(o.height, a - s.y), this.adaptor.copyToTexture(t, e, s, o, i) } ensureDepthStencil () { this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport)) } destroy () { this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((t, e) => { t !== e && t.destroy() }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = Object.create(null) } _initRenderTarget (t) { let e = null; return se.test(t) && (t = Un(t)), t instanceof Vo ? e = t : t instanceof J && (e = new Vo({ colorTextures: [t] }), se.test(t.source.resource) && (e.isRoot = !0), t.once("destroy", () => { e.destroy(); let s = this._gpuRenderTargetHash[e.uid]; s && (this._gpuRenderTargetHash[e.uid] = null, this.adaptor.destroyGpuRenderTarget(s)) })), this._renderSurfaceToRenderTargetHash.set(t, e), e } getGpuRenderTarget (t) { return this._gpuRenderTargetHash[t.uid] || (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t)) } }; c(Or, "RenderTargetSystem") }); var Ko, Ox = m(() => { "use strict"; Ko = class { constructor() { this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1 } }; c(Ko, "GpuRenderTarget") }); var qo, kx = m(() => { Wo(); Mi(); Lt(); Ox(); qo = class { init (t, e) { this._renderer = t, this._renderTargetSystem = e } copyToTexture (t, e, s, o, i) { let n = this._renderer, a = this._getGpuColorTexture(t), l = n.texture.getGpuSource(e.source); return n.encoder.commandEncoder.copyTextureToTexture({ texture: a, origin: s }, { texture: l, origin: i }, o), e } startRenderPass (t, e = !0, s, o) { let n = this._renderTargetSystem.getGpuRenderTarget(t), a = this.getDescriptor(t, e, s); n.descriptor = a, this._renderer.pipeline.setRenderTarget(n), this._renderer.encoder.beginRenderPass(n), this._renderer.encoder.setViewport(o) } finishRenderPass () { this._renderer.encoder.endRenderPass() } _getGpuColorTexture (t) { let e = this._renderTargetSystem.getGpuRenderTarget(t); return e.contexts[0] ? e.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(t.colorTextures[0].source) } getDescriptor (t, e, s) { typeof e == "boolean" && (e = e ? Ut.ALL : Ut.NONE); let o = this._renderTargetSystem, i = o.getGpuRenderTarget(t), n = t.colorTextures.map((h, u) => { let d = i.contexts[u], f, p; d ? f = d.getCurrentTexture().createView() : f = this._renderer.texture.getGpuSource(h).createView({ mipLevelCount: 1 }), i.msaaTextures[u] && (p = f, f = this._renderer.texture.getTextureView(i.msaaTextures[u])); let g = e & Ut.COLOR ? "clear" : "load"; return s ?? (s = o.defaultClearColor), { view: f, resolveTarget: p, clearValue: s, storeOp: "store", loadOp: g } }), a; if ((t.stencil || t.depth) && !t.depthStencilTexture && (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = i.msaa ? 4 : 1), t.depthStencilTexture) { let h = e & Ut.STENCIL ? "clear" : "load", u = e & Ut.DEPTH ? "clear" : "load"; a = { view: this._renderer.texture.getGpuSource(t.depthStencilTexture.source).createView(), stencilStoreOp: "store", stencilLoadOp: h, depthClearValue: 1, depthLoadOp: u, depthStoreOp: "store" } } return { colorAttachments: n, depthStencilAttachment: a } } clear (t, e = !0, s, o) { if (!e) return; let { gpu: i, encoder: n } = this._renderer, a = i.device; if (n.commandEncoder === null) { let h = a.createCommandEncoder(), u = this.getDescriptor(t, e, s), d = h.beginRenderPass(u); d.setViewport(o.x, o.y, o.width, o.height, 0, 1), d.end(); let f = h.finish(); a.queue.submit([f]) } else this.startRenderPass(t, e, s, o) } initGpuRenderTarget (t) { t.isRoot = !0; let e = new Ko; return t.colorTextures.forEach((s, o) => { if (se.test(s.resource)) { let i = s.resource.getContext("webgpu"), n = s.transparent ? "premultiplied" : "opaque"; try { i.configure({ device: this._renderer.gpu.device, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC, format: "bgra8unorm", alphaMode: n }) } catch (a) { console.error(a) } e.contexts[o] = i } if (e.msaa = s.source.antialias, s.source.antialias) { let i = new J({ width: 0, height: 0, sampleCount: 4 }); e.msaaTextures[o] = i } }), e.msaa && (e.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), e } destroyGpuRenderTarget (t) { t.contexts.forEach(e => { e.unconfigure() }), t.msaaTextures.forEach(e => { e.destroy() }), t.msaaTextures.length = 0, t.contexts.length = 0 } ensureDepthStencilTexture (t) { let e = this._renderTargetSystem.getGpuRenderTarget(t); t.depthStencilTexture && e.msaa && (t.depthStencilTexture.source.sampleCount = 4) } resizeGpuRenderTarget (t) { let e = this._renderTargetSystem.getGpuRenderTarget(t); e.width = t.width, e.height = t.height, e.msaa && t.colorTextures.forEach((s, o) => { e.msaaTextures[o]?.resize(s.source.width, s.source.height, s.source._resolution) }) } }; c(qo, "GpuRenderTargetAdaptor") }); var qs, Dx = m(() => { S(); $h(); kx(); qs = class extends Or { constructor(t) { super(t), this.adaptor = new qo, this.adaptor.init(t, this) } }; c(qs, "GpuRenderTargetSystem"); qs.extension = { type: [x.WebGPUSystem], name: "renderTarget" } }); var Zs, Lx = m(() => { S(); Zs = class { constructor() { this._gpuProgramData = Object.create(null) } contextChange (t) { this._gpu = t } getProgramData (t) { return this._gpuProgramData[t._layoutKey] || this._createGPUProgramData(t) } _createGPUProgramData (t) { let e = this._gpu.device, s = t.gpuLayout.map(i => e.createBindGroupLayout({ entries: i })), o = { bindGroupLayouts: s }; return this._gpuProgramData[t._layoutKey] = { bindGroups: s, pipeline: e.createPipelineLayout(o) }, this._gpuProgramData[t._layoutKey] } destroy () { this._gpu = null, this._gpuProgramData = null } }; c(Zs, "GpuShaderSystem"); Zs.extension = { type: [x.WebGPUSystem], name: "shader" } }); var ae, Hx = m(() => { "use strict"; ae = {}; ae.normal = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" } }; ae.add = { alpha: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one", operation: "add" } }; ae.multiply = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "dst", dstFactor: "one-minus-src-alpha", operation: "add" } }; ae.screen = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }; ae.overlay = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }; ae.none = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "zero", operation: "add" } }; ae["normal-npm"] = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" } }; ae["add-npm"] = { alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" } }; ae["screen-npm"] = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src", operation: "add" } }; ae.erase = { alpha: { srcFactor: "zero", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "one-minus-src", operation: "add" } } }); var Qs, Nx = m(() => { S(); Se(); Hx(); Qs = class { constructor() { this.defaultState = new Pt, this.defaultState.blend = !0 } contextChange (t) { this.gpu = t } getColorTargets (t) { return [{ format: "bgra8unorm", writeMask: 0, blend: ae[t.blendMode] || ae.normal }] } destroy () { this.gpu = null } }; c(Qs, "GpuStateSystem"); Qs.extension = { type: [x.WebGPUSystem], name: "state" } }); var jh, Wx = m(() => { "use strict"; jh = { type: "image", upload (r, t, e) { let s = r.resource, o = (r.pixelWidth | 0) * (r.pixelHeight | 0), i = s.byteLength / o; e.device.queue.writeTexture({ texture: t }, s, { offset: 0, rowsPerImage: r.pixelHeight, bytesPerRow: r.pixelHeight * i }, { width: r.pixelWidth, height: r.pixelHeight, depthOrArrayLayers: 1 }) } } }); var tc, RT, Kh, Xx = m(() => { "use strict"; tc = { "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 } }, RT = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, Kh = { type: "compressed", upload (r, t, e) { let s = r.pixelWidth, o = r.pixelHeight, i = tc[r.format] || RT; for (let n = 0; n < r.resource.length; n++) { let a = r.resource[n], l = Math.ceil(s / i.blockWidth) * i.blockBytes; e.device.queue.writeTexture({ texture: t, mipLevel: n }, a, { offset: 0, bytesPerRow: l }, { width: Math.ceil(s / i.blockWidth) * i.blockWidth, height: Math.ceil(o / i.blockHeight) * i.blockHeight, depthOrArrayLayers: 1 }), s = Math.max(s >> 1, 1), o = Math.max(o >> 1, 1) } } } }); var Dn, qh = m(() => { "use strict"; Dn = { type: "image", upload (r, t, e) { let s = r.resource; if (!s) return; let o = Math.min(t.width, r.resourceWidth || r.pixelWidth), i = Math.min(t.height, r.resourceHeight || r.pixelHeight), n = r.alphaMode === "premultiply-alpha-on-upload"; e.device.queue.copyExternalImageToTexture({ source: s }, { texture: t, premultipliedAlpha: n }, { width: o, height: i }) } } }); var Zh, zx = m(() => { qh(); Zh = { type: "video", upload (r, t, e) { Dn.upload(r, t, e) } } }); var Zo, Vx = m(() => {
              "use strict"; Zo = class {
                constructor(t) { this.device = t, this.sampler = t.createSampler({ minFilter: "linear" }), this.pipelines = {} } _getMipmapPipeline (t) {
                  let e = this.pipelines[t]; return e || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
                    code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})), e = this.device.createRenderPipeline({ layout: "auto", vertex: { module: this.mipmapShaderModule, entryPoint: "vertexMain" }, fragment: { module: this.mipmapShaderModule, entryPoint: "fragmentMain", targets: [{ format: t }] } }), this.pipelines[t] = e), e
                } generateMipmap (t) { let e = this._getMipmapPipeline(t.format); if (t.dimension === "3d" || t.dimension === "1d") throw new Error("Generating mipmaps for non-2d textures is currently unsupported!"); let s = t, o = t.depthOrArrayLayers || 1, i = t.usage & GPUTextureUsage.RENDER_ATTACHMENT; if (!i) { let l = { size: { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: o }, format: t.format, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT, mipLevelCount: t.mipLevelCount - 1 }; s = this.device.createTexture(l) } let n = this.device.createCommandEncoder({}), a = e.getBindGroupLayout(0); for (let l = 0; l < o; ++l) { let h = t.createView({ baseMipLevel: 0, mipLevelCount: 1, dimension: "2d", baseArrayLayer: l, arrayLayerCount: 1 }), u = i ? 1 : 0; for (let d = 1; d < t.mipLevelCount; ++d) { let f = s.createView({ baseMipLevel: u++, mipLevelCount: 1, dimension: "2d", baseArrayLayer: l, arrayLayerCount: 1 }), p = n.beginRenderPass({ colorAttachments: [{ view: f, storeOp: "store", loadOp: "clear", clearValue: { r: 0, g: 0, b: 0, a: 0 } }] }), g = this.device.createBindGroup({ layout: a, entries: [{ binding: 0, resource: this.sampler }, { binding: 1, resource: h }] }); p.setPipeline(e), p.setBindGroup(0, g), p.draw(3, 1, 0, 0), p.end(), h = f } } if (!i) { let l = { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: o }; for (let h = 1; h < t.mipLevelCount; ++h)n.copyTextureToTexture({ texture: s, mipLevel: h - 1 }, { texture: t, mipLevel: h }, l), l.width = Math.ceil(l.width / 2), l.height = Math.ceil(l.height / 2) } return this.device.queue.submit([n.finish()]), i || s.destroy(), t }
              }; c(Zo, "GpuMipmapGenerator")
            }); var Js, Yx = m(() => { ft(); S(); Yi(); _r(); Wx(); Xx(); qh(); zx(); Vx(); Js = class { constructor(t) { this.managedTextures = [], this._gpuSources = Object.create(null), this._gpuSamplers = Object.create(null), this._bindGroupHash = Object.create(null), this._textureViewHash = Object.create(null), this._uploads = { image: Dn, buffer: jh, video: Zh, compressed: Kh }, this._renderer = t } contextChange (t) { this._gpu = t } initSource (t) { if (t.autoGenerateMipmaps) { let l = Math.max(t.pixelWidth, t.pixelHeight); t.mipLevelCount = Math.floor(Math.log2(l)) + 1 } let e = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST; t.uploadMethodId !== "compressed" && (e |= GPUTextureUsage.RENDER_ATTACHMENT, e |= GPUTextureUsage.COPY_SRC); let s = tc[t.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, o = Math.ceil(t.pixelWidth / s.blockWidth) * s.blockWidth, i = Math.ceil(t.pixelHeight / s.blockHeight) * s.blockHeight, n = { label: t.label, size: { width: o, height: i }, format: t.format, sampleCount: t.sampleCount, mipLevelCount: t.mipLevelCount, dimension: t.dimension, usage: e }, a = this._gpu.device.createTexture(n); return this._gpuSources[t.uid] = a, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), a } onSourceUpdate (t) { let e = this.getGpuSource(t); e && (this._uploads[t.uploadMethodId] && this._uploads[t.uploadMethodId].upload(t, e, this._gpu), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t)) } onSourceUnload (t) { let e = this._gpuSources[t.uid]; e && (this._gpuSources[t.uid] = null, e.destroy()) } onUpdateMipmaps (t) { this._mipmapGenerator || (this._mipmapGenerator = new Zo(this._gpu.device)); let e = this.getGpuSource(t); this._mipmapGenerator.generateMipmap(e) } onSourceDestroy (t) { t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t) } onSourceResize (t) { let e = this._gpuSources[t.uid]; e ? (e.width !== t.pixelWidth || e.height !== t.pixelHeight) && (this._textureViewHash[t.uid] = null, this._bindGroupHash[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t) } _initSampler (t) { return this._gpuSamplers[t._resourceId] = this._gpu.device.createSampler(t), this._gpuSamplers[t._resourceId] } getGpuSampler (t) { return this._gpuSamplers[t._resourceId] || this._initSampler(t) } getGpuSource (t) { return this._gpuSources[t.uid] || this.initSource(t) } getTextureBindGroup (t) { return this._bindGroupHash[t.uid] ?? this._createTextureBindGroup(t) } _createTextureBindGroup (t) { let e = t.source, s = e.uid; return this._bindGroupHash[s] = new Rt({ 0: e, 1: e.style }), this._bindGroupHash[s] } getTextureView (t) { let e = t.source; return this._textureViewHash[e.uid] ?? this._createTextureView(e) } _createTextureView (t) { return this._textureViewHash[t.uid] = this.getGpuSource(t).createView(), this._textureViewHash[t.uid] } generateCanvas (t) { let e = this._renderer, s = e.gpu.device.createCommandEncoder(), o = k.get().createCanvas(); o.width = t.source.pixelWidth, o.height = t.source.pixelHeight; let i = o.getContext("webgpu"); return i.configure({ device: e.gpu.device, usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC, format: navigator.gpu.getPreferredCanvasFormat(), alphaMode: "premultiplied" }), s.copyTextureToTexture({ texture: e.texture.getGpuSource(t.source), origin: { x: 0, y: 0 } }, { texture: i.getCurrentTexture() }, { width: o.width, height: o.height }), e.gpu.device.queue.submit([s.finish()]), o } getPixels (t) { let e = this.generateCanvas(t), s = ie.getOptimalCanvasAndContext(e.width, e.height), o = s.context; o.drawImage(e, 0, 0); let { width: i, height: n } = e, a = o.getImageData(0, 0, i, n), l = new Uint8ClampedArray(a.data.buffer); return ie.returnCanvasAndContext(s), { pixels: l, width: i, height: n } } destroy () { this.managedTextures.slice().forEach(t => this.onSourceDestroy(t)), this.managedTextures = null; for (let t of Object.keys(this._bindGroupHash)) { let e = Number(t); this._bindGroupHash[e]?.destroy(), this._bindGroupHash[e] = null } this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null } }; c(Js, "GpuTextureSystem"); Js.extension = { type: [x.WebGPUSystem], name: "texture" } }); var i0 = {}; c_(i0, { WebGPURenderer: () => Ln }); var MT, GT, UT, r0, s0, o0, Ln, $x = m(() => { S(); Xm(); zm(); Ym(); Mn(); Uh(); Re(); Sx(); Tx(); Ex(); Px(); Cx(); Bx(); Rx(); Gx(); Ux(); Dx(); Lx(); Nx(); Yx(); MT = [...Fn, $s, Vs, Fr, Xs, Js, qs, Zs, Qs, Ks, zs, Ys, Ws], GT = [...In, js], UT = [ws, As, Bs], r0 = [], s0 = [], o0 = []; I.handleByNamedList(x.WebGPUSystem, r0); I.handleByNamedList(x.WebGPUPipes, s0); I.handleByNamedList(x.WebGPUPipesAdaptor, o0); I.add(...MT, ...GT, ...UT); Ln = class extends nr { constructor() { let t = { name: "webgpu", type: yt.WEBGPU, systems: r0, renderPipes: s0, renderPipeAdaptors: o0 }; super(t) } }; c(Ln, "WebGPURenderer") }); var to, jx = m(() => { S(); ot(); Ze(); sr(); Oo(); ko(); Lo(); or(); La(); Me(); Ot(); to = class { init () { let t = new et({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new B, type: "mat3x3<f32>" }, uRound: { value: 0, type: "f32" } }), e = Be({ name: "graphics", bits: [ps, xs(16), ys, we] }); this.shader = new dt({ glProgram: e, resources: { localUniforms: t, batchSamplers: gs } }) } execute (t, e) { let s = e.context, o = s.customShader || this.shader, i = t.renderer, n = i.graphicsContext, { geometry: a, instructions: l } = n.getContextRenderData(s); o.groups[0] = i.globalUniforms.bindGroup, i.state.set(t.state), i.shader.bind(o), i.geometry.bind(a, o.glProgram); let h = l.instructions; for (let u = 0; u < l.instructionSize; u++) { let d = h[u]; if (d.size) { for (let f = 0; f < d.textures.textures.length; f++)i.texture.bind(d.textures.textures[f], f); i.geometry.draw("triangle-list", d.size, d.start) } } } destroy () { this.shader.destroy(!0), this.shader = null } }; c(to, "GlGraphicsAdaptor"); to.extension = { type: [x.WebGLPipesAdaptor], name: "graphics" } }); var eo, Kx = m(() => { S(); ot(); sr(); Lo(); or(); _h(); Me(); rt(); ut(); eo = class { init () { let t = Be({ name: "mesh", bits: [ys, gh, we] }); this._shader = new dt({ glProgram: t, resources: { uTexture: E.EMPTY.source, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new B } } } }) } execute (t, e) { let s = t.renderer, o = e._shader; if (o) { if (!o.glProgram) { U("Mesh shader has no glProgram", e.shader); return } } else { o = this._shader; let i = e.texture, n = i.source; o.resources.uTexture = n, o.resources.uSampler = n.style, o.resources.textureUniforms.uniforms.uTextureMatrix = i.textureMatrix.mapCoord } o.groups[100] = s.globalUniforms.bindGroup, o.groups[101] = t.localUniformsBindGroup, s.encoder.draw({ geometry: e._geometry, shader: o, state: e.state }) } destroy () { this._shader.destroy(!0), this._shader = null } }; c(eo, "GlMeshAdaptor"); eo.extension = { type: [x.WebGLPipesAdaptor], name: "mesh" } }); var ro, qx = m(() => { S(); sr(); Oo(); ko(); or(); La(); Me(); Se(); Ze(); ro = class { constructor() { this._didUpload = !1, this._tempState = Pt.for2d() } init (t) { let e = Be({ name: "batch", bits: [ps, xs(16), we] }); this._shader = new dt({ glProgram: e, resources: { batchSamplers: gs } }), t.renderer.runners.contextChange.add(this) } contextChange () { this._didUpload = !1 } start (t, e) { let s = t.renderer; s.shader.bind(this._shader, this._didUpload), s.shader.updateUniformGroup(s.globalUniforms.uniformGroup), s.geometry.bind(e, this._shader.glProgram) } execute (t, e) { let s = t.renderer; this._didUpload = !0, this._tempState.blendMode = e.blendMode, s.state.set(this._tempState); let o = e.textures.textures; for (let i = 0; i < o.length; i++)s.texture.bind(o[i], i); s.geometry.draw("triangle-list", e.size, e.start) } destroy () { this._shader.destroy(!0), this._shader = null } }; c(ro, "GlBatchAdaptor"); ro.extension = { type: [x.WebGLPipesAdaptor], name: "batch" } }); var Qo, Zx = m(() => { "use strict"; Qo = (r => (r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", r))(Qo || {}) }); var Jo, Qx = m(() => { "use strict"; Jo = class { constructor(t, e) { this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = e } }; c(Jo, "GlBuffer") }); var so, Jx = m(() => { S(); qe(); Zx(); Qx(); so = class { constructor(t) { this._gpuBuffers = Object.create(null), this._boundBufferBases = Object.create(null), this._renderer = t } destroy () { this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null } contextChange () { this._gpuBuffers = Object.create(null), this._gl = this._renderer.gl } getGlBuffer (t) { return this._gpuBuffers[t.uid] || this.createGLBuffer(t) } bind (t) { let { _gl: e } = this, s = this.getGlBuffer(t); e.bindBuffer(s.type, s.buffer) } bindBufferBase (t, e) { let { _gl: s } = this; if (this._boundBufferBases[e] !== t) { let o = this.getGlBuffer(t); this._boundBufferBases[e] = t, s.bindBufferBase(s.UNIFORM_BUFFER, e, o.buffer) } } bindBufferRange (t, e, s) { let { _gl: o } = this; s = s || 0; let i = this.getGlBuffer(t); o.bindBufferRange(o.UNIFORM_BUFFER, e || 0, i.buffer, s * 256, 256) } updateBuffer (t) { let { _gl: e } = this, s = this.getGlBuffer(t); if (t._updateID === s.updateID) return s; s.updateID = t._updateID, e.bindBuffer(s.type, s.buffer); let o = t.data; if (s.byteLength >= t.data.byteLength) e.bufferSubData(s.type, 0, o, 0, t._updateSize / o.BYTES_PER_ELEMENT); else { let i = t.descriptor.usage & K.STATIC ? e.STATIC_DRAW : e.DYNAMIC_DRAW; s.byteLength = o.byteLength, e.bufferData(s.type, o, i) } return s } destroyAll () { let t = this._gl; for (let e in this._gpuBuffers) t.deleteBuffer(this._gpuBuffers[e].buffer); this._gpuBuffers = Object.create(null) } onBufferDestroy (t, e) { let s = this._gpuBuffers[t.uid], o = this._gl; e || o.deleteBuffer(s.buffer), this._gpuBuffers[t.uid] = null } createGLBuffer (t) { let { _gl: e } = this, s = Qo.ARRAY_BUFFER; t.descriptor.usage & K.INDEX ? s = Qo.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & K.UNIFORM && (s = Qo.UNIFORM_BUFFER); let o = new Jo(e.createBuffer(), s); return this._gpuBuffers[t.uid] = o, t.on("destroy", this.onBufferDestroy, this), o } }; c(so, "GlBufferSystem"); so.extension = { type: [x.WebGLSystem], name: "buffer" } }); var yb, Qh, tg = m(() => { ft(); S(); ut(); yb = c(class n0 { constructor(t) { this.supports = { uint32Indices: !0, uniformBufferObject: !0, vertexArrayObject: !0, srgbTextures: !0, nonPowOf2wrapping: !0, msaa: !0, nonPowOf2mipmaps: !0 }, this._renderer = t, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this) } get isLost () { return !this.gl || this.gl.isContextLost() } contextChange (t) { this.gl = t, this._renderer.gl = t } init (t) { if (t = { ...n0.defaultOptions, ...t }, t.context) this.initFromContext(t.context); else { let e = this._renderer.background.alpha < 1, s = t.premultipliedAlpha ?? !0, o = t.antialias && !this._renderer.backBuffer.useBackBuffer; this.createContext(t.preferWebGLVersion, { alpha: e, premultipliedAlpha: s, antialias: o, stencil: !0, preserveDrawingBuffer: t.preserveDrawingBuffer, powerPreference: t.powerPreference ?? "default" }) } } initFromContext (t) { this.gl = t, this.webGLVersion = t instanceof k.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this._renderer.runners.contextChange.emit(t); let e = this._renderer.view.canvas; e.addEventListener("webglcontextlost", this.handleContextLost, !1), e.addEventListener("webglcontextrestored", this.handleContextRestored, !1) } createContext (t, e) { let s, o = this._renderer.view.canvas; if (t === 2 && (s = o.getContext("webgl2", e)), !s && (s = o.getContext("webgl", e), !s)) throw new Error("This browser does not support WebGL. Try using the canvas renderer"); this.gl = s, this.initFromContext(this.gl) } getExtensions () { let { gl: t } = this, e = { anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t.getExtension("WEBGL_compressed_texture_etc"), etc1: t.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t.getExtension("WEBGL_compressed_texture_atc"), astc: t.getExtension("WEBGL_compressed_texture_astc"), bptc: t.getExtension("EXT_texture_compression_bptc"), rgtc: t.getExtension("EXT_texture_compression_rgtc"), loseContext: t.getExtension("WEBGL_lose_context") }; if (this.webGLVersion === 1) this.extensions = { ...e, drawBuffers: t.getExtension("WEBGL_draw_buffers"), depthTexture: t.getExtension("WEBGL_depth_texture"), vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t.getExtension("OES_element_index_uint"), floatTexture: t.getExtension("OES_texture_float"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), textureHalfFloat: t.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"), vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"), srgb: t.getExtension("EXT_sRGB") }; else { this.extensions = { ...e, colorBufferFloat: t.getExtension("EXT_color_buffer_float") }; let s = t.getExtension("WEBGL_provoking_vertex"); s && s.provokingVertexWEBGL(s.FIRST_VERTEX_CONVENTION_WEBGL) } } handleContextLost (t) { t.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(() => { this.gl.isContextLost() && this.extensions.loseContext?.restoreContext() }, 0)) } handleContextRestored () { this._renderer.runners.contextChange.emit(this.gl) } destroy () { let t = this._renderer.view.canvas; this._renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext() } forceContextLoss () { this.extensions.loseContext?.loseContext(), this._contextLossForced = !0 } validateContext (t) { let e = t.getContextAttributes(); e && !e.stencil && U("Provided WebGL context does not have a stencil buffer, masks may not render correctly"); let s = this.supports, o = this.webGLVersion === 2, i = this.extensions; s.uint32Indices = o || !!i.uint32ElementIndex, s.uniformBufferObject = o, s.vertexArrayObject = o || !!i.vertexArrayObject, s.srgbTextures = o || !!i.srgb, s.nonPowOf2wrapping = o, s.nonPowOf2mipmaps = o, s.msaa = o, s.uint32Indices || U("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly") } }, "_GlContextSystem"); yb.extension = { type: [x.WebGLSystem], name: "context" }; yb.defaultOptions = { context: null, premultipliedAlpha: !0, preserveDrawingBuffer: !1, powerPreference: void 0, preferWebGLVersion: 2 }; Qh = yb }); var Hn, ec, eg, st, Jh = m(() => { "use strict"; Hn = (r => (r[r.RGBA = 6408] = "RGBA", r[r.RGB = 6407] = "RGB", r[r.RG = 33319] = "RG", r[r.RED = 6403] = "RED", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.ALPHA = 6406] = "ALPHA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", r))(Hn || {}), ec = (r => (r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", r))(ec || {}), eg = (r => (r[r.CLAMP = 33071] = "CLAMP", r[r.REPEAT = 10497] = "REPEAT", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", r))(eg || {}), st = (r => (r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.BYTE = 5120] = "BYTE", r[r.SHORT = 5122] = "SHORT", r[r.INT = 5124] = "INT", r[r.FLOAT = 5126] = "FLOAT", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.HALF_FLOAT = 36193] = "HALF_FLOAT", r))(st || {}) }); function td (r) { return a0[r] ?? a0.float32 } var a0, rg = m(() => { Jh(); a0 = { uint8x2: st.UNSIGNED_BYTE, uint8x4: st.UNSIGNED_BYTE, sint8x2: st.BYTE, sint8x4: st.BYTE, unorm8x2: st.UNSIGNED_BYTE, unorm8x4: st.UNSIGNED_BYTE, snorm8x2: st.BYTE, snorm8x4: st.BYTE, uint16x2: st.UNSIGNED_SHORT, uint16x4: st.UNSIGNED_SHORT, sint16x2: st.SHORT, sint16x4: st.SHORT, unorm16x2: st.UNSIGNED_SHORT, unorm16x4: st.UNSIGNED_SHORT, snorm16x2: st.SHORT, snorm16x4: st.SHORT, float16x2: st.HALF_FLOAT, float16x4: st.HALF_FLOAT, float32: st.FLOAT, float32x2: st.FLOAT, float32x3: st.FLOAT, float32x4: st.FLOAT, uint32: st.UNSIGNED_INT, uint32x2: st.UNSIGNED_INT, uint32x3: st.UNSIGNED_INT, uint32x4: st.UNSIGNED_INT, sint32: st.INT, sint32x2: st.INT, sint32x3: st.INT, sint32x4: st.INT }; c(td, "getGlTypeFromFormat") }); var FT, oo, sg = m(() => { S(); sn(); Xh(); rg(); FT = { "point-list": 0, "line-list": 1, "line-strip": 3, "triangle-list": 4, "triangle-strip": 5 }, oo = class { constructor(t) { this._geometryVaoHash = Object.create(null), this._renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0 } contextChange () { let t = this.gl = this._renderer.gl; if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device"); let e = this._renderer.context.extensions.vertexArrayObject; e && (t.createVertexArray = () => e.createVertexArrayOES(), t.bindVertexArray = o => e.bindVertexArrayOES(o), t.deleteVertexArray = o => e.deleteVertexArrayOES(o)); let s = this._renderer.context.extensions.vertexAttribDivisorANGLE; s && (t.drawArraysInstanced = (o, i, n, a) => { s.drawArraysInstancedANGLE(o, i, n, a) }, t.drawElementsInstanced = (o, i, n, a, l) => { s.drawElementsInstancedANGLE(o, i, n, a, l) }, t.vertexAttribDivisor = (o, i) => s.vertexAttribDivisorANGLE(o, i)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = Object.create(null) } bind (t, e) { let s = this.gl; this._activeGeometry = t; let o = this.getVao(t, e); this._activeVao !== o && (this._activeVao = o, s.bindVertexArray(o)), this.updateBuffers() } reset () { this.unbind() } updateBuffers () { let t = this._activeGeometry, e = this._renderer.buffer; for (let s = 0; s < t.buffers.length; s++) { let o = t.buffers[s]; e.updateBuffer(o) } } checkCompatibility (t, e) { let s = t.attributes, o = e._attributeData; for (let i in o) if (!s[i]) throw new Error(`shader and geometry incompatible, geometry missing the "${i}" attribute`) } getSignature (t, e) { let s = t.attributes, o = e._attributeData, i = ["g", t.uid]; for (let n in s) o[n] && i.push(n, o[n].location); return i.join("-") } getVao (t, e) { return this._geometryVaoHash[t.uid]?.[e._key] || this.initGeometryVao(t, e) } initGeometryVao (t, e, s = !0) { let o = this._renderer.gl, i = this._renderer.buffer; this._renderer.shader._getProgramData(e), this.checkCompatibility(t, e); let n = this.getSignature(t, e); this._geometryVaoHash[t.uid] || (this._geometryVaoHash[t.uid] = Object.create(null), t.on("destroy", this.onGeometryDestroy, this)); let a = this._geometryVaoHash[t.uid], l = a[n]; if (l) return a[e._key] = l, l; kn(t, e._attributeData); let h = t.buffers; l = o.createVertexArray(), o.bindVertexArray(l); for (let u = 0; u < h.length; u++) { let d = h[u]; i.bind(d) } return this.activateVao(t, e), a[e._key] = l, a[n] = l, o.bindVertexArray(null), l } onGeometryDestroy (t, e) { let s = this._geometryVaoHash[t.uid], o = this.gl; if (s) { if (e) for (let i in s) this._activeVao !== s[i] && this.unbind(), o.deleteVertexArray(s[i]); this._geometryVaoHash[t.uid] = null } } destroyAll (t = !1) { let e = this.gl; for (let s in this._geometryVaoHash) { if (t) for (let o in this._geometryVaoHash[s]) { let i = this._geometryVaoHash[s]; this._activeVao !== i && this.unbind(), e.deleteVertexArray(i[o]) } this._geometryVaoHash[s] = null } } activateVao (t, e) { let s = this._renderer.gl, o = this._renderer.buffer, i = t.attributes; t.indexBuffer && o.bind(t.indexBuffer); let n = null; for (let a in i) { let l = i[a], h = l.buffer, u = o.getGlBuffer(h), d = e._attributeData[a]; if (d) { n !== u && (o.bind(h), n = u); let f = l.location; s.enableVertexAttribArray(f); let p = De(l.format), g = td(l.format); if (d.format?.substring(1, 4) === "int" ? s.vertexAttribIPointer(f, p.size, g, l.stride, l.offset) : s.vertexAttribPointer(f, p.size, g, p.normalised, l.stride, l.offset), l.instance) if (this.hasInstance) s.vertexAttribDivisor(f, 1); else throw new Error("geometry error, GPU Instancing is not supported on this device") } } } draw (t, e, s, o) { let { gl: i } = this._renderer, n = this._activeGeometry, a = FT[n.topology || t]; if (o || (o = n.instanceCount), n.indexBuffer) { let l = n.indexBuffer.data.BYTES_PER_ELEMENT, h = l === 2 ? i.UNSIGNED_SHORT : i.UNSIGNED_INT; o > 1 ? i.drawElementsInstanced(a, e || n.indexBuffer.data.length, h, (s || 0) * l, o) : i.drawElements(a, e || n.indexBuffer.data.length, h, (s || 0) * l) } else o > 1 ? i.drawArraysInstanced(a, s || 0, e || n.getSize(), o) : i.drawArrays(a, s || 0, e || n.getSize()); return this } unbind () { this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null } destroy () { this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null } }; c(oo, "GlGeometrySystem"); oo.extension = { type: [x.WebGLSystem], name: "geometry" } }); var IT, vb, ed, og = m(() => {
              S(); ut(); wo(); Me(); Se(); Lt(); rt(); xe(); IT = new oe({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } }), vb = c(class c0 {
                constructor(t) { this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = t } init (t = {}) {
                  let { useBackBuffer: e, antialias: s } = { ...c0.defaultOptions, ...t }; this.useBackBuffer = e, this._antialias = s, this._renderer.context.supports.msaa || (U("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = Pt.for2d(); let o = new bt({
                    vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`, fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`, name: "big-triangle"
                  }); this._bigTriangleShader = new dt({ glProgram: o, resources: { uTexture: E.WHITE.source } })
                } renderStart (t) { let e = this._renderer.renderTarget.getRenderTarget(t.target); if (this._useBackBufferThisRender = this.useBackBuffer && !!e.isRoot, this._useBackBufferThisRender) { let s = this._renderer.renderTarget.getRenderTarget(t.target); this._targetTexture = s.colorTexture, t.target = this._getBackBufferTexture(s.colorTexture) } } renderEnd () { this._presentBackBuffer() } _presentBackBuffer () { let t = this._renderer; t.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (t.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, t.encoder.draw({ geometry: IT, shader: this._bigTriangleShader, state: this._state })) } _getBackBufferTexture (t) { return this._backBufferTexture = this._backBufferTexture || new E({ source: new J({ width: t.width, height: t.height, resolution: t._resolution, antialias: this._antialias }) }), this._backBufferTexture.source.resize(t.width, t.height, t._resolution), this._backBufferTexture } destroy () { this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null) }
              }, "_GlBackBufferSystem"); vb.extension = { type: [x.WebGLSystem], name: "backBuffer", priority: 1 }; vb.defaultOptions = { useBackBuffer: !1 }; ed = vb
            }); var io, ig = m(() => { S(); io = class { constructor(t) { this._colorMaskCache = 15, this._renderer = t } setMask (t) { this._colorMaskCache !== t && (this._colorMaskCache = t, this._renderer.gl.colorMask(!!(t & 8), !!(t & 4), !!(t & 2), !!(t & 1))) } }; c(io, "GlColorMaskSystem"); io.extension = { type: [x.WebGLSystem], name: "colorMask" } }); var no, ng = m(() => { S(); no = class { constructor(t) { this.commandFinished = Promise.resolve(), this._renderer = t } setGeometry (t, e) { this._renderer.geometry.bind(t, e.glProgram) } finishRenderPass () { } draw (t) { let e = this._renderer, { geometry: s, shader: o, state: i, skipSync: n, topology: a, size: l, start: h, instanceCount: u } = t; e.shader.bind(o, n), e.geometry.bind(s, e.shader._activeProgram), i && e.state.set(i), e.geometry.draw(a, l, h, u ?? s.instanceCount) } destroy () { this._renderer = null } }; c(no, "GlEncoderSystem"); no.extension = { type: [x.WebGLSystem], name: "encoder" } }); var ao, ag = m(() => { S(); zh(); Jr(); ao = class { constructor(t) { this._stencilCache = { enabled: !1, stencilReference: 0, stencilMode: xt.NONE }, this._renderTargetStencilState = Object.create(null), t.renderTarget.onRenderTargetChange.add(this) } contextChange (t) { this._gl = t, this._comparisonFuncMapping = { always: t.ALWAYS, never: t.NEVER, equal: t.EQUAL, "not-equal": t.NOTEQUAL, less: t.LESS, "less-equal": t.LEQUAL, greater: t.GREATER, "greater-equal": t.GEQUAL }, this._stencilOpsMapping = { keep: t.KEEP, zero: t.ZERO, replace: t.REPLACE, invert: t.INVERT, "increment-clamp": t.INCR, "decrement-clamp": t.DECR, "increment-wrap": t.INCR_WRAP, "decrement-wrap": t.DECR_WRAP }, this._stencilCache.enabled = !1, this._stencilCache.stencilMode = xt.NONE, this._stencilCache.stencilReference = 0 } onRenderTargetChange (t) { if (this._activeRenderTarget === t) return; this._activeRenderTarget = t; let e = this._renderTargetStencilState[t.uid]; e || (e = this._renderTargetStencilState[t.uid] = { stencilMode: xt.DISABLED, stencilReference: 0 }), this.setStencilMode(e.stencilMode, e.stencilReference) } setStencilMode (t, e) { let s = this._renderTargetStencilState[this._activeRenderTarget.uid], o = this._gl, i = We[t], n = this._stencilCache; if (s.stencilMode = t, s.stencilReference = e, t === xt.DISABLED) { this._stencilCache.enabled && (this._stencilCache.enabled = !1, o.disable(o.STENCIL_TEST)); return } this._stencilCache.enabled || (this._stencilCache.enabled = !0, o.enable(o.STENCIL_TEST)), (t !== n.stencilMode || n.stencilReference !== e) && (n.stencilMode = t, n.stencilReference = e, o.stencilFunc(this._comparisonFuncMapping[i.stencilBack.compare], e, 255), o.stencilOp(o.KEEP, o.KEEP, this._stencilOpsMapping[i.stencilBack.passOp])) } }; c(ao, "GlStencilSystem"); ao.extension = { type: [x.WebGLSystem], name: "stencil" } }); function rd (r) { let t = r.map(i => ({ data: i, offset: 0, size: 0 })), e = 0, s = 0, o = 0; for (let i = 0; i < t.length; i++) { let n = t[i]; if (e = rc[n.data.type], !e) throw new Error(`Unknown type ${n.data.type}`); if (n.data.size > 1 && (e = Math.max(e, 16) * n.data.size), n.size = e, s % e !== 0 && s < 16) { let a = s % e % 16; s += a, o += a } s + e > 16 ? (o = Math.ceil(o / 16) * 16, n.offset = o, o += e, s = e) : (n.offset = o, s += e, o += e) } return o = Math.ceil(o / 16) * 16, { uboElements: t, size: o } } var rc, sd = m(() => { "use strict"; rc = { f32: 4, "vec2<f32>": 8, "vec3<f32>": 12, "vec4<f32>": 16, "mat2x2<f32>": 32, "mat3x3<f32>": 48, "mat4x4<f32>": 64 }; c(rd, "createUboElementsSTD40") }); function od (r, t) {
              let e = Math.max(rc[r.data.type] / 16, 1), s = r.data.value.length / r.data.size, o = (4 - s % 4) % 4; return `
        v = uv.${r.data.name};
        offset += ${t};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${r.data.size * e}; i++)
        {
            for(var j = 0; j < ${s}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${o !== 0 ? `arrayOffset += ${o};` : ""}
        }
    `} var cg = m(() => { sd(); c(od, "generateArraySyncSTD40") }); function id (r) { return On(r, "uboStd40", od, Qa) } var lg = m(() => { Dh(); Hh(); cg(); c(id, "createUboSyncFunctionSTD40") }); var co, ug = m(() => { S(); Fh(); sd(); lg(); co = class extends Ir { constructor() { super({ createUboElements: rd, generateUboSync: id }) } }; c(co, "GlUboSystem"); co.extension = { type: [x.WebGLSystem], name: "ubo" } }); var ti, hg = m(() => { "use strict"; ti = class { constructor() { this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [] } }; c(ti, "GlRenderTarget") }); var ei, dg = m(() => { Gt(); ut(); Wo(); hg(); ei = class { constructor() { this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new H } init (t, e) { this._renderer = t, this._renderTargetSystem = e, t.runners.contextChange.add(this) } contextChange () { this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new H } copyToTexture (t, e, s, o, i) { let n = this._renderTargetSystem, a = this._renderer, l = n.getGpuRenderTarget(t), h = a.gl; return this.finishRenderPass(t), h.bindFramebuffer(h.FRAMEBUFFER, l.resolveTargetFramebuffer), a.texture.bind(e, 0), h.copyTexSubImage2D(h.TEXTURE_2D, 0, i.x, i.y, s.x, s.y, o.width, o.height), e } startRenderPass (t, e = !0, s, o) { let i = this._renderTargetSystem, n = t.colorTexture, a = i.getGpuRenderTarget(t), l = o.y; t.isRoot && (l = n.pixelHeight - o.height), t.colorTextures.forEach(d => { this._renderer.texture.unbind(d) }); let h = this._renderer.gl; h.bindFramebuffer(h.FRAMEBUFFER, a.framebuffer); let u = this._viewPortCache; (u.x !== o.x || u.y !== l || u.width !== o.width || u.height !== o.height) && (u.x = o.x, u.y = l, u.width = o.width, u.height = o.height, h.viewport(o.x, l, o.width, o.height)), !a.depthStencilRenderBuffer && (t.stencil || t.depth) && this._initStencil(a), this.clear(t, e, s) } finishRenderPass (t) { let s = this._renderTargetSystem.getGpuRenderTarget(t); if (!s.msaa) return; let o = this._renderer.gl; o.bindFramebuffer(o.FRAMEBUFFER, s.resolveTargetFramebuffer), o.bindFramebuffer(o.READ_FRAMEBUFFER, s.framebuffer), o.blitFramebuffer(0, 0, s.width, s.height, 0, 0, s.width, s.height, o.COLOR_BUFFER_BIT, o.NEAREST), o.bindFramebuffer(o.FRAMEBUFFER, s.framebuffer) } initGpuRenderTarget (t) { let e = this._renderer, s = e.gl, o = new ti; return t.colorTexture.resource === e.gl.canvas ? (o.framebuffer = null, o) : (this._initColor(t, o), s.bindFramebuffer(s.FRAMEBUFFER, null), o) } destroyGpuRenderTarget (t) { let e = this._renderer.gl; t.framebuffer && (e.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (e.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (e.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach(s => { e.deleteRenderbuffer(s) }), t.msaaRenderBuffer = null } clear (t, e, s) { if (!e) return; let o = this._renderTargetSystem; typeof e == "boolean" && (e = e ? Ut.ALL : Ut.NONE); let i = this._renderer.gl; if (e & Ut.COLOR) { s ?? (s = o.defaultClearColor); let n = this._clearColorCache, a = s; (n[0] !== a[0] || n[1] !== a[1] || n[2] !== a[2] || n[3] !== a[3]) && (n[0] = a[0], n[1] = a[1], n[2] = a[2], n[3] = a[3], i.clearColor(a[0], a[1], a[2], a[3])) } i.clear(e) } resizeGpuRenderTarget (t) { if (t.isRoot) return; let s = this._renderTargetSystem.getGpuRenderTarget(t); this._resizeColor(t, s), t.stencil && this._resizeStencil(s) } _initColor (t, e) { let s = this._renderer, o = s.gl, i = o.createFramebuffer(); if (e.resolveTargetFramebuffer = i, o.bindFramebuffer(o.FRAMEBUFFER, i), e.width = t.colorTexture.source.pixelWidth, e.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((n, a) => { let l = n.source; l.antialias && (s.context.supports.msaa ? e.msaa = !0 : U("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), s.texture.bindSource(l, 0); let u = s.texture.getGlSource(l).texture; o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + a, 3553, u, 0) }), e.msaa) { let n = o.createFramebuffer(); e.framebuffer = n, o.bindFramebuffer(o.FRAMEBUFFER, n), t.colorTextures.forEach((a, l) => { let h = o.createRenderbuffer(); e.msaaRenderBuffer[l] = h }) } else e.framebuffer = i; this._resizeColor(t, e) } _resizeColor (t, e) { let s = t.colorTexture.source; if (e.width = s.pixelWidth, e.height = s.pixelHeight, t.colorTextures.forEach((o, i) => { i !== 0 && o.source.resize(s.width, s.height, s._resolution) }), e.msaa) { let o = this._renderer, i = o.gl, n = e.framebuffer; i.bindFramebuffer(i.FRAMEBUFFER, n), t.colorTextures.forEach((a, l) => { let h = a.source; o.texture.bindSource(h, 0); let d = o.texture.getGlSource(h).internalFormat, f = e.msaaRenderBuffer[l]; i.bindRenderbuffer(i.RENDERBUFFER, f), i.renderbufferStorageMultisample(i.RENDERBUFFER, 4, d, h.pixelWidth, h.pixelHeight), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + l, i.RENDERBUFFER, f) }) } } _initStencil (t) { if (t.framebuffer === null) return; let e = this._renderer.gl, s = e.createRenderbuffer(); t.depthStencilRenderBuffer = s, e.bindRenderbuffer(e.RENDERBUFFER, s), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, s), this._resizeStencil(t) } _resizeStencil (t) { let e = this._renderer.gl; e.bindRenderbuffer(e.RENDERBUFFER, t.depthStencilRenderBuffer), t.msaa ? e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL, t.width, t.height) } }; c(ei, "GlRenderTargetAdaptor") }); var lo, fg = m(() => { S(); $h(); dg(); lo = class extends Or { constructor(t) { super(t), this.adaptor = new ei, this.adaptor.init(t, this) } }; c(lo, "GlRenderTargetSystem"); lo.extension = { type: [x.WebGLSystem], name: "renderTarget" } }); function nd (r, t) {
          let e = [], s = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `], o = !1, i = 0, n = 0, a = t._getProgramData(r.glProgram); for (let h in r.groups) {
            let u = r.groups[h]; e.push(`
            resources = g[${h}].resources;
        `); for (let d in u.resources) {
              let f = u.resources[d]; if (f instanceof et) f.ubo ? e.push(`
                        sS.bindUniformBlock(
                            resources[${d}],
                            sS._uniformBindMap[${h}[${d}],
                            ${i++}
                        );
                    `) : e.push(`
                        ugS.updateUniformGroup(resources[${d}], p, sD);
                    `); else if (f instanceof Ne) e.push(`
                    sS.bindUniformBlock(
                        resources[${d}],
                        sS._uniformBindMap[${h}[${d}],
                        ${i++}
                    );
                `); else if (f instanceof J) {
                let p = r._uniformBindMap[h][d], g = a.uniformData[p]; g && (o || (o = !0, s.push(`
                        var tS = r.texture;
                        `)), t._gl.uniform1i(g.location, n), e.push(`
                        tS.bind(resources[${d}], ${n});
                    `), n++)
              }
            }
          } let l = [...s, ...e].join(`
`); return new Function("r", "s", "sD", l)
        } var pg = m(() => { Ja(); Ot(); Lt(); c(nd, "generateShaderSyncCode") }); var sc, ri, mg = m(() => { "use strict"; sc = class { }; c(sc, "IGLUniformData"); ri = class { constructor(t, e) { this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {} } destroy () { this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null } }; c(ri, "GlProgramData") }); function oc (r, t, e) { let s = r.createShader(t); return r.shaderSource(s, e), r.compileShader(s), s } var xg = m(() => { "use strict"; c(oc, "compileShader") }); function Sb (r) { let t = new Array(r); for (let e = 0; e < t.length; e++)t[e] = !1; return t } function Nn (r, t) { switch (r) { case "float": return 0; case "vec2": return new Float32Array(2 * t); case "vec3": return new Float32Array(3 * t); case "vec4": return new Float32Array(4 * t); case "int": case "uint": case "sampler2D": case "sampler2DArray": return 0; case "ivec2": return new Int32Array(2 * t); case "ivec3": return new Int32Array(3 * t); case "ivec4": return new Int32Array(4 * t); case "uvec2": return new Uint32Array(2 * t); case "uvec3": return new Uint32Array(3 * t); case "uvec4": return new Uint32Array(4 * t); case "bool": return !1; case "bvec2": return Sb(2 * t); case "bvec3": return Sb(3 * t); case "bvec4": return Sb(4 * t); case "mat2": return new Float32Array([1, 0, 0, 1]); case "mat3": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } var ad = m(() => { "use strict"; c(Sb, "booleanArray"); c(Nn, "defaultValue") }); function ic (r, t) { if (!gg) { let e = Object.keys(l0); gg = {}; for (let s = 0; s < e.length; ++s) { let o = e[s]; gg[r[o]] = l0[o] } } return gg[t] } function cd (r, t) { let e = ic(r, t); return OT[e] || "float32" } var gg, l0, OT, ld = m(() => { "use strict"; gg = null, l0 = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" }, OT = { float: "float32", vec2: "float32x2", vec3: "float32x3", vec4: "float32x4", int: "sint32", ivec2: "sint32x2", ivec3: "sint32x3", ivec4: "sint32x4", uint: "uint32", uvec2: "uint32x2", uvec3: "uint32x3", uvec4: "uint32x4", bool: "uint32", bvec2: "uint32x2", bvec3: "uint32x3", bvec4: "uint32x4" }; c(ic, "mapType"); c(cd, "mapGlToVertexFormat") }); function ud (r, t, e = !1) { let s = {}, o = t.getProgramParameter(r, t.ACTIVE_ATTRIBUTES); for (let n = 0; n < o; n++) { let a = t.getActiveAttrib(r, n); if (a.name.startsWith("gl_")) continue; let l = cd(t, a.type); s[a.name] = { location: 0, format: l, stride: De(l).stride, offset: 0, instance: !1, start: 0 } } let i = Object.keys(s); if (e) { i.sort((n, a) => n > a ? 1 : -1); for (let n = 0; n < i.length; n++)s[i[n]].location = n, t.bindAttribLocation(r, n, i[n]); t.linkProgram(r) } else for (let n = 0; n < i.length; n++)s[i[n]].location = t.getAttribLocation(r, i[n]); return s } var _g = m(() => { sn(); ld(); c(ud, "extractAttributesFromGlProgram") }); function hd (r, t) { if (!t.ACTIVE_UNIFORM_BLOCKS) return {}; let e = {}, s = t.getProgramParameter(r, t.ACTIVE_UNIFORM_BLOCKS); for (let o = 0; o < s; o++) { let i = t.getActiveUniformBlockName(r, o), n = t.getUniformBlockIndex(r, i), a = t.getActiveUniformBlockParameter(r, o, t.UNIFORM_BLOCK_DATA_SIZE); e[i] = { name: i, index: n, size: a } } return e } var bg = m(() => { "use strict"; c(hd, "getUboData") }); function dd (r, t) { let e = {}, s = t.getProgramParameter(r, t.ACTIVE_UNIFORMS); for (let o = 0; o < s; o++) { let i = t.getActiveUniform(r, o), n = i.name.replace(/\[.*?\]$/, ""), a = !!i.name.match(/\[.*?\]$/), l = ic(t, i.type); e[n] = { name: n, index: o, type: l, size: i.size, isArray: a, value: Nn(l, i.size) } } return e } var yg = m(() => { ad(); ld(); c(dd, "getUniformData") }); function u0 (r, t) {
          let e = r.getShaderSource(t).split(`
`).map((h, u) => `${u}: ${h}`), s = r.getShaderInfoLog(t), o = s.split(`
`), i = {}, n = o.map(h => parseFloat(h.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(h => h && !i[h] ? (i[h] = !0, !0) : !1), a = [""]; n.forEach(h => { e[h - 1] = `%c${e[h - 1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px") }); let l = e.join(`
`); a[0] = l, console.error(s), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd()
        } function fd (r, t, e, s) { r.getProgramParameter(t, r.LINK_STATUS) || (r.getShaderParameter(e, r.COMPILE_STATUS) || u0(r, e), r.getShaderParameter(s, r.COMPILE_STATUS) || u0(r, s), console.error("PixiJS Error: Could not initialize shader."), r.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", r.getProgramInfoLog(t))) } var vg = m(() => { "use strict"; c(u0, "logPrettyShaderError"); c(fd, "logProgramError") }); function pd (r, t) { let e = oc(r, r.VERTEX_SHADER, t.vertex), s = oc(r, r.FRAGMENT_SHADER, t.fragment), o = r.createProgram(); r.attachShader(o, e), r.attachShader(o, s); let i = t.transformFeedbackVaryings; i && (typeof r.transformFeedbackVaryings != "function" ? U("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : r.transformFeedbackVaryings(o, i.names, i.bufferMode === "separate" ? r.SEPARATE_ATTRIBS : r.INTERLEAVED_ATTRIBS)), r.linkProgram(o), r.getProgramParameter(o, r.LINK_STATUS) || fd(r, o, e, s), t._attributeData = ud(o, r, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertex)), t._uniformData = dd(o, r), t._uniformBlockData = hd(o, r), r.deleteShader(e), r.deleteShader(s); let n = {}; for (let l in t._uniformData) { let h = t._uniformData[l]; n[l] = { location: r.getUniformLocation(o, l), value: Nn(h.type, h.size) } } return new ri(o, n) } var Sg = m(() => { ut(); mg(); xg(); ad(); _g(); bg(); yg(); vg(); c(pd, "generateProgram") }); var Tg, uo, Eg = m(() => { S(); pg(); Sg(); Tg = { textureCount: 0, blockIndex: 0 }, uo = class { constructor(t) { this._activeProgram = null, this._programDataHash = Object.create(null), this._nextIndex = 0, this._boundUniformsIdsToIndexHash = Object.create(null), this._boundIndexToUniformsHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._renderer = t } contextChange (t) { this._gl = t, this._maxBindings = t.MAX_UNIFORM_BUFFER_BINDINGS ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0, this._programDataHash = Object.create(null), this._boundUniformsIdsToIndexHash = Object.create(null), this._boundIndexToUniformsHash = Object.create(null), this._activeProgram = null } bind (t, e) { if (this._setProgram(t.glProgram), e) return; Tg.textureCount = 0, Tg.blockIndex = 0; let s = this._shaderSyncFunctions[t.glProgram._key]; s || (s = this._shaderSyncFunctions[t.glProgram._key] = this._generateShaderSync(t, this)), s(this._renderer, t, Tg) } updateUniformGroup (t) { this._renderer.uniformGroup.updateUniformGroup(t, this._activeProgram, Tg) } bindUniformBlock (t, e, s = 0) { let o = this._renderer.buffer, i = this._getProgramData(this._activeProgram), n = t._bufferResource; n && this._renderer.ubo.updateUniformGroup(t), o.updateBuffer(t.buffer); let a = this._boundUniformsIdsToIndexHash[t.uid]; if (a === void 0) { let u = this._nextIndex++ % this._maxBindings, d = this._boundIndexToUniformsHash[u]; d && (this._boundUniformsIdsToIndexHash[d.uid] = void 0), a = this._boundUniformsIdsToIndexHash[t.uid] = u, this._boundIndexToUniformsHash[u] = t, n ? o.bindBufferRange(t.buffer, u, t.offset) : o.bindBufferBase(t.buffer, u) } let l = this._gl, h = this._activeProgram._uniformBlockData[e].index; i.uniformBlockBindings[s] !== a && (i.uniformBlockBindings[s] = a, l.uniformBlockBinding(i.program, h, a)) } _setProgram (t) { if (this._activeProgram === t) return; this._activeProgram = t; let e = this._getProgramData(t); this._gl.useProgram(e.program) } _getProgramData (t) { return this._programDataHash[t._key] || this._createProgramData(t) } _createProgramData (t) { let e = t._key; return this._programDataHash[e] = pd(this._gl, t), this._programDataHash[e] } destroy () { for (let t of Object.keys(this._programDataHash)) this._programDataHash[t].destroy(), this._programDataHash[t] = null; this._programDataHash = null, this._boundUniformsIdsToIndexHash = null } _generateShaderSync (t, e) { return nd(t, e) } }; c(uo, "GlShaderSystem"); uo.extension = { type: [x.WebGLSystem], name: "shader" } }); var md, xd, Pg = m(() => {
          "use strict"; md = {
            f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`, "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`, "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`, "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`, i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`, "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`, "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`, "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`, u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`, "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`, "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`, "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`, bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`, "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`, "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`, "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`, "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
          }, xd = { f32: "gl.uniform1fv(location, v);", "vec2<f32>": "gl.uniform2fv(location, v);", "vec3<f32>": "gl.uniform3fv(location, v);", "vec4<f32>": "gl.uniform4fv(location, v);", "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);", i32: "gl.uniform1iv(location, v);", "vec2<i32>": "gl.uniform2iv(location, v);", "vec3<i32>": "gl.uniform3iv(location, v);", "vec4<i32>": "gl.uniform4iv(location, v);", u32: "gl.uniform1iv(location, v);", "vec2<u32>": "gl.uniform2iv(location, v);", "vec3<u32>": "gl.uniform3iv(location, v);", "vec4<u32>": "gl.uniform4iv(location, v);", bool: "gl.uniform1iv(location, v);", "vec2<bool>": "gl.uniform2iv(location, v);", "vec3<bool>": "gl.uniform3iv(location, v);", "vec4<bool>": "gl.uniform4iv(location, v);" }
        }); function gd (r, t) {
          let e = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `]; for (let s in r.uniforms) {
            if (!t[s]) {
              r.uniforms[s] instanceof et ? r.uniforms[s].ubo ? e.push(`
                        renderer.shader.bindUniformBlock(uv.${s}, "${s}");
                    `) : e.push(`
                        renderer.shader.updateUniformGroup(uv.${s});
                    `) : r.uniforms[s] instanceof Ne && e.push(`
                        renderer.shader.bindBufferResource(uv.${s}, "${s}");
                    `); continue
            } let o = r.uniformStructures[s], i = !1; for (let n = 0; n < He.length; n++) { let a = He[n]; if (o.type === a.type && a.test(o)) { e.push(`name = "${s}";`, He[n].uniform), i = !0; break } } if (!i) {
              let a = (o.size === 1 ? md : xd)[o.type].replace("location", `ud["${s}"].location`); e.push(`
            cu = ud["${s}"];
            cv = cu.value;
            v = uv["${s}"];
            ${a};`)
            }
          } return new Function("ud", "uv", "renderer", "syncData", e.join(`
`))
        } var Cg = m(() => { Ja(); Ot(); kh(); Pg(); c(gd, "generateUniformsSync") }); var ho, Bg = m(() => { S(); Cg(); ho = class { constructor(t) { this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = t, this.gl = null, this._cache = {} } contextChange (t) { this.gl = t } updateUniformGroup (t, e, s) { let o = this._renderer.shader._getProgramData(e); (!t.isStatic || t._dirtyId !== o.uniformDirtyGroups[t.uid]) && (o.uniformDirtyGroups[t.uid] = t._dirtyId, this._getUniformSyncFunction(t, e)(o.uniformData, t.uniforms, this._renderer, s)) } _getUniformSyncFunction (t, e) { return this._uniformGroupSyncHash[t._signature]?.[e._key] || this._createUniformSyncFunction(t, e) } _createUniformSyncFunction (t, e) { let s = this._uniformGroupSyncHash[t._signature] || (this._uniformGroupSyncHash[t._signature] = {}), o = this._getSignature(t, e._uniformData, "u"); return this._cache[o] || (this._cache[o] = this._generateUniformsSync(t, e._uniformData)), s[e._key] = this._cache[o], s[e._key] } _generateUniformsSync (t, e) { return gd(t, e) } _getSignature (t, e, s) { let o = t.uniforms, i = [`${s}-`]; for (let n in o) i.push(n), e[n] && i.push(e[n].type); return i.join("-") } destroy () { this._renderer = null, this._cache = null } }; c(ho, "GlUniformGroupSystem"); ho.extension = { type: [x.WebGLSystem], name: "uniformGroup" } }); function _d (r) { let t = {}; return t.normal = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t.add = [r.ONE, r.ONE], t.multiply = [r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t.screen = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t.none = [0, 0], t["normal-npm"] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t["add-npm"] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE], t["screen-npm"] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t.erase = [r.ZERO, r.ONE_MINUS_SRC_ALPHA], t } var Ag = m(() => { "use strict"; c(_d, "mapWebGLBlendModesToPixi") }); var kT, DT, LT, HT, NT, WT, h0, bd, wg = m(() => { S(); Se(); Ag(); kT = 0, DT = 1, LT = 2, HT = 3, NT = 4, WT = 5, h0 = c(class Tb { constructor() { this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[kT] = this.setBlend, this.map[DT] = this.setOffset, this.map[LT] = this.setCullFace, this.map[HT] = this.setDepthTest, this.map[NT] = this.setFrontFace, this.map[WT] = this.setDepthMask, this.checks = [], this.defaultState = Pt.for2d() } contextChange (t) { this.gl = t, this.blendModesMap = _d(t), this.reset() } set (t) { if (t = t || this.defaultState, this.stateId !== t.data) { let e = this.stateId ^ t.data, s = 0; for (; e;)e & 1 && this.map[s].call(this, !!(t.data & 1 << s)), e = e >> 1, s++; this.stateId = t.data } for (let e = 0; e < this.checks.length; e++)this.checks[e](this, t) } forceState (t) { t = t || this.defaultState; for (let e = 0; e < this.map.length; e++)this.map[e].call(this, !!(t.data & 1 << e)); for (let e = 0; e < this.checks.length; e++)this.checks[e](this, t); this.stateId = t.data } setBlend (t) { this._updateCheck(Tb._checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND) } setOffset (t) { this._updateCheck(Tb._checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL) } setDepthTest (t) { this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST) } setDepthMask (t) { this.gl.depthMask(t) } setCullFace (t) { this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE) } setFrontFace (t) { this.gl.frontFace(this.gl[t ? "CW" : "CCW"]) } setBlendMode (t) { if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode) return; this.blendMode = t; let e = this.blendModesMap[t], s = this.gl; e.length === 2 ? s.blendFunc(e[0], e[1]) : s.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, s.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, s.blendEquationSeparate(s.FUNC_ADD, s.FUNC_ADD)) } setPolygonOffset (t, e) { this.gl.polygonOffset(t, e) } reset () { this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal") } _updateCheck (t, e) { let s = this.checks.indexOf(t); e && s === -1 ? this.checks.push(t) : !e && s !== -1 && this.checks.splice(s, 1) } static _checkBlendMode (t, e) { t.setBlendMode(e.blendMode) } static _checkPolygonOffset (t, e) { t.setPolygonOffset(1, e.polygonOffset) } destroy () { this.gl = null, this.checks.length = 0 } }, "_GlStateSystem"); h0.extension = { type: [x.WebGLSystem], name: "state" }; bd = h0 }); var si, Rg = m(() => { Jh(); si = class { constructor(t) { this.target = ec.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = st.UNSIGNED_BYTE, this.internalFormat = Hn.RGBA, this.format = Hn.RGBA, this.samplerType = 0 } }; c(si, "GlTexture") }); var yd, Mg = m(() => { "use strict"; yd = { id: "image", upload (r, t, e) { t.width === r.width || t.height === r.height ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, r.resource) : e.texImage2D(t.target, 0, t.internalFormat, r.width, r.height, 0, t.format, t.type, r.resource), t.width = r.width, t.height = r.height } } }); var XT, vd, Gg = m(() => { "use strict"; XT = { "bc1-rgba-unorm": !0, "bc1-rgba-unorm-srgb": !0, "bc2-rgba-unorm": !0, "bc2-rgba-unorm-srgb": !0, "bc3-rgba-unorm": !0, "bc3-rgba-unorm-srgb": !0, "bc4-r-unorm": !0, "bc4-r-snorm": !0, "bc5-rg-unorm": !0, "bc5-rg-snorm": !0, "bc6h-rgb-ufloat": !0, "bc6h-rgb-float": !0, "bc7-rgba-unorm": !0, "bc7-rgba-unorm-srgb": !0, "etc2-rgb8unorm": !0, "etc2-rgb8unorm-srgb": !0, "etc2-rgb8a1unorm": !0, "etc2-rgb8a1unorm-srgb": !0, "etc2-rgba8unorm": !0, "etc2-rgba8unorm-srgb": !0, "eac-r11unorm": !0, "eac-r11snorm": !0, "eac-rg11unorm": !0, "eac-rg11snorm": !0, "astc-4x4-unorm": !0, "astc-4x4-unorm-srgb": !0, "astc-5x4-unorm": !0, "astc-5x4-unorm-srgb": !0, "astc-5x5-unorm": !0, "astc-5x5-unorm-srgb": !0, "astc-6x5-unorm": !0, "astc-6x5-unorm-srgb": !0, "astc-6x6-unorm": !0, "astc-6x6-unorm-srgb": !0, "astc-8x5-unorm": !0, "astc-8x5-unorm-srgb": !0, "astc-8x6-unorm": !0, "astc-8x6-unorm-srgb": !0, "astc-8x8-unorm": !0, "astc-8x8-unorm-srgb": !0, "astc-10x5-unorm": !0, "astc-10x5-unorm-srgb": !0, "astc-10x6-unorm": !0, "astc-10x6-unorm-srgb": !0, "astc-10x8-unorm": !0, "astc-10x8-unorm-srgb": !0, "astc-10x10-unorm": !0, "astc-10x10-unorm-srgb": !0, "astc-12x10-unorm": !0, "astc-12x10-unorm-srgb": !0, "astc-12x12-unorm": !0, "astc-12x12-unorm-srgb": !0 }, vd = { id: "compressed", upload (r, t, e) { e.pixelStorei(e.UNPACK_ALIGNMENT, 4); let s = r.pixelWidth, o = r.pixelHeight, i = !!XT[r.format]; for (let n = 0; n < r.resource.length; n++) { let a = r.resource[n]; i ? e.compressedTexImage2D(e.TEXTURE_2D, n, t.internalFormat, s, o, 0, a) : e.texImage2D(e.TEXTURE_2D, n, t.internalFormat, s, o, 0, t.format, t.type, a), s = Math.max(s >> 1, 1), o = Math.max(o >> 1, 1) } } } }); var Wn, Sd = m(() => { "use strict"; Wn = { id: "image", upload (r, t, e, s) { let o = r.alphaMode === "premultiply-alpha-on-upload"; e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o); let i = t.width, n = t.height, a = r.pixelWidth, l = r.pixelHeight, h = r.resourceWidth, u = r.resourceHeight; h < a || u < l ? ((i !== a || n !== l) && e.texImage2D(t.target, 0, t.internalFormat, a, l, 0, t.format, t.type, null), s === 2 ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, h, u, t.format, t.type, r.resource) : e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, r.resource)) : i === a || n === l ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, r.resource) : s === 2 ? e.texImage2D(t.target, 0, t.internalFormat, a, l, 0, t.format, t.type, r.resource) : e.texImage2D(t.target, 0, t.internalFormat, t.format, t.type, r.resource), t.width = a, t.height = l } } }); var Td, Ug = m(() => { Sd(); Td = { id: "video", upload (r, t, e, s) { if (!r.isValid) { e.texImage2D(t.target, 0, t.internalFormat, 1, 1, 0, t.format, t.type, null); return } Wn.upload(r, t, e, s) } } }); var nc, Ed, Xn, Pd, Fg = m(() => { "use strict"; nc = { linear: 9729, nearest: 9728 }, Ed = { linear: { linear: 9987, nearest: 9985 }, nearest: { linear: 9986, nearest: 9984 } }, Xn = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 }, Pd = { never: 512, less: 513, equal: 514, "less-equal": 515, greater: 516, "not-equal": 517, "greater-equal": 518, always: 519 } }); function ac (r, t, e, s, o, i, n, a) { let l = i; if (!a || r.addressModeU !== "repeat" || r.addressModeV !== "repeat" || r.addressModeW !== "repeat") { let h = Xn[n ? "clamp-to-edge" : r.addressModeU], u = Xn[n ? "clamp-to-edge" : r.addressModeV], d = Xn[n ? "clamp-to-edge" : r.addressModeW]; t[o](l, t.TEXTURE_WRAP_S, h), t[o](l, t.TEXTURE_WRAP_T, u), t.TEXTURE_WRAP_R && t[o](l, t.TEXTURE_WRAP_R, d) } if ((!a || r.magFilter !== "linear") && t[o](l, t.TEXTURE_MAG_FILTER, nc[r.magFilter]), e) { if (!a || r.mipmapFilter !== "linear") { let h = Ed[r.minFilter][r.mipmapFilter]; t[o](l, t.TEXTURE_MIN_FILTER, h) } } else t[o](l, t.TEXTURE_MIN_FILTER, nc[r.minFilter]); if (s && r.maxAnisotropy > 1) { let h = Math.min(r.maxAnisotropy, t.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)); t[o](l, s.TEXTURE_MAX_ANISOTROPY_EXT, h) } r.compare && t[o](l, t.TEXTURE_COMPARE_FUNC, Pd[r.compare]) } var Ig = m(() => { Fg(); c(ac, "applyStyleParams") }); function Cd (r) { return { r8unorm: r.RED, r8snorm: r.RED, r8uint: r.RED, r8sint: r.RED, r16uint: r.RED, r16sint: r.RED, r16float: r.RED, rg8unorm: r.RG, rg8snorm: r.RG, rg8uint: r.RG, rg8sint: r.RG, r32uint: r.RED, r32sint: r.RED, r32float: r.RED, rg16uint: r.RG, rg16sint: r.RG, rg16float: r.RG, rgba8unorm: r.RGBA, "rgba8unorm-srgb": r.RGBA, rgba8snorm: r.RGBA, rgba8uint: r.RGBA, rgba8sint: r.RGBA, bgra8unorm: r.RGBA, "bgra8unorm-srgb": r.RGBA, rgb9e5ufloat: r.RGB, rgb10a2unorm: r.RGBA, rg11b10ufloat: r.RGB, rg32uint: r.RG, rg32sint: r.RG, rg32float: r.RG, rgba16uint: r.RGBA, rgba16sint: r.RGBA, rgba16float: r.RGBA, rgba32uint: r.RGBA, rgba32sint: r.RGBA, rgba32float: r.RGBA, stencil8: r.STENCIL_INDEX8, depth16unorm: r.DEPTH_COMPONENT, depth24plus: r.DEPTH_COMPONENT, "depth24plus-stencil8": r.DEPTH_STENCIL, depth32float: r.DEPTH_COMPONENT, "depth32float-stencil8": r.DEPTH_STENCIL } } var Og = m(() => { "use strict"; c(Cd, "mapFormatToGlFormat") }); function Bd (r, t) { let e = {}, s = r.RGBA; return r instanceof k.get().getWebGLRenderingContext() ? t.srgb && (e = { "rgba8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT, "bgra8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT }) : (e = { "rgba8unorm-srgb": r.SRGB8_ALPHA8, "bgra8unorm-srgb": r.SRGB8_ALPHA8 }, s = r.RGBA8), { r8unorm: r.R8, r8snorm: r.R8_SNORM, r8uint: r.R8UI, r8sint: r.R8I, r16uint: r.R16UI, r16sint: r.R16I, r16float: r.R16F, rg8unorm: r.RG8, rg8snorm: r.RG8_SNORM, rg8uint: r.RG8UI, rg8sint: r.RG8I, r32uint: r.R32UI, r32sint: r.R32I, r32float: r.R32F, rg16uint: r.RG16UI, rg16sint: r.RG16I, rg16float: r.RG16F, rgba8unorm: r.RGBA, ...e, rgba8snorm: r.RGBA8_SNORM, rgba8uint: r.RGBA8UI, rgba8sint: r.RGBA8I, bgra8unorm: s, rgb9e5ufloat: r.RGB9_E5, rgb10a2unorm: r.RGB10_A2, rg11b10ufloat: r.R11F_G11F_B10F, rg32uint: r.RG32UI, rg32sint: r.RG32I, rg32float: r.RG32F, rgba16uint: r.RGBA16UI, rgba16sint: r.RGBA16I, rgba16float: r.RGBA16F, rgba32uint: r.RGBA32UI, rgba32sint: r.RGBA32I, rgba32float: r.RGBA32F, stencil8: r.STENCIL_INDEX8, depth16unorm: r.DEPTH_COMPONENT16, depth24plus: r.DEPTH_COMPONENT24, "depth24plus-stencil8": r.DEPTH24_STENCIL8, depth32float: r.DEPTH_COMPONENT32F, "depth32float-stencil8": r.DEPTH32F_STENCIL8, ...t.s3tc ? { "bc1-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT, "bc2-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT, "bc3-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT } : {}, ...t.s3tc_sRGB ? { "bc1-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, "bc2-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, "bc3-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } : {}, ...t.rgtc ? { "bc4-r-unorm": t.rgtc.COMPRESSED_RED_RGTC1_EXT, "bc4-r-snorm": t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT, "bc5-rg-unorm": t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT, "bc5-rg-snorm": t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } : {}, ...t.bptc ? { "bc6h-rgb-float": t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, "bc6h-rgb-ufloat": t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, "bc7-rgba-unorm": t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT, "bc7-rgba-unorm-srgb": t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT } : {}, ...t.etc ? { "etc2-rgb8unorm": t.etc.COMPRESSED_RGB8_ETC2, "etc2-rgb8unorm-srgb": t.etc.COMPRESSED_SRGB8_ETC2, "etc2-rgb8a1unorm": t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgb8a1unorm-srgb": t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgba8unorm": t.etc.COMPRESSED_RGBA8_ETC2_EAC, "etc2-rgba8unorm-srgb": t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, "eac-r11unorm": t.etc.COMPRESSED_R11_EAC, "eac-rg11unorm": t.etc.COMPRESSED_SIGNED_RG11_EAC } : {}, ...t.astc ? { "astc-4x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR, "astc-4x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, "astc-5x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR, "astc-5x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, "astc-5x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR, "astc-5x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, "astc-6x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR, "astc-6x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, "astc-6x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR, "astc-6x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, "astc-8x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR, "astc-8x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, "astc-8x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR, "astc-8x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, "astc-8x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR, "astc-8x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, "astc-10x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR, "astc-10x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, "astc-10x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR, "astc-10x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, "astc-10x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR, "astc-10x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, "astc-10x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR, "astc-10x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, "astc-12x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR, "astc-12x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, "astc-12x12-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR, "astc-12x12-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR } : {} } } var kg = m(() => { ft(); c(Bd, "mapFormatToGlInternalFormat") }); function Ad (r) { return { r8unorm: r.UNSIGNED_BYTE, r8snorm: r.BYTE, r8uint: r.UNSIGNED_BYTE, r8sint: r.BYTE, r16uint: r.UNSIGNED_SHORT, r16sint: r.SHORT, r16float: r.HALF_FLOAT, rg8unorm: r.UNSIGNED_BYTE, rg8snorm: r.BYTE, rg8uint: r.UNSIGNED_BYTE, rg8sint: r.BYTE, r32uint: r.UNSIGNED_INT, r32sint: r.INT, r32float: r.FLOAT, rg16uint: r.UNSIGNED_SHORT, rg16sint: r.SHORT, rg16float: r.HALF_FLOAT, rgba8unorm: r.UNSIGNED_BYTE, "rgba8unorm-srgb": r.UNSIGNED_BYTE, rgba8snorm: r.BYTE, rgba8uint: r.UNSIGNED_BYTE, rgba8sint: r.BYTE, bgra8unorm: r.UNSIGNED_BYTE, "bgra8unorm-srgb": r.UNSIGNED_BYTE, rgb9e5ufloat: r.UNSIGNED_INT_5_9_9_9_REV, rgb10a2unorm: r.UNSIGNED_INT_2_10_10_10_REV, rg11b10ufloat: r.UNSIGNED_INT_10F_11F_11F_REV, rg32uint: r.UNSIGNED_INT, rg32sint: r.INT, rg32float: r.FLOAT, rgba16uint: r.UNSIGNED_SHORT, rgba16sint: r.SHORT, rgba16float: r.HALF_FLOAT, rgba32uint: r.UNSIGNED_INT, rgba32sint: r.INT, rgba32float: r.FLOAT, stencil8: r.UNSIGNED_BYTE, depth16unorm: r.UNSIGNED_SHORT, depth24plus: r.UNSIGNED_INT, "depth24plus-stencil8": r.UNSIGNED_INT_24_8, depth32float: r.FLOAT, "depth32float-stencil8": r.FLOAT_32_UNSIGNED_INT_24_8_REV } } var Dg = m(() => { "use strict"; c(Ad, "mapFormatToGlType") }); function Eb (r) { r instanceof Uint8ClampedArray && (r = new Uint8Array(r.buffer)); let t = r.length; for (let e = 0; e < t; e += 4) { let s = r[e + 3]; if (s !== 0) { let o = 255.001 / s; r[e] = r[e] * o + .5, r[e + 1] = r[e + 1] * o + .5, r[e + 2] = r[e + 2] * o + .5 } } } var Lg = m(() => { "use strict"; c(Eb, "unpremultiplyAlpha") }); var zT, fo, Hg = m(() => { ft(); S(); rt(); Rg(); Mg(); Gg(); Sd(); Ug(); Ig(); Og(); kg(); Dg(); Lg(); zT = 4, fo = class { constructor(t) { this.managedTextures = [], this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = Object.create(null), this._uploads = { image: Wn, buffer: yd, video: Td, compressed: vd }, this._useSeparateSamplers = !1, this._renderer = t } contextChange (t) { this._gl = t, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = Bd(t, this._renderer.context.extensions), this._mapFormatToType = Ad(t), this._mapFormatToFormat = Cd(t)), this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundSamplers = Object.create(null); for (let e = 0; e < 16; e++)this.bind(E.EMPTY, e) } initSource (t) { this.bind(t) } bind (t, e = 0) { let s = t.source; t ? (this.bindSource(s, e), this._useSeparateSamplers && this._bindSampler(s.style, e)) : (this.bindSource(null, e), this._useSeparateSamplers && this._bindSampler(null, e)) } bindSource (t, e = 0) { let s = this._gl; if (t._touched = this._renderer.textureGC.count, this._boundTextures[e] !== t) { this._boundTextures[e] = t, this._activateLocation(e), t = t || E.EMPTY.source; let o = this.getGlSource(t); s.bindTexture(o.target, o.texture) } } _bindSampler (t, e = 0) { let s = this._gl; if (!t) { this._boundSamplers[e] = null, s.bindSampler(e, null); return } let o = this._getGlSampler(t); this._boundSamplers[e] !== o && (this._boundSamplers[e] = o, s.bindSampler(e, o)) } unbind (t) { let e = t.source, s = this._boundTextures, o = this._gl; for (let i = 0; i < s.length; i++)if (s[i] === e) { this._activateLocation(i); let n = this.getGlSource(e); o.bindTexture(n.target, null), s[i] = null } } _activateLocation (t) { this._activeTextureLocation !== t && (this._activeTextureLocation = t, this._gl.activeTexture(this._gl.TEXTURE0 + t)) } _initSource (t) { let e = this._gl, s = new si(e.createTexture()); if (s.type = this._mapFormatToType[t.format], s.internalFormat = this._mapFormatToInternalFormat[t.format], s.format = this._mapFormatToFormat[t.format], t.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) { let o = Math.max(t.width, t.height); t.mipLevelCount = Math.floor(Math.log2(o)) + 1 } return this._glTextures[t.uid] = s, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, !1), s } onStyleChange (t) { this.updateStyle(t, !1) } updateStyle (t, e) { let s = this._gl, o = this.getGlSource(t); s.bindTexture(s.TEXTURE_2D, o.texture), this._boundTextures[this._activeTextureLocation] = t, ac(t.style, s, t.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", s.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo, e) } onSourceUnload (t) { let e = this._glTextures[t.uid]; e && (this.unbind(t), this._glTextures[t.uid] = null, this._gl.deleteTexture(e.texture)) } onSourceUpdate (t) { let e = this._gl, s = this.getGlSource(t); e.bindTexture(e.TEXTURE_2D, s.texture), this._boundTextures[this._activeTextureLocation] = t, this._uploads[t.uploadMethodId] ? this._uploads[t.uploadMethodId].upload(t, s, e, this._renderer.context.webGLVersion) : e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t.pixelWidth, t.pixelHeight, 0, e.RGBA, e.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, !1) } onUpdateMipmaps (t, e = !0) { e && this.bindSource(t, 0); let s = this.getGlSource(t); this._gl.generateMipmap(s.target) } onSourceDestroy (t) { t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t) } _initSampler (t) { let e = this._gl, s = this._gl.createSampler(); return this._glSamplers[t._resourceId] = s, ac(t, e, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", s, !1, !0), this._glSamplers[t._resourceId] } _getGlSampler (t) { return this._glSamplers[t._resourceId] || this._initSampler(t) } getGlSource (t) { return this._glTextures[t.uid] || this._initSource(t) } generateCanvas (t) { let { pixels: e, width: s, height: o } = this.getPixels(t), i = k.get().createCanvas(); i.width = s, i.height = o; let n = i.getContext("2d"); if (n) { let a = n.createImageData(s, o); a.data.set(e), n.putImageData(a, 0, 0) } return i } getPixels (t) { let e = t.source.resolution, s = t.frame, o = Math.max(Math.round(s.width * e), 1), i = Math.max(Math.round(s.height * e), 1), n = new Uint8Array(zT * o * i), a = this._renderer, l = a.renderTarget.getRenderTarget(t), h = a.renderTarget.getGpuRenderTarget(l), u = a.gl; return u.bindFramebuffer(u.FRAMEBUFFER, h.resolveTargetFramebuffer), u.readPixels(Math.round(s.x * e), Math.round(s.y * e), o, i, u.RGBA, u.UNSIGNED_BYTE, n), { pixels: new Uint8ClampedArray(n.buffer), width: o, height: i } } destroy () { this.managedTextures.slice().forEach(t => this.onSourceDestroy(t)), this.managedTextures = null, this._renderer = null } }; c(fo, "GlTextureSystem"); fo.extension = { type: [x.WebGLSystem], name: "texture" } }); var m0 = {}; c_(m0, { WebGLRenderer: () => zn }); var VT, YT, $T, d0, f0, p0, zn, Ng = m(() => { S(); jx(); Kx(); qx(); Mn(); Uh(); Re(); Jx(); tg(); sg(); og(); ig(); ng(); ag(); ug(); fg(); Eg(); Bg(); wg(); Hg(); VT = [...Fn, co, ed, Qh, so, fo, lo, oo, ho, uo, no, bd, ao, io], YT = [...In], $T = [ro, eo, to], d0 = [], f0 = [], p0 = []; I.handleByNamedList(x.WebGLSystem, d0); I.handleByNamedList(x.WebGLPipes, f0); I.handleByNamedList(x.WebGLPipesAdaptor, p0); I.add(...VT, ...YT, ...$T); zn = class extends nr { constructor() { let t = { name: "webgl", type: yt.WEBGL, systems: d0, renderPipes: f0, renderPipeAdaptors: p0 }; super(t) } }; c(zn, "WebGLRenderer") }); var Q1 = {}; c_(Q1, { AbstractBitmapFont: () => Cr, AbstractRenderer: () => nr, AbstractText: () => Xe, AccessibilitySystem: () => Lr, AlphaFilter: () => Vb, AlphaMask: () => $r, AlphaMaskPipe: () => Os, AnimatedSprite: () => ur, Application: () => Wg, Assets: () => Kn, AssetsClass: () => qn, BLEND_TO_NPM: () => wl, BUFFER_TYPE: () => Qo, BackgroundLoader: () => oi, BackgroundSystem: () => Ph, Batch: () => Mo, BatchGeometry: () => gr, BatchTextureArray: () => ts, BatchableGraphics: () => Qe, BatchableMesh: () => Ie, BatchableSprite: () => Oe, Batcher: () => Ui, BatcherPipe: () => Is, BigPool: () => Y, BindGroup: () => Rt, BindGroupSystem: () => Ws, BitmapFont: () => hs, BitmapFontManager: () => Br, BitmapText: () => li, BitmapTextPipe: () => _s, BlendModeFilter: () => X, BlendModePipe: () => Ls, BlurFilter: () => oa, BlurFilterPass: () => sa, Bounds: () => it, BrowserAdapter: () => fl, Buffer: () => _t, BufferImageSource: () => je, BufferResource: () => Ne, BufferUsage: () => K, CLEAR: () => Ut, Cache: () => tt, CanvasPool: () => ie, CanvasPoolClass: () => Vi, CanvasSource: () => se, CanvasTextMetrics: () => Kt, CanvasTextPipe: () => os, CanvasTextSystem: () => ls, Circle: () => yr, Color: () => j, ColorBlend: () => ln, ColorBurnBlend: () => un, ColorDodgeBlend: () => hn, ColorMask: () => jr, ColorMaskPipe: () => ks, ColorMatrixFilter: () => vc, CompressedSource: () => ge, Container: () => N, Culler: () => Qd, CullerPlugin: () => ea, CustomRenderPipe: () => Rs, DATA_URI: () => dy, DDS: () => W, DEG_TO_RAD: () => Xc, DEPRECATED_SCALE_MODES: () => Ac, DEPRECATED_WRAP_MODES: () => Bc, DOMAdapter: () => k, DRAW_MODES: () => ty, DXGI_TO_TEXTURE_FORMAT: () => Qt, DarkenBlend: () => dn, DifferenceBlend: () => fn, DisplacementFilter: () => Tc, DivideBlend: () => pn, DynamicBitmapFont: () => us, Ellipse: () => vr, EventBoundary: () => Co, EventEmitter: () => z0.default, EventSystem: () => Ti, EventsTicker: () => ye, ExclusionBlend: () => mn, ExtensionType: () => x, ExtractSystem: () => Bh, FOURCC_TO_TEXTURE_FORMAT: () => xc, FederatedContainer: () => dl, FederatedEvent: () => de, FederatedMouseEvent: () => ve, FederatedPointerEvent: () => kt, FederatedWheelEvent: () => fe, FillGradient: () => is, FillPattern: () => Tr, Filter: () => Nt, FilterEffect: () => Ue, FilterPipe: () => Ts, FilterSystem: () => Es, FontStylePromiseCache: () => nn, GAUSSIAN_VALUES: () => ra, GL_FORMATS: () => Hn, GL_INTERNAL_FORMAT: () => t_, GL_TARGETS: () => ec, GL_TYPES: () => st, GL_WRAP_MODES: () => eg, GenerateTextureSystem: () => Hs, Geometry: () => oe, GlBackBufferSystem: () => ed, GlBatchAdaptor: () => ro, GlBuffer: () => Jo, GlBufferSystem: () => so, GlColorMaskSystem: () => io, GlContextSystem: () => Qh, GlEncoderSystem: () => no, GlGeometrySystem: () => oo, GlGraphicsAdaptor: () => to, GlMeshAdaptor: () => eo, GlProgram: () => bt, GlProgramData: () => ri, GlRenderTarget: () => ti, GlRenderTargetAdaptor: () => ei, GlRenderTargetSystem: () => lo, GlShaderSystem: () => uo, GlStateSystem: () => bd, GlStencilSystem: () => ao, GlTexture: () => si, GlTextureSystem: () => fo, GlUboSystem: () => co, GlUniformGroupSystem: () => ho, GlobalUniformSystem: () => Ns, GpuBatchAdaptor: () => ws, GpuBlendModesToPixi: () => ae, GpuBufferSystem: () => Xs, GpuColorMaskSystem: () => zs, GpuDeviceSystem: () => Fr, GpuEncoderSystem: () => Vs, GpuGraphicsAdaptor: () => Bs, GpuGraphicsContext: () => Ni, GpuMeshAdapter: () => As, GpuMipmapGenerator: () => Zo, GpuProgram: () => ht, GpuReadBuffer: () => Jb, GpuRenderTarget: () => Ko, GpuRenderTargetAdaptor: () => qo, GpuRenderTargetSystem: () => qs, GpuShaderSystem: () => Zs, GpuStateSystem: () => Qs, GpuStencilModesToPixi: () => We, GpuStencilSystem: () => Ys, GpuTextureSystem: () => Js, GpuUboSystem: () => $s, GpuUniformBatchPipe: () => js, Graphics: () => Ee, GraphicsContext: () => Vt, GraphicsContextRenderData: () => Wi, GraphicsContextSystem: () => es, GraphicsPath: () => ne, GraphicsPipe: () => rs, HTMLText: () => ui, HTMLTextPipe: () => bs, HTMLTextRenderData: () => Ar, HTMLTextStyle: () => ue, HTMLTextSystem: () => wr, HardLightBlend: () => xn, HardMixBlend: () => gn, HelloSystem: () => Ur, IGLUniformData: () => sc, ImageSource: () => jt, InstructionSet: () => hr, KTX: () => St, LightenBlend: () => _n, LinearBurnBlend: () => bn, LinearDodgeBlend: () => yn, LinearLightBlend: () => vn, Loader: () => ii, LoaderParserPriority: () => mt, LuminosityBlend: () => Sn, MAX_TEXTURES: () => Mt, MSAA_QUALITY: () => s_, MaskEffectManager: () => yi, MaskEffectManagerClass: () => bi, MaskFilter: () => Xo, Matrix: () => B, Mesh: () => _e, MeshGeometry: () => qt, MeshPipe: () => ss, MeshPlane: () => Mc, MeshRope: () => ly, MeshSimple: () => Gc, NOOP: () => pa, NegationBlend: () => Tn, NineSliceGeometry: () => Le, NineSlicePlane: () => Uc, NineSliceSprite: () => o_, NineSliceSpritePipe: () => Ss, NoiseFilter: () => Yb, ObservablePoint: () => at, OverlayBlend: () => En, PI_2: () => Nc, PinLightBlend: () => Pn, PipelineSystem: () => Ks, PlaneGeometry: () => cn, Point: () => V, Polygon: () => ke, Pool: () => Ve, PoolGroupClass: () => _i, PrepareBase: () => uf, PrepareQueue: () => ci, PrepareSystem: () => ia, PrepareUpload: () => hi, QuadGeometry: () => No, RAD_TO_DEG: () => Wc, Rectangle: () => H, RenderContainer: () => Rc, RenderGroup: () => So, RenderGroupPipe: () => Ms, RenderGroupSystem: () => Us, RenderTarget: () => Vo, RenderTargetSystem: () => Or, RenderTexture: () => zo, RendererType: () => yt, ResizePlugin: () => Hr, Resolver: () => Dt, RopeGeometry: () => df, RoundedRectangle: () => Sr, SCALE_MODES: () => sy, STENCIL_MODES: () => xt, SVGParser: () => ou, SVGToGraphicsPath: () => $l, SaturationBlend: () => Cn, ScissorMask: () => Cc, SdfShader: () => Do, Shader: () => dt, ShaderStage: () => ds, ShapePath: () => Uo, SharedRenderPipes: () => In, SharedSystems: () => Fn, SoftLightBlend: () => Bn, Sprite: () => wt, SpritePipe: () => Fs, Spritesheet: () => xa, State: () => Pt, StencilMask: () => Kr, StencilMaskPipe: () => Ds, SubtractBlend: () => An, SystemRunner: () => Gr, TEXTURE_FORMAT_BLOCK_SIZE: () => Vd, Text: () => kr, TextStyle: () => Ht, Texture: () => E, TextureGCSystem: () => Ka, TextureMatrix: () => pr, TexturePool: () => gt, TexturePoolClass: () => $i, TextureSource: () => J, TextureStyle: () => _l, TextureUvs: () => wc, Ticker: () => Bt, TickerListener: () => dr, TickerPlugin: () => Nr, TilingSprite: () => hf, TilingSpritePipe: () => vs, TilingSpriteShader: () => Ho, Transform: () => ai, Triangle: () => ni, UNIFORM_TO_ARRAY_SETTERS: () => xd, UNIFORM_TO_SINGLE_SETTERS: () => md, UPDATE_BLEND: () => ua, UPDATE_COLOR: () => Si, UPDATE_PRIORITY: () => re, UPDATE_TRANSFORM: () => x_, UPDATE_VISIBLE: () => To, UboBatch: () => $o, UboSystem: () => Ir, UniformGroup: () => et, VERSION: () => Ah, VideoSource: () => qr, ViewSystem: () => Gh, ViewableBuffer: () => Qr, VividLightBlend: () => wn, WGSL_ALIGN_SIZE_DATA: () => Yo, WGSL_TO_STD40_SIZE: () => rc, WRAP_MODES: () => ry, WebGLRenderer: () => zn, WebGPURenderer: () => Ln, WebWorkerAdapter: () => zb, WorkerManager: () => hc, _getGlobalBounds: () => Qc, _getGlobalBoundsRecursive: () => ah, accessibilityTarget: () => nl, addBits: () => Ia, addMaskBounds: () => Vr, addMaskLocalBounds: () => Yr, addProgramDefines: () => _u, alphaFrag: () => Jd, alphaWgsl: () => bc, applyMatrix: () => rh, applyStyleParams: () => ac, assignWithIgnore: () => ol, autoDetectEnvironment: () => dh, autoDetectRenderer: () => wd, autoDetectSource: () => tp, basisTranscoderUrls: () => Qn, batchSamplersUniformGroup: () => gs, bitmapFontCachePlugin: () => fu, bitmapFontTextParser: () => rn, bitmapFontXMLParser: () => Ua, bitmapFontXMLStringParser: () => Fa, blendTemplateFrag: () => lh, blendTemplateVert: () => uh, blendTemplateWgsl: () => hh, blockDataMap: () => tc, blurTemplateWgsl: () => sf, boundsPool: () => ee, browserExt: () => Lm, buildAdaptiveBezier: () => Ki, buildAdaptiveQuadratic: () => ql, buildArc: () => qi, buildArcTo: () => Ql, buildArcToSvg: () => tu, buildCircle: () => Je, buildContextBatches: () => zl, buildGeometryFromPath: () => cy, buildInstructions: () => yh, buildLine: () => Ll, buildPolygon: () => Di, buildRectangle: () => Li, buildSimpleUvs: () => Ii, buildTriangle: () => Hi, buildUvs: () => Fi, cacheTextureArray: () => Rd, calculateProjection: () => Vh, checkChildrenDidChange: () => la, checkDataUrl: () => he, checkExtension: () => vt, childrenHelperMixin: () => $c, closePointEps: () => kl, collectAllRenderables: () => Gs, collectRenderGroups: () => Xa, color32BitToUniform: () => tr, colorBit: () => fs, colorBitGl: () => ps, colorMatrixFilterFrag: () => nf, colorMatrixFilterWgsl: () => yc, colorToUniform: () => I_, compareModeToGlCompare: () => Pd, compileHighShader: () => Au, compileHighShaderGl: () => wu, compileHighShaderGlProgram: () => Be, compileHighShaderGpuProgram: () => Ce, compileHooks: () => Oa, compileInputs: () => ka, compileOutputs: () => Bu, compileShader: () => oc, convertFillInputToFillStyle: () => Te, convertFormatIfRequired: () => kb, convertToList: () => Xt, copySearchParams: () => Bo, createIdFromString: () => er, createLevelBuffers: () => Rb, createLevelBuffersFromKTX: () => Db, createStringVariations: () => ml, createTexture: () => Zt, createUboElementsSTD40: () => rd, createUboElementsWGSL: () => Ih, createUboSyncFunction: () => On, createUboSyncFunctionSTD40: () => id, createUboSyncFunctionWGSL: () => Wh, crossOrigin: () => Yg, cullingMixin: () => Hc, curveEps: () => Ta, defaultFilterVert: () => xo, defaultValue: () => Nn, definedProps: () => me, deprecation: () => w, detectAvif: () => Md, detectBasis: () => Bb, detectCompressed: () => Wb, detectDefaults: () => Gd, detectMp4: () => Ud, detectOgv: () => Fd, detectVideoAlphaMode: () => Gi, detectWebm: () => Id, detectWebp: () => Od, determineCrossOrigin: () => jg, displacementFrag: () => af, displacementVert: () => cf, displacementWgsl: () => Sc, earcut: () => V0.default, effectsMixin: () => qc, ensureAttributes: () => kn, ensureIsBuffer: () => ya, ensureOptions: () => go, ensurePrecision: () => bu, ensureTextStyle: () => hy, executeInstructions: () => Gn, extensions: () => I, extractAttributesFromGlProgram: () => ud, extractAttributesFromGpuProgram: () => Tu, extractFontFamilies: () => Vu, extractStructAndGroups: () => on, fastCopy: () => Ro, findHooksRx: () => sm, findMixin: () => Zc, fontStringFromTextStyle: () => Pr, formatShader: () => qb, fragmentGPUTemplate: () => Mu, fragmentGlTemplate: () => Uu, generateArraySyncSTD40: () => od, generateArraySyncWGSL: () => Nh, generateBlurFragSource: () => tf, generateBlurGlProgram: () => rf, generateBlurProgram: () => of, generateBlurVertSource: () => ef, generateGPULayout: () => jb, generateGpuLayoutGroups: () => Eu, generateLayout: () => Kb, generateLayoutHash: () => Pu, generateProgram: () => pd, generateShaderSyncCode: () => nd, generateTextStyleKey: () => Zi, generateTextureBatchBit: () => ms, generateTextureBatchBitGl: () => xs, generateUID: () => oy, generateUniformsSync: () => gd, getAdjustedBlendModeBlend: () => Sa, getAttributeInfoFromFormat: () => De, getBitmapTextLayout: () => en, getCanvasBoundingBox: () => Yl, getCanvasFillStyle: () => cs, getCanvasTexture: () => Un, getDefaultUniformValue: () => Vl, getFastGlobalBounds: () => nh, getFontCss: () => $u, getFontFamilyName: () => Xg, getGeometryBounds: () => Cl, getGlTypeFromFormat: () => td, getGlobalBounds: () => Ye, getGlobalRenderableBounds: () => ch, getLocalBounds: () => Dr, getMatrixRelativeToParent: () => Tl, getMaxFragmentPrecision: () => gu, getOrientationOfPoints: () => Dl, getParent: () => Sf, getPo2TextureFromSource: () => Qi, getResolutionOfUrl: () => mo, getSVGUrl: () => ju, getSupportedCompressedTextureFormats: () => Zn, getSupportedGPUCompressedTextureFormats: () => fc, getSupportedGlCompressedTextureFormats: () => dc, getSupportedTextureFormats: () => lr, getTemporaryCanvasFromImage: () => Ku, getTestContext: () => xu, getTextureBatchBindGroup: () => Zr, getTextureDefaultMatrix: () => uy, getTextureFormatFromKTXTexture: () => Lb, getUboData: () => hd, getUniformData: () => dd, getUrlExtension: () => Wf, glFormatToGPUFormat: () => qd, glUploadBufferImageResource: () => yd, glUploadCompressedTextureResource: () => vd, glUploadImageResource: () => Wn, glUploadVideoResource: () => Td, globalUniformsBit: () => Fu, globalUniformsBitGl: () => Iu, globalUniformsUBOBitGl: () => tb, gpuFormatToBasisTranscoderFormat: () => Mb, gpuFormatToKTXBasisTranscoderFormat: () => Hb, gpuUploadBufferImageResource: () => jh, gpuUploadCompressedTextureResource: () => Kh, gpuUploadImageResource: () => Dn, gpuUploadVideoResource: () => Zh, groupD8: () => Q, hasCachedCanvasTexture: () => _b, hslWgsl: () => $b, hslgl: () => Ps, hslgpu: () => Cs, injectBits: () => Da, insertVersion: () => yu, isMobile: () => il, isPow2: () => ma, isRenderingToScreen: () => Yh, isSafari: () => Hu, isSingleItem: () => fr, isWebGLSupported: () => ar, isWebGPUSupported: () => cr, ktxTranscoderUrls: () => Jn, loadBasis: () => wb, loadBasisOnWorker: () => zd, loadBitmapFont: () => pu, loadDDS: () => Gb, loadFontAsBase64: () => Yu, loadFontCSS: () => Na, loadImageBitmap: () => Vg, loadJson: () => kd, loadKTX: () => Ub, loadKTX2: () => Ib, loadKTX2onWorker: () => Kd, loadSVGImage: () => qu, loadSvg: () => Hd, loadTextures: () => $n, loadTxt: () => Dd, loadVideoTextures: () => Nd, loadWebFont: () => Ld, localUniformBit: () => Mr, localUniformBitGl: () => ys, localUniformBitGroup2: () => Qu, localUniformMSDFBit: () => Ou, localUniformMSDFBitGl: () => ku, log2: () => S_, logDebugTexture: () => fy, logProgramError: () => fd, logRenderGroupScene: () => n_, logScene: () => i_, mSDFBit: () => Du, mSDFBitGl: () => Lu, mapFormatToGlFormat: () => Cd, mapFormatToGlInternalFormat: () => Bd, mapFormatToGlType: () => Ad, mapGlToVertexFormat: () => cd, mapSize: () => Qb, mapType: () => ic, mapWebGLBlendModesToPixi: () => _d, maskFrag: () => Th, maskVert: () => Eh, maskWgsl: () => ja, matrixPool: () => le, measureHtmlText: () => an, measureMixin: () => Jc, migrateFragmentFromV7toV8: () => Zb, mipmapScaleModeToGlFilter: () => Ed, mixColors: () => Ya, mixHexColors: () => za, mixStandardAnd32BitColors: () => fb, multiplyHexColors: () => Fl, nextPow2: () => Fe, noiseFrag: () => lf, noiseWgsl: () => Ec, nonCompressedFormats: () => Jg, normalizeExtensionPriority: () => xi, nssvg: () => Nu, nsxhtml: () => Wu, onRenderMixin: () => tl, parseDDS: () => Yd, parseFunctionBody: () => iy, parseKTX: () => $d, path: () => At, pointInTriangle: () => Pc, preloadVideo: () => $g, removeItems: () => gi, removeStructAndGroupDuplicates: () => Cu, resetUids: () => h_, resolveCharacters: () => tn, resolveCompressedTextureUrl: () => Nb, resolveJsonUrl: () => Wd, resolveTextureUrl: () => jn, resourceToTexture: () => ep, roundPixelsBit: () => Ae, roundPixelsBitGl: () => we, roundedShapeArc: () => eu, roundedShapeQuadraticCurve: () => ru, sayHello: () => wh, scaleModeToGlFilter: () => nc, setBasisTranscoderPath: () => Ab, setKTXTranscoderPath: () => Fb, setPositions: () => eh, setProgramName: () => vu, setUvs: () => sh, sortMixin: () => el, spritesheetAsset: () => Sl, squaredDistanceToLineSegment: () => ns, stripVersion: () => Su, testImageFormat: () => Vn, testVideoFormat: () => po, textStyleToCSS: () => zu, textureBit: () => xh, textureBitGl: () => gh, textureFrom: () => rp, tilingBit: () => Ju, tilingBitGl: () => th, toLocalGlobalMixin: () => rl, transformVertices: () => Go, triangulateWithHoles: () => ki, uboSyncFunctionsSTD40: () => Qa, uboSyncFunctionsWGSL: () => Lh, uid: () => Z, uniformParsers: () => He, unpremultiplyAlpha: () => Eb, unsafeEvalSupported: () => Rn, updateLocalTransform: () => ny, updateQuadBounds: () => mr, updateRenderGroupTransform: () => Qm, updateRenderGroupTransforms: () => $a, updateTransformAndChildren: () => vh, updateTransformBackwards: () => yo, updateWorldTransform: () => ay, v8_0_0: () => G, validFormats: () => ta, validateRenderables: () => Sh, vertexGPUTemplate: () => Ru, vertexGlTemplate: () => Gu, viewportFromFrame: () => ey, vkFormatToGPUFormat: () => Zd, warn: () => U, webworkerExt: () => Hm, wrapModeToGlAddress: () => Xn }); S(); var Lm = { extension: { type: x.Environment, name: "browser", priority: -1 }, test: () => !0, load: async () => { await Promise.resolve().then(() => (Lv(), fT)) } }; S(); var Hm = { extension: { type: x.Environment, name: "webworker", priority: 0 }, test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0, load: async () => { await Promise.resolve().then(() => (Hv(), pT)) } }; S(); S(); op(); jf(); Gf(); Uf(); S(); xe(); Pe(); Ot(); rt(); ir(); var lh = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uBlend;

uniform sampler2D uTexture;
uniform sampler2D uBackTexture;

{FUNCTIONS}

void main()
{ 
    vec4 back = texture(uBackTexture, vTextureCoord);
    vec4 front = texture(uTexture, vTextureCoord);

    {MAIN}
}
`; var uh = `in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 backgroundUv;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`; var hh = `
struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlendUniforms {
  uBlend:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;
@group(0) @binding(3) var uBackTexture: texture_2d<f32>;

@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

{FUNCTIONS}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>
) -> @location(0) vec4<f32> {


   var back =  textureSample(uBackTexture, uSampler, uv);
   var front = textureSample(uTexture, uSampler, uv);
   
   var out = vec4<f32>(0.0,0.0,0.0,0.0);

   {MAIN}

   return out;
}`; var X = class extends Nt { constructor(t) { let e = t.gpu, s = Wv({ source: hh, ...e }), o = ht.from({ vertex: { source: s, entryPoint: "mainVertex" }, fragment: { source: s, entryPoint: "mainFragment" } }), i = t.gl, n = Wv({ source: lh, ...i }), a = bt.from({ vertex: uh, fragment: n }), l = new et({ uBlend: { value: 1, type: "f32" } }); super({ gpuProgram: o, glProgram: a, blendRequired: !0, resources: { blendUniforms: l, uBackTexture: E.EMPTY } }) } }; c(X, "BlendModeFilter"); function Wv (r) { let { source: t, functions: e, main: s } = r; return t.replace("{FUNCTIONS}", e).replace("{MAIN}", s) } c(Wv, "compileBlendModeShader"); var Ps = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `; var Cs = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`; var ln = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                ${Ps}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                ${Cs}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(ln, "ColorBlend"); ln.extension = { name: "color", type: x.BlendMode }; S(); var un = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `}, gpu: {
                functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(un, "ColorBurnBlend"); un.extension = { name: "color-burn", type: x.BlendMode }; S(); var hn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(hn, "ColorDodgeBlend"); hn.extension = { name: "color-dodge", type: x.BlendMode }; S(); var dn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(dn, "DarkenBlend"); dn.extension = { name: "darken", type: x.BlendMode }; S(); var fn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `}, gpu: {
                functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(fn, "DifferenceBlend"); fn.extension = { name: "difference", type: x.BlendMode }; S(); var pn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(pn, "DivideBlend"); pn.extension = { name: "divide", type: x.BlendMode }; S(); var mn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(mn, "ExclusionBlend"); mn.extension = { name: "exclusion", type: x.BlendMode }; S(); var xn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `}, gpu: {
                functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(xn, "HardLightBlend"); xn.extension = { name: "hard-light", type: x.BlendMode }; S(); var gn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `}, gpu: {
                functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(gn, "HardMixBlend"); gn.extension = { name: "hard-mix", type: x.BlendMode }; S(); var _n = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(_n, "LightenBlend"); _n.extension = { name: "lighten", type: x.BlendMode }; S(); var bn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(bn, "LinearBurnBlend"); bn.extension = { name: "linear-burn", type: x.BlendMode }; S(); var yn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(yn, "LinearDodgeBlend"); yn.extension = { name: "linear-dodge", type: x.BlendMode }; S(); var vn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(vn, "LinearLightBlend"); vn.extension = { name: "linear-light", type: x.BlendMode }; S(); var Sn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                ${Ps}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                ${Cs}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(Sn, "LuminosityBlend"); Sn.extension = { name: "luminosity", type: x.BlendMode }; S(); var Tn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(Tn, "NegationBlend"); Tn.extension = { name: "negation", type: x.BlendMode }; S(); var En = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(En, "OverlayBlend"); En.extension = { name: "overlay", type: x.BlendMode }; S(); var Pn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(Pn, "PinLightBlend"); Pn.extension = { name: "pin-light", type: x.BlendMode }; S(); var Cn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                ${Ps}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `}, gpu: {
                functions: `
                ${Cs}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `, main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}
            })
          }
        }; c(Cn, "SaturationBlend"); Cn.extension = { name: "saturation", type: x.BlendMode }; S(); var Bn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(Bn, "SoftLightBlend"); Bn.extension = { name: "soft-light", type: x.BlendMode }; S(); var An = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `}, gpu: {
                functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(An, "SubtractBlend"); An.extension = { name: "subtract", type: x.BlendMode }; S(); var wn = class extends X {
          constructor() {
            super({
              gl: {
                functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `, main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `}, gpu: {
                functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `, main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}
            })
          }
        }; c(wn, "VividLightBlend"); wn.extension = { name: "vivid-light", type: x.BlendMode }; S(); S(); var hb = []; I.handleByNamedList(x.Environment, hb); async function dh (r) { if (r) for (let t = 0; t < hb.length; t++) { let e = hb[t]; if (e.value.test()) { await e.value.load(); return } } } c(dh, "autoDetectEnvironment"); ft(); Mn(); var Nm; function ar (r) { return Nm !== void 0 || (Nm = (() => { let t = { stencil: !0, failIfMajorPerformanceCaveat: r ?? nr.defaultOptions.failIfMajorPerformanceCaveat }; try { if (!k.get().getWebGLRenderingContext()) return !1; let s = k.get().createCanvas().getContext("webgl", t), o = !!s?.getContextAttributes()?.stencil; if (s) { let i = s.getExtension("WEBGL_lose_context"); i && i.loseContext() } return s = null, o } catch { return !1 } })()), Nm } c(ar, "isWebGLSupported"); ft(); var Wm; async function cr (r = {}) { return Wm !== void 0 || (Wm = await (async () => { if (!k.get().getNavigator().gpu) return !1; try { return await (await navigator.gpu.requestAdapter(r)).requestDevice(), !0 } catch { return !1 } })()), Wm } c(cr, "isWebGPUSupported"); Mn(); var x0 = ["webgl", "webgpu", "canvas"]; async function wd (r) { let t = []; r.preference ? (t.push(r.preference), x0.forEach(i => { i !== r.preference && t.push(i) })) : t = x0.slice(); let e; await dh(r.manageImports ?? !0); let s = {}; for (let i = 0; i < t.length; i++) { let n = t[i]; if (n === "webgpu" && await cr()) { let { WebGPURenderer: a } = await Promise.resolve().then(() => ($x(), i0)); e = a, s = { ...r, ...r.webgpu }; break } else if (n === "webgl" && ar(r.failIfMajorPerformanceCaveat ?? nr.defaultOptions.failIfMajorPerformanceCaveat)) { let { WebGLRenderer: a } = await Promise.resolve().then(() => (Ng(), m0)); e = a, s = { ...r, ...r.webgl }; break } else if (n === "canvas") throw s = { ...r }, new Error("CanvasRenderer is not yet implemented") } if (delete s.webgpu, delete s.webgl, !e) throw new Error("No available renderer for the current environment"); let o = new e; return await o.init(s), o } c(wd, "autoDetectRenderer"); It(); lt(); var g0 = c(class Pb { constructor(...t) { this.stage = new N, t[0] !== void 0 && w(G, "Application constructor options are deprecated, please use Application.init() instead.") } async init (t) { t = { ...t }, this.renderer = await wd(t), Pb._plugins.forEach(e => { e.init.call(this, t) }) } render () { this.renderer.render({ container: this.stage }) } get canvas () { return this.renderer.canvas } get view () { return w(G, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas } get screen () { return this.renderer.screen } destroy (t = !1, e = !1) { let s = Pb._plugins.slice(0); s.reverse(), s.forEach(o => { o.destroy.call(this) }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null } }, "_Application"); g0._plugins = []; var Wg = g0; I.handleByList(x.Application, Wg._plugins); Ff(); Of(); S(); ut(); var oi = class { constructor(t, e = !1) { this._loader = t, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = e } add (t) { t.forEach(e => { this._assetList.push(e) }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next() } async _next () { if (this._assetList.length && this._isActive) { this._isLoading = !0; let t = [], e = Math.min(this._assetList.length, this._maxConcurrent); for (let s = 0; s < e; s++)t.push(this._assetList.pop()); await this._loader.load(t), this._isLoading = !1, this._next() } } get active () { return this._isActive } set active (t) { this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next()) } }; c(oi, "BackgroundLoader"); Ke(); S(); rt(); var Rd = { extension: x.CacheParser, test: r => Array.isArray(r) && r.every(t => t instanceof E), getCacheableAssets: (r, t) => { let e = {}; return r.forEach(s => { t.forEach((o, i) => { e[s + (i === 0 ? "" : i + 1)] = o }) }), e } }; S(); async function Vn (r) { if ("Image" in globalThis) return new Promise(t => { let e = new Image; e.onload = () => { t(!0) }, e.onerror = () => { t(!1) }, e.src = r }); if ("createImageBitmap" in globalThis && "fetch" in globalThis) { try { let t = await (await fetch(r)).blob(); await createImageBitmap(t) } catch { return !1 } return !0 } return !1 } c(Vn, "testImageFormat"); var Md = { extension: { type: x.DetectionParser, priority: 1 }, test: async () => Vn("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="), add: async r => [...r, "avif"], remove: async r => r.filter(t => t !== "avif") }; S(); var _0 = ["png", "jpg", "jpeg"], Gd = { extension: { type: x.DetectionParser, priority: -1 }, test: () => Promise.resolve(!0), add: async r => [...r, ..._0], remove: async r => r.filter(t => !_0.includes(t)) }; S(); var jT = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope; function po (r) { return jT ? !1 : document.createElement("video").canPlayType(r) !== "" } c(po, "testVideoFormat"); var Ud = { extension: { type: x.DetectionParser, priority: 0 }, test: async () => po("video/mp4"), add: async r => [...r, "mp4", "m4v"], remove: async r => r.filter(t => t !== "mp4" && t !== "m4v") }; S(); var Fd = { extension: { type: x.DetectionParser, priority: 0 }, test: async () => po("video/ogg"), add: async r => [...r, "ogv"], remove: async r => r.filter(t => t !== "ogv") }; S(); var Id = { extension: { type: x.DetectionParser, priority: 0 }, test: async () => po("video/webm"), add: async r => [...r, "webm"], remove: async r => r.filter(t => t !== "webm") }; S(); var Od = { extension: { type: x.DetectionParser, priority: 0 }, test: async () => Vn("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="), add: async r => [...r, "webp"], remove: async r => r.filter(t => t !== "webp") }; ut(); Wr(); Ei(); fa(); var ii = class {
          constructor() { this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, { set: (t, e, s) => (this._parsersValidated = !1, t[e] = s, !0) }), this.promiseCache = {} } reset () { this._parsersValidated = !1, this.promiseCache = {} } _getLoadPromiseAndParser (t, e) { let s = { promise: null, parser: null }; return s.promise = (async () => { let o = null, i = null; if (e.loadParser && (i = this._parserHash[e.loadParser], i || U(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)), !i) { for (let n = 0; n < this.parsers.length; n++) { let a = this.parsers[n]; if (a.load && a.test?.(t, e, this)) { i = a; break } } if (!i) return U(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null } o = await i.load(t, e, this), s.parser = i; for (let n = 0; n < this.parsers.length; n++) { let a = this.parsers[n]; a.parse && a.parse && await a.testParse?.(o, e, this) && (o = await a.parse(o, e, this) || o, s.parser = a) } return o })(), s } async load (t, e) {
            this._parsersValidated || this._validateParsers(); let s = 0, o = {}, i = fr(t), n = Xt(t, h => ({ alias: [h], src: h })), a = n.length, l = n.map(async h => {
              let u = At.toAbsolute(h.src); if (!o[h.src]) try { this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, h)), o[h.src] = await this.promiseCache[u].promise, e && e(++s / a) } catch (d) {
                throw delete this.promiseCache[u], delete o[h.src], new Error(`[Loader.load] Failed to load ${u}.
${d}`)
              }
            }); return await Promise.all(l), i ? o[n[0].src] : o
          } async unload (t) { let s = Xt(t, o => ({ alias: [o], src: o })).map(async o => { let i = At.toAbsolute(o.src), n = this.promiseCache[i]; if (n) { let a = await n.promise; delete this.promiseCache[i], await n.parser?.unload?.(a, o, this) } }); await Promise.all(s) } _validateParsers () { this._parsersValidated = !0, this._parserHash = this._parsers.filter(t => t.name).reduce((t, e) => (e.name ? t[e.name] && U(`[Assets] loadParser name conflict "${e.name}"`) : U("[Assets] loadParser should have a name"), { ...t, [e.name]: e }), {}) }
        }; c(ii, "Loader"); ft(); S(); function he (r, t) { if (Array.isArray(t)) { for (let e of t) if (r.startsWith(`data:${e}`)) return !0; return !1 } return r.startsWith(`data:${t}`) } c(he, "checkDataUrl"); Wr(); function vt (r, t) { let e = r.split("?")[0], s = At.extname(e).toLowerCase(); return Array.isArray(t) ? t.includes(s) : s === t } c(vt, "checkExtension"); pe(); var KT = ".json", qT = "application/json", kd = { extension: { type: x.LoadParser, priority: mt.Low }, name: "loadJson", test (r) { return he(r, qT) || vt(r, KT) }, async load (r) { return await (await k.get().fetch(r)).json() } }; ft(); S(); pe(); var ZT = ".txt", QT = "text/plain", Dd = { name: "loadTxt", extension: { type: x.LoadParser, priority: mt.Low }, test (r) { return he(r, QT) || vt(r, ZT) }, async load (r) { return await (await k.get().fetch(r)).text() } }; ft(); S(); ut(); Wr(); Ke(); pe(); var JT = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"], t1 = [".ttf", ".otf", ".woff", ".woff2"], e1 = ["font/ttf", "font/otf", "font/woff", "font/woff2"], r1 = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i; function Xg (r) { let t = At.extname(r), o = At.basename(r, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(a => a.charAt(0).toUpperCase() + a.slice(1)), i = o.length > 0; for (let a of o) if (!a.match(r1)) { i = !1; break } let n = o.join(" "); return i || (n = `"${n.replace(/[\\"]/g, "\\$&")}"`), n } c(Xg, "getFontFamilyName"); var s1 = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/; function o1 (r) { return s1.test(r) ? r : encodeURI(r) } c(o1, "encodeURIWhenNeeded"); var Ld = { extension: { type: x.LoadParser, priority: mt.Low }, name: "loadWebFont", test (r) { return he(r, e1) || vt(r, t1) }, async load (r, t) { let e = k.get().getFontFaceSet(); if (e) { let s = [], o = t.data?.family ?? Xg(r), i = t.data?.weights?.filter(a => JT.includes(a)) ?? ["normal"], n = t.data ?? {}; for (let a = 0; a < i.length; a++) { let l = i[a], h = new FontFace(o, `url(${o1(r)})`, { ...n, weight: l }); await h.load(), e.add(h), s.push(h) } return tt.set(`${o}-and-url`, { url: r, fontFaces: s }), s.length === 1 ? s[0] : s } return U("[loadWebFont] FontFace API is not supported. Skipping loading font"), null }, unload (r) { (Array.isArray(r) ? r : [r]).forEach(t => { tt.remove(t.family), k.get().getFontFaceSet().delete(t) }) } }; ft(); S(); Ao(); Fo(); Xr(); function mo (r, t = 1) { let e = Dt.RETINA_PREFIX?.exec(r); return e ? parseFloat(e[1]) : t } c(mo, "getResolutionOfUrl"); pe(); rt(); ut(); Ke(); function Zt (r, t, e) { r.label = e, r._sourceOrigin = e; let s = new E({ source: r, label: e }), o = c(() => { delete t.promiseCache[e], tt.has(e) && tt.remove(e) }, "unload"); return s.source.once("destroy", () => { t.promiseCache[e] && (U("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), o()) }), s.once("destroy", () => { r.destroyed || (U("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), o()) }), s } c(Zt, "createTexture"); var i1 = ".svg", n1 = "image/svg+xml", Hd = { extension: { type: x.LoadParser, priority: mt.Low }, name: "loadSVG", config: { crossOrigin: "anonymous", parseAsGraphicsContext: !1 }, test (r) { return he(r, n1) || vt(r, i1) }, async load (r, t, e) { return t.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? c1(r) : a1(r, t, e, this.config.crossOrigin) }, unload (r) { r.destroy(!0) } }; async function a1 (r, t, e, s) { let i = await (await k.get().fetch(r)).blob(), n = URL.createObjectURL(i), a = new Image; a.src = n, a.crossOrigin = s, await a.decode(), URL.revokeObjectURL(n); let l = document.createElement("canvas"), h = l.getContext("2d"), u = t.data?.resolution || mo(r), d = t.data?.width ?? a.width, f = t.data?.height ?? a.height; l.width = d * u, l.height = f * u, h.drawImage(a, 0, 0, d * u, f * u); let { parseAsGraphicsContext: p, ...g } = t.data, b = new jt({ resource: l, alphaMode: "premultiply-alpha-on-upload", resolution: u, ...g }); return Zt(b, e, r) } c(a1, "loadAsTexture"); async function c1 (r) { let e = await (await k.get().fetch(r)).text(), s = new Vt; return s.svg(e), s } c(c1, "loadAsGraphics"); ft(); S(); Ao(); var l1 = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`, cc = null, Yn = class { constructor() { cc || (cc = URL.createObjectURL(new Blob([l1], { type: "application/javascript" }))), this.worker = new Worker(cc) } }; c(Yn, "WorkerInstance"); Yn.revokeObjectURL = c(function () { cc && (URL.revokeObjectURL(cc), cc = null) }, "revokeObjectURL"); var u1 = `(function () {
    'use strict';

    async function loadImageBitmap(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      const imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap;
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`, lc = null, uc = class { constructor() { lc || (lc = URL.createObjectURL(new Blob([u1], { type: "application/javascript" }))), this.worker = new Worker(lc) } }; c(uc, "WorkerInstance"); uc.revokeObjectURL = c(function () { lc && (URL.revokeObjectURL(lc), lc = null) }, "revokeObjectURL"); var b0 = 0, Cb, zg = class { constructor() { this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {} } isImageBitmapSupported () { return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(t => { let { worker: e } = new Yn; e.addEventListener("message", s => { e.terminate(), Yn.revokeObjectURL(), t(s.data) }) }), this._isImageBitmapSupported) } loadImageBitmap (t) { return this._run("loadImageBitmap", [t]) } async _initWorkers () { this._initialized || (this._initialized = !0) } _getWorker () { Cb === void 0 && (Cb = navigator.hardwareConcurrency || 4); let t = this._workerPool.pop(); return !t && this._createdWorkers < Cb && (this._createdWorkers++, t = new uc().worker, t.addEventListener("message", e => { this._complete(e.data), this._returnWorker(e.target), this._next() })), t } _returnWorker (t) { this._workerPool.push(t) } _complete (t) { t.error !== void 0 ? this._resolveHash[t.uuid].reject(t.error) : this._resolveHash[t.uuid].resolve(t.data), this._resolveHash[t.uuid] = null } async _run (t, e) { await this._initWorkers(); let s = new Promise((o, i) => { this._queue.push({ id: t, arguments: e, resolve: o, reject: i }) }); return this._next(), s } _next () { if (!this._queue.length) return; let t = this._getWorker(); if (!t) return; let e = this._queue.pop(), s = e.id; this._resolveHash[b0] = { resolve: e.resolve, reject: e.reject }, t.postMessage({ data: e.arguments, uuid: b0++, id: s }) } }; c(zg, "WorkerManagerClass"); var hc = new zg; pe(); var h1 = [".jpeg", ".jpg", ".png", ".webp", ".avif"], d1 = ["image/jpeg", "image/png", "image/webp", "image/avif"]; async function Vg (r) { let t = await k.get().fetch(r); if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${r}: ${t.status} ${t.statusText}`); let e = await t.blob(); return await createImageBitmap(e) } c(Vg, "loadImageBitmap"); var $n = { name: "loadTextures", extension: { type: x.LoadParser, priority: mt.High }, config: { preferWorkers: !0, preferCreateImageBitmap: !0, crossOrigin: "anonymous" }, test (r) { return he(r, d1) || vt(r, h1) }, async load (r, t, e) { let s = null; globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await hc.isImageBitmapSupported() ? s = await hc.loadImageBitmap(r) : s = await Vg(r) : s = await new Promise(i => { s = new Image, s.crossOrigin = this.config.crossOrigin, s.src = r, s.complete ? i(s) : s.onload = () => { i(s) } }); let o = new jt({ resource: s, alphaMode: "premultiply-alpha-on-upload", resolution: t.data?.resolution || mo(r), ...t.data }); return Zt(o, e, r) }, unload (r) { r.destroy(!0) } }; S(); Pl(); El(); var y0 = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"], f1 = y0.map(r => `video/${r.substring(1)}`); function Yg (r, t, e) { e === void 0 && !t.startsWith("data:") ? r.crossOrigin = jg(t) : e !== !1 && (r.crossOrigin = typeof e == "string" ? e : "anonymous") } c(Yg, "crossOrigin"); function $g (r) { return new Promise((t, e) => { r.addEventListener("canplaythrough", s), r.addEventListener("error", o), r.load(); function s () { i(), t() } c(s, "loaded"); function o (n) { i(), e(n) } c(o, "error"); function i () { r.removeEventListener("canplaythrough", s), r.removeEventListener("error", o) } c(i, "cleanup") }) } c($g, "preloadVideo"); function jg (r, t = globalThis.location) { if (r.startsWith("data:")) return ""; t = t || globalThis.location; let e = new URL(r, document.baseURI); return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : "" } c(jg, "determineCrossOrigin"); var Nd = { name: "loadVideo", extension: { type: x.LoadParser }, config: null, test (r) { let t = he(r, f1), e = vt(r, y0); return t || e }, async load (r, t, e) { let s = { ...qr.defaultOptions, resolution: t.data?.resolution || mo(r), alphaMode: t.data?.alphaMode || await Gi(), ...t.data }, o = document.createElement("video"), i = { preload: s.autoLoad !== !1 ? "auto" : void 0, "webkit-playsinline": s.playsinline !== !1 ? "" : void 0, playsinline: s.playsinline !== !1 ? "" : void 0, muted: s.muted === !0 ? "" : void 0, loop: s.loop === !0 ? "" : void 0, autoplay: s.autoPlay !== !1 ? "" : void 0 }; Object.keys(i).forEach(l => { let h = i[l]; h !== void 0 && o.setAttribute(l, h) }), s.muted === !0 && (o.muted = !0), Yg(o, r, s.crossorigin); let n = document.createElement("source"), a; if (r.startsWith("data:")) a = r.slice(5, r.indexOf(";")); else if (!r.startsWith("blob:")) { let l = r.split("?")[0].slice(r.lastIndexOf(".") + 1).toLowerCase(); a = qr.MIME_TYPES[l] || `video/${l}` } return n.src = r, a && (n.type = a), new Promise(l => { let h = c(async () => { let u = new qr({ ...s, resource: o }); o.removeEventListener("canplay", h), t.data.preload && await $g(o), l(Zt(u, e, r)) }, "onCanPlay"); o.addEventListener("canplay", h), o.appendChild(n) }) }, unload (r) { r.destroy(!0) } }; S(); Xr(); S(); Xr(); var jn = { extension: x.ResolveParser, test: $n.test, parse: r => ({ resolution: parseFloat(Dt.RETINA_PREFIX.exec(r)?.[1] ?? "1"), format: r.split(".").pop(), src: r }) }; var Wd = { extension: x.ResolveParser, test: r => Dt.RETINA_PREFIX.test(r) && r.endsWith(".json"), parse: jn.parse }; Xr(); Ei(); fa(); var qn = class { constructor() { this._detections = [], this._initialized = !1, this.resolver = new Dt, this.loader = new ii, this.cache = tt, this._backgroundLoader = new oi(this.loader), this._backgroundLoader.active = !0, this.reset() } async init (t = {}) { if (this._initialized) { U("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?"); return } if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) { let i = t.manifest; typeof i == "string" && (i = await this.load(i)), this.resolver.addManifest(i) } let e = t.texturePreference?.resolution ?? 1, s = typeof e == "number" ? [e] : e, o = await this._detectFormats({ preferredFormats: t.texturePreference?.format, skipDetections: t.skipDetections, detections: this._detections }); this.resolver.prefer({ params: { format: o, resolution: s } }), t.preferences && this.setPreferences(t.preferences) } add (t) { this.resolver.add(t) } async load (t, e) { this._initialized || await this.init(); let s = fr(t), o = Xt(t).map(a => { if (typeof a != "string") { let l = this.resolver.getAlias(a); return l.some(h => !this.resolver.hasKey(h)) && this.add(a), Array.isArray(l) ? l[0] : l } return this.resolver.hasKey(a) || this.add({ alias: a, src: a }), a }), i = this.resolver.resolve(o), n = await this._mapLoadToResolve(i, e); return s ? n[o[0]] : n } addBundle (t, e) { this.resolver.addBundle(t, e) } async loadBundle (t, e) { this._initialized || await this.init(); let s = !1; typeof t == "string" && (s = !0, t = [t]); let o = this.resolver.resolveBundle(t), i = {}, n = Object.keys(o), a = 0, l = 0, h = c(() => { e?.(++a / l) }, "_onProgress"), u = n.map(d => { let f = o[d]; return l += Object.keys(f).length, this._mapLoadToResolve(f, h).then(p => { i[d] = p }) }); return await Promise.all(u), s ? i[t[0]] : i } async backgroundLoad (t) { this._initialized || await this.init(), typeof t == "string" && (t = [t]); let e = this.resolver.resolve(t); this._backgroundLoader.add(Object.values(e)) } async backgroundLoadBundle (t) { this._initialized || await this.init(), typeof t == "string" && (t = [t]); let e = this.resolver.resolveBundle(t); Object.values(e).forEach(s => { this._backgroundLoader.add(Object.values(s)) }) } reset () { this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1 } get (t) { if (typeof t == "string") return tt.get(t); let e = {}; for (let s = 0; s < t.length; s++)e[s] = tt.get(t[s]); return e } async _mapLoadToResolve (t, e) { let s = [...new Set(Object.values(t))]; this._backgroundLoader.active = !1; let o = await this.loader.load(s, e); this._backgroundLoader.active = !0; let i = {}; return s.forEach(n => { let a = o[n.src], l = [n.src]; n.alias && l.push(...n.alias), l.forEach(h => { i[h] = a }), tt.set(l, a) }), i } async unload (t) { this._initialized || await this.init(); let e = Xt(t).map(o => typeof o != "string" ? o.src : o), s = this.resolver.resolve(e); await this._unloadFromResolved(s) } async unloadBundle (t) { this._initialized || await this.init(), t = Xt(t); let e = this.resolver.resolveBundle(t), s = Object.keys(e).map(o => this._unloadFromResolved(e[o])); await Promise.all(s) } async _unloadFromResolved (t) { let e = Object.values(t); e.forEach(s => { tt.remove(s.src) }), await this.loader.unload(e) } async _detectFormats (t) { let e = []; t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [t.preferredFormats]); for (let s of t.detections) t.skipDetections || await s.test() ? e = await s.add(e) : t.skipDetections || (e = await s.remove(e)); return e = e.filter((s, o) => e.indexOf(s) === o), e } get detections () { return this._detections } setPreferences (t) { this.loader.parsers.forEach(e => { e.config && Object.keys(e.config).filter(s => s in t).forEach(s => { e.config[s] = t[s] }) }) } }; c(qn, "AssetsClass"); var Kn = new qn; I.handleByList(x.LoadParser, Kn.loader.parsers).handleByList(x.ResolveParser, Kn.resolver.parsers).handleByList(x.CacheParser, Kn.cache.parsers).handleByList(x.DetectionParser, Kn.detections); I.add(Rd, Gd, Md, Od, Ud, Fd, Id, kd, Dd, Ld, Hd, $n, Nd, jn, Wd); var v0 = { loader: x.LoadParser, resolver: x.ResolveParser, cache: x.CacheParser, detection: x.DetectionParser }; I.handle(x.Asset, r => { let t = r.ref; Object.entries(v0).filter(([e]) => !!t[e]).forEach(([e, s]) => I.add(Object.assign(t[e], { extension: t[e].extension ?? s }))) }, r => { let t = r.ref; Object.keys(v0).filter(e => !!t[e]).forEach(e => I.remove(t[e])) }); Ke(); pe(); Xr(); Ei(); xl(); Nf(); fa(); $t(); S(); var Bb = { extension: { type: x.DetectionParser, priority: 3 }, test: async () => !!(await cr() || ar()), add: async r => [...r, "basis"], remove: async r => r.filter(t => t !== "basis") }; pe(); S(); Lt(); var ge = class extends J { constructor(t) { super(t), this.uploadMethodId = "compressed", this.resource = t.resource, this.mipLevelCount = this.resource.length } }; c(ge, "CompressedSource"); var Kg; function dc () { if (Kg) return Kg; let t = document.createElement("canvas").getContext("webgl"); return t ? (Kg = [...t.getExtension("EXT_texture_compression_bptc") ? ["bc6h-rgb-ufloat", "bc6h-rgb-float", "bc7-rgba-unorm", "bc7-rgba-unorm-srgb"] : [], ...t.getExtension("WEBGL_compressed_texture_s3tc") ? ["bc1-rgba-unorm", "bc2-rgba-unorm", "bc3-rgba-unorm"] : [], ...t.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? ["bc1-rgba-unorm-srgb", "bc2-rgba-unorm-srgb", "bc3-rgba-unorm-srgb"] : [], ...t.getExtension("EXT_texture_compression_rgtc") ? ["bc4-r-unorm", "bc4-r-snorm", "bc5-rg-unorm", "bc5-rg-snorm"] : [], ...t.getExtension("WEBGL_compressed_texture_etc") ? ["etc2-rgb8unorm", "etc2-rgb8unorm-srgb", "etc2-rgba8unorm", "etc2-rgba8unorm-srgb", "etc2-rgb8a1unorm", "etc2-rgb8a1unorm-srgb", "eac-r11unorm", "eac-rg11unorm"] : [], ...t.getExtension("WEBGL_compressed_texture_astc") ? ["astc-4x4-unorm", "astc-4x4-unorm-srgb", "astc-5x4-unorm", "astc-5x4-unorm-srgb", "astc-5x5-unorm", "astc-5x5-unorm-srgb", "astc-6x5-unorm", "astc-6x5-unorm-srgb", "astc-6x6-unorm", "astc-6x6-unorm-srgb", "astc-8x5-unorm", "astc-8x5-unorm-srgb", "astc-8x6-unorm", "astc-8x6-unorm-srgb", "astc-8x8-unorm", "astc-8x8-unorm-srgb", "astc-10x5-unorm", "astc-10x5-unorm-srgb", "astc-10x6-unorm", "astc-10x6-unorm-srgb", "astc-10x8-unorm", "astc-10x8-unorm-srgb", "astc-10x10-unorm", "astc-10x10-unorm-srgb", "astc-12x10-unorm", "astc-12x10-unorm-srgb", "astc-12x12-unorm", "astc-12x12-unorm-srgb"] : []], Kg) : [] } c(dc, "getSupportedGlCompressedTextureFormats"); var qg; async function fc () { if (qg) return qg; let r = await navigator.gpu.requestAdapter(); return qg = [...r.features.has("texture-compression-bc") ? ["bc1-rgba-unorm", "bc1-rgba-unorm-srgb", "bc2-rgba-unorm", "bc2-rgba-unorm-srgb", "bc3-rgba-unorm", "bc3-rgba-unorm-srgb", "bc4-r-unorm", "bc4-r-snorm", "bc5-rg-unorm", "bc5-rg-snorm", "bc6h-rgb-ufloat", "bc6h-rgb-float", "bc7-rgba-unorm", "bc7-rgba-unorm-srgb"] : [], ...r.features.has("texture-compression-etc2") ? ["etc2-rgb8unorm", "etc2-rgb8unorm-srgb", "etc2-rgb8a1unorm", "etc2-rgb8a1unorm-srgb", "etc2-rgba8unorm", "etc2-rgba8unorm-srgb", "eac-r11unorm", "eac-r11snorm", "eac-rg11unorm", "eac-rg11snorm"] : [], ...r.features.has("texture-compression-astc") ? ["astc-4x4-unorm", "astc-4x4-unorm-srgb", "astc-5x4-unorm", "astc-5x4-unorm-srgb", "astc-5x5-unorm", "astc-5x5-unorm-srgb", "astc-6x5-unorm", "astc-6x5-unorm-srgb", "astc-6x6-unorm", "astc-6x6-unorm-srgb", "astc-8x5-unorm", "astc-8x5-unorm-srgb", "astc-8x6-unorm", "astc-8x6-unorm-srgb", "astc-8x8-unorm", "astc-8x8-unorm-srgb", "astc-10x5-unorm", "astc-10x5-unorm-srgb", "astc-10x6-unorm", "astc-10x6-unorm-srgb", "astc-10x8-unorm", "astc-10x8-unorm-srgb", "astc-10x10-unorm", "astc-10x10-unorm-srgb", "astc-12x10-unorm", "astc-12x10-unorm-srgb", "astc-12x12-unorm", "astc-12x12-unorm-srgb"] : []], qg } c(fc, "getSupportedGPUCompressedTextureFormats"); var Zg; async function Zn () { return Zg !== void 0 || (Zg = await (async () => { let r = await cr(), t = ar(); if (r && t) { let e = await fc(), s = dc(); return e.filter(o => s.includes(o)) } else { if (r) return await fc(); if (t) return dc() } return [] })()), Zg } c(Zn, "getSupportedCompressedTextureFormats"); var Jg = ["r8unorm", "r8snorm", "r8uint", "r8sint", "r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2unorm", "rg11b10ufloat", "rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float", "rgba32uint", "rgba32sint", "rgba32float", "stencil8", "depth16unorm", "depth24plus", "depth24plus-stencil8", "depth32float", "depth32float-stencil8"], Qg; async function lr () { if (Qg !== void 0) return Qg; let r = await Zn(); return Qg = [...Jg, ...r], Qg } c(lr, "getSupportedTextureFormats"); var p1 = `(function () {
    'use strict';

    function createLevelBuffers(basisTexture, basisTranscoderFormat) {
      const images = basisTexture.getNumImages();
      const levels = basisTexture.getNumLevels(0);
      const success = basisTexture.startTranscoding();
      if (!success) {
        throw new Error("startTranscoding failed");
      }
      const levelBuffers = [];
      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {
        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {
          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
          const levelBuffer = new Uint8Array(transcodeSize);
          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
          if (!success2) {
            throw new Error("transcodeImage failed");
          }
          levelBuffers.push(levelBuffer);
        }
      }
      return levelBuffers;
    }

    const gpuFormatToBasisTranscoderFormatMap = {
      "bc3-rgba-unorm": 3,
      // cTFBC3_RGBA
      "bc7-rgba-unorm": 6,
      // cTFBC7_RGBA,
      "etc2-rgba8unorm": 1,
      // cTFETC2_RGBA,
      "astc-4x4-unorm": 10,
      // cTFASTC_4x4_RGBA,
      // Uncompressed
      rgba8unorm: 13,
      // cTFRGBA32,
      rgba4unorm: 16
      // cTFRGBA4444,
    };
    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported transcoderFormat: \${transcoderFormat}\`);
    }

    const settings = {
      jsUrl: "basis/basis_transcoder.js",
      wasmUrl: "basis/basis_transcoder.wasm"
    };
    let basisTranscoderFormat;
    let basisTranscodedTextureFormat;
    let basisPromise;
    async function getBasis() {
      if (!basisPromise) {
        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;
        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;
        importScripts(absoluteJsUrl);
        basisPromise = new Promise((resolve) => {
          BASIS({
            locateFile: (_file) => absoluteWasmUrl
          }).then((module) => {
            module.initializeBasis();
            resolve(module.BasisFile);
          });
        });
      }
      return basisPromise;
    }
    async function fetchBasisTexture(url, BasisTexture) {
      const basisResponse = await fetch(url);
      if (basisResponse.ok) {
        const basisArrayBuffer = await basisResponse.arrayBuffer();
        return new BasisTexture(new Uint8Array(basisArrayBuffer));
      }
      throw new Error(\`Failed to load Basis texture: \${url}\`);
    }
    const preferredTranscodedFormat = [
      "bc7-rgba-unorm",
      "astc-4x4-unorm",
      "etc2-rgba8unorm",
      "bc3-rgba-unorm",
      "rgba8unorm"
    ];
    async function load(url) {
      const BasisTexture = await getBasis();
      const basisTexture = await fetchBasisTexture(url, BasisTexture);
      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);
      return {
        width: basisTexture.getImageWidth(0, 0),
        height: basisTexture.getImageHeight(0, 0),
        format: basisTranscodedTextureFormat,
        resource: levelBuffers,
        alphaMode: "no-premultiply-alpha"
      };
    }
    async function init(jsUrl, wasmUrl, supportedTextures) {
      if (jsUrl)
        settings.jsUrl = jsUrl;
      if (wasmUrl)
        settings.wasmUrl = wasmUrl;
      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];
      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);
      await getBasis();
    }
    const messageHandlers = {
      init: async (data) => {
        const { jsUrl, wasmUrl, supportedTextures } = data;
        await init(jsUrl, wasmUrl, supportedTextures);
      },
      load: async (data) => {
        try {
          const textureOptions = await load(data.url);
          return {
            type: "load",
            url: data.url,
            success: true,
            textureOptions,
            transferables: textureOptions.resource?.map((arr) => arr.buffer)
          };
        } catch (e) {
          throw e;
        }
      }
    };
    self.onmessage = async (messageEvent) => {
      const message = messageEvent.data;
      const response = await messageHandlers[message.type](message);
      if (response) {
        self.postMessage(response, response.transferables);
      }
    };

})();
`, pc = null, mc = class { constructor() { pc || (pc = URL.createObjectURL(new Blob([p1], { type: "application/javascript" }))), this.worker = new Worker(pc) } }; c(mc, "WorkerInstance"); mc.revokeObjectURL = c(function () { pc && (URL.revokeObjectURL(pc), pc = null) }, "revokeObjectURL"); var Qn = { jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js", wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm" }; function Ab (r) { Object.assign(Qn, r) } c(Ab, "setBasisTranscoderPath"); var Xd, S0 = {}; function m1 (r) { return Xd || (Xd = new mc().worker, Xd.onmessage = t => { let { success: e, url: s, textureOptions: o } = t.data; e || console.warn("Failed to load Basis texture", s), S0[s](o) }, Xd.postMessage({ type: "init", jsUrl: Qn.jsUrl, wasmUrl: Qn.wasmUrl, supportedTextures: r })), Xd } c(m1, "getBasisWorker"); function zd (r, t) { let e = m1(t); return new Promise(s => { S0[r] = s, e.postMessage({ type: "load", url: r }) }) } c(zd, "loadBasisOnWorker"); var wb = { extension: { type: x.LoadParser, priority: mt.High }, name: "loadBasis", test (r) { return vt(r, [".basis"]) }, async load (r, t, e) { let s = await lr(), o = await zd(r, s), i = new ge(o); return Zt(i, e, r) }, unload (r) { Array.isArray(r) ? r.forEach(t => t.destroy(!0)) : r.destroy(!0) } }; function Rb (r, t) { let e = r.getNumImages(), s = r.getNumLevels(0); if (!r.startTranscoding()) throw new Error("startTranscoding failed"); let i = []; for (let n = 0; n < s; ++n)for (let a = 0; a < e; ++a) { let l = r.getImageTranscodedSizeInBytes(a, n, t), h = new Uint8Array(l); if (!r.transcodeImage(h, a, n, t, 1, 0)) throw new Error("transcodeImage failed"); i.push(h) } return i } c(Rb, "createLevelBuffers"); var x1 = { "bc3-rgba-unorm": 3, "bc7-rgba-unorm": 6, "etc2-rgba8unorm": 1, "astc-4x4-unorm": 10, rgba8unorm: 13, rgba4unorm: 16 }; function Mb (r) { let t = x1[r]; if (t) return t; throw new Error(`Unsupported transcoderFormat: ${r}`) } c(Mb, "gpuFormatToBasisTranscoderFormat"); var g1 = { MAGIC: 0, SIZE: 1, FLAGS: 2, HEIGHT: 3, WIDTH: 4, MIPMAP_COUNT: 7, PIXEL_FORMAT: 19, PF_FLAGS: 20, FOURCC: 21, RGB_BITCOUNT: 22, R_BIT_MASK: 23, G_BIT_MASK: 24, B_BIT_MASK: 25, A_BIT_MASK: 26 }, _1 = { DXGI_FORMAT: 0, RESOURCE_DIMENSION: 1, MISC_FLAG: 2, ARRAY_SIZE: 3, MISC_FLAGS2: 4 }, T0 = (r => (r[r.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", r[r.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", r[r.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", r[r.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", r[r.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", r[r.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", r[r.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", r[r.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", r[r.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", r[r.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", r[r.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", r[r.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", r[r.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", r[r.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", r[r.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", r[r.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", r[r.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", r[r.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", r[r.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", r[r.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", r[r.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", r[r.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", r[r.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", r[r.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", r[r.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", r[r.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", r[r.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", r[r.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", r[r.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", r[r.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", r[r.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", r[r.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", r[r.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", r[r.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", r[r.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", r[r.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", r[r.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", r[r.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", r[r.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", r[r.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", r[r.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", r[r.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", r[r.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", r[r.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", r[r.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", r[r.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", r[r.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", r[r.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", r[r.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", r[r.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", r[r.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", r[r.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", r[r.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", r[r.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", r[r.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", r[r.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", r[r.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", r[r.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", r[r.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", r[r.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", r[r.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", r[r.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", r[r.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", r[r.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", r[r.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", r[r.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", r[r.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", r[r.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", r[r.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", r[r.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", r[r.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", r[r.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", r[r.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", r[r.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", r[r.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", r[r.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", r[r.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", r[r.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", r[r.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", r[r.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", r[r.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", r[r.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", r[r.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", r[r.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", r[r.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", r[r.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", r[r.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", r[r.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", r[r.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", r[r.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", r[r.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", r[r.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", r[r.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", r[r.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", r[r.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", r[r.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", r[r.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", r[r.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", r[r.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", r[r.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", r[r.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", r[r.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", r[r.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", r[r.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", r[r.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", r[r.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", r[r.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", r[r.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", r[r.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", r[r.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", r[r.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", r[r.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT", r))(T0 || {}), E0 = (r => (r[r.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", r[r.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", r[r.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D", r))(E0 || {}); function Yt (r) { return r.charCodeAt(0) + (r.charCodeAt(1) << 8) + (r.charCodeAt(2) << 16) + (r.charCodeAt(3) << 24) } c(Yt, "fourCCToInt32"); var Ge = (r => (r[r.UNKNOWN = 0] = "UNKNOWN", r[r.R8G8B8 = 20] = "R8G8B8", r[r.A8R8G8B8 = 21] = "A8R8G8B8", r[r.X8R8G8B8 = 22] = "X8R8G8B8", r[r.R5G6B5 = 23] = "R5G6B5", r[r.X1R5G5B5 = 24] = "X1R5G5B5", r[r.A1R5G5B5 = 25] = "A1R5G5B5", r[r.A4R4G4B4 = 26] = "A4R4G4B4", r[r.R3G3B2 = 27] = "R3G3B2", r[r.A8 = 28] = "A8", r[r.A8R3G3B2 = 29] = "A8R3G3B2", r[r.X4R4G4B4 = 30] = "X4R4G4B4", r[r.A2B10G10R10 = 31] = "A2B10G10R10", r[r.A8B8G8R8 = 32] = "A8B8G8R8", r[r.X8B8G8R8 = 33] = "X8B8G8R8", r[r.G16R16 = 34] = "G16R16", r[r.A2R10G10B10 = 35] = "A2R10G10B10", r[r.A16B16G16R16 = 36] = "A16B16G16R16", r[r.A8P8 = 40] = "A8P8", r[r.P8 = 41] = "P8", r[r.L8 = 50] = "L8", r[r.A8L8 = 51] = "A8L8", r[r.A4L4 = 52] = "A4L4", r[r.V8U8 = 60] = "V8U8", r[r.L6V5U5 = 61] = "L6V5U5", r[r.X8L8V8U8 = 62] = "X8L8V8U8", r[r.Q8W8V8U8 = 63] = "Q8W8V8U8", r[r.V16U16 = 64] = "V16U16", r[r.A2W10V10U10 = 67] = "A2W10V10U10", r[r.Q16W16V16U16 = 110] = "Q16W16V16U16", r[r.R16F = 111] = "R16F", r[r.G16R16F = 112] = "G16R16F", r[r.A16B16G16R16F = 113] = "A16B16G16R16F", r[r.R32F = 114] = "R32F", r[r.G32R32F = 115] = "G32R32F", r[r.A32B32G32R32F = 116] = "A32B32G32R32F", r[r.UYVY = Yt("UYVY")] = "UYVY", r[r.R8G8_B8G8 = Yt("RGBG")] = "R8G8_B8G8", r[r.YUY2 = Yt("YUY2")] = "YUY2", r[r.D3DFMT_G8R8_G8B8 = Yt("GRGB")] = "D3DFMT_G8R8_G8B8", r[r.DXT1 = Yt("DXT1")] = "DXT1", r[r.DXT2 = Yt("DXT2")] = "DXT2", r[r.DXT3 = Yt("DXT3")] = "DXT3", r[r.DXT4 = Yt("DXT4")] = "DXT4", r[r.DXT5 = Yt("DXT5")] = "DXT5", r[r.ATI1 = Yt("ATI1")] = "ATI1", r[r.AT1N = Yt("AT1N")] = "AT1N", r[r.ATI2 = Yt("ATI2")] = "ATI2", r[r.AT2N = Yt("AT2N")] = "AT2N", r[r.BC4U = Yt("BC4U")] = "BC4U", r[r.BC4S = Yt("BC4S")] = "BC4S", r[r.BC5U = Yt("BC5U")] = "BC5U", r[r.BC5S = Yt("BC5S")] = "BC5S", r[r.DX10 = Yt("DX10")] = "DX10", r))(Ge || {}), xc = { [Ge.DXT1]: "bc1-rgba-unorm", [Ge.DXT2]: "bc2-rgba-unorm", [Ge.DXT3]: "bc2-rgba-unorm", [Ge.DXT4]: "bc3-rgba-unorm", [Ge.DXT5]: "bc3-rgba-unorm", [Ge.ATI1]: "bc4-r-unorm", [Ge.BC4U]: "bc4-r-unorm", [Ge.BC4S]: "bc4-r-snorm", [Ge.ATI2]: "bc5-rg-unorm", [Ge.BC5U]: "bc5-rg-unorm", [Ge.BC5S]: "bc5-rg-snorm", [36]: "rgba16uint", [110]: "rgba16sint", [111]: "r16float", [112]: "rg16float", [113]: "rgba16float", [114]: "r32float", [115]: "rg32float", [116]: "rgba32float" }, Qt = { [70]: "bc1-rgba-unorm", [71]: "bc1-rgba-unorm", [72]: "bc1-rgba-unorm-srgb", [73]: "bc2-rgba-unorm", [74]: "bc2-rgba-unorm", [75]: "bc2-rgba-unorm-srgb", [76]: "bc3-rgba-unorm", [77]: "bc3-rgba-unorm", [78]: "bc3-rgba-unorm-srgb", [79]: "bc4-r-unorm", [80]: "bc4-r-unorm", [81]: "bc4-r-snorm", [82]: "bc5-rg-unorm", [83]: "bc5-rg-unorm", [84]: "bc5-rg-snorm", [94]: "bc6h-rgb-ufloat", [95]: "bc6h-rgb-ufloat", [96]: "bc6h-rgb-float", [97]: "bc7-rgba-unorm", [98]: "bc7-rgba-unorm", [99]: "bc7-rgba-unorm-srgb", [28]: "rgba8unorm", [29]: "rgba8unorm-srgb", [87]: "bgra8unorm", [91]: "bgra8unorm-srgb", [41]: "r32float", [49]: "rg8unorm", [56]: "r16uint", [61]: "r8unorm", [24]: "rgb10a2unorm", [11]: "rgba16uint", [13]: "rgba16sint", [10]: "rgba16float", [54]: "r16float", [34]: "rg16float", [16]: "rg32float", [2]: "rgba32float" }, W = { MAGIC_VALUE: 542327876, MAGIC_SIZE: 4, HEADER_SIZE: 124, HEADER_DX10_SIZE: 20, PIXEL_FORMAT_FLAGS: { ALPHAPIXELS: 1, ALPHA: 2, FOURCC: 4, RGB: 64, RGBA: 65, YUV: 512, LUMINANCE: 131072, LUMINANCEA: 131073 }, RESOURCE_MISC_TEXTURECUBE: 4, HEADER_FIELDS: g1, HEADER_DX10_FIELDS: _1, DXGI_FORMAT: T0, D3D10_RESOURCE_DIMENSION: E0, D3DFMT: Ge }, Vd = { "bc1-rgba-unorm": 8, "bc1-rgba-unorm-srgb": 8, "bc2-rgba-unorm": 16, "bc2-rgba-unorm-srgb": 16, "bc3-rgba-unorm": 16, "bc3-rgba-unorm-srgb": 16, "bc4-r-unorm": 8, "bc4-r-snorm": 8, "bc5-rg-unorm": 16, "bc5-rg-snorm": 16, "bc6h-rgb-ufloat": 16, "bc6h-rgb-float": 16, "bc7-rgba-unorm": 16, "bc7-rgba-unorm-srgb": 16 }; pe(); S(); function Yd (r, t) { let { format: e, fourCC: s, width: o, height: i, dataOffset: n, mipmapCount: a } = y1(r); if (!t.includes(e)) throw new Error(`Unsupported texture format: ${s} ${e}, supported: ${t}`); if (a <= 1) return { format: e, width: o, height: i, resource: [new Uint8Array(r, n)], alphaMode: "no-premultiply-alpha" }; let l = b1(e, o, i, n, a, r); return { format: e, width: o, height: i, resource: l, alphaMode: "no-premultiply-alpha" } } c(Yd, "parseDDS"); function b1 (r, t, e, s, o, i) { let n = [], a = Vd[r], l = t, h = e, u = s; for (let d = 0; d < o; ++d) { let f = a ? Math.max(4, l) / 4 * Math.max(4, h) / 4 * a : l * h * 4, p = new Uint8Array(i, u, f); n.push(p), u += f, l = Math.max(l >> 1, 1), h = Math.max(h >> 1, 1) } return n } c(b1, "getMipmapLevelBuffers"); function y1 (r) { let t = new Uint32Array(r, 0, W.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT); if (t[W.HEADER_FIELDS.MAGIC] !== W.MAGIC_VALUE) throw new Error("Invalid magic number in DDS header"); let e = t[W.HEADER_FIELDS.HEIGHT], s = t[W.HEADER_FIELDS.WIDTH], o = Math.max(1, t[W.HEADER_FIELDS.MIPMAP_COUNT]), i = t[W.HEADER_FIELDS.PF_FLAGS], n = t[W.HEADER_FIELDS.FOURCC], a = v1(t, i, n, r), l = W.MAGIC_SIZE + W.HEADER_SIZE + (n === W.D3DFMT.DX10 ? W.HEADER_DX10_SIZE : 0); return { format: a, fourCC: n, width: s, height: e, dataOffset: l, mipmapCount: o } } c(y1, "parseDDSHeader"); function v1 (r, t, e, s) { if (t & W.PIXEL_FORMAT_FLAGS.FOURCC) { if (e === W.D3DFMT.DX10) { let o = new Uint32Array(s, W.MAGIC_SIZE + W.HEADER_SIZE, W.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT); if (o[W.HEADER_DX10_FIELDS.MISC_FLAG] === W.RESOURCE_MISC_TEXTURECUBE) throw new Error("DDSParser does not support cubemap textures"); if (o[W.HEADER_DX10_FIELDS.RESOURCE_DIMENSION] === W.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) throw new Error("DDSParser does not supported 3D texture data"); let a = o[W.HEADER_DX10_FIELDS.DXGI_FORMAT]; if (a in Qt) return Qt[a]; throw new Error(`DDSParser cannot parse texture data with DXGI format ${a}`) } if (e in xc) return xc[e]; throw new Error(`DDSParser cannot parse texture data with fourCC format ${e}`) } if (t & W.PIXEL_FORMAT_FLAGS.RGB || t & W.PIXEL_FORMAT_FLAGS.RGBA) return S1(r); throw t & W.PIXEL_FORMAT_FLAGS.YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : t & W.PIXEL_FORMAT_FLAGS.LUMINANCE || t & W.PIXEL_FORMAT_FLAGS.LUMINANCEA ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : t & W.PIXEL_FORMAT_FLAGS.ALPHA || t & W.PIXEL_FORMAT_FLAGS.ALPHAPIXELS ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!") } c(v1, "getTextureFormat"); function S1 (r) {
          let t = r[W.HEADER_FIELDS.RGB_BITCOUNT], e = r[W.HEADER_FIELDS.R_BIT_MASK], s = r[W.HEADER_FIELDS.G_BIT_MASK], o = r[W.HEADER_FIELDS.B_BIT_MASK], i = r[W.HEADER_FIELDS.A_BIT_MASK]; switch (t) { case 32: if (e === 255 && s === 65280 && o === 16711680 && i === 4278190080) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM]; if (e === 16711680 && s === 65280 && o === 255 && i === 4278190080) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM]; if (e === 1072693248 && s === 1047552 && o === 1023 && i === 3221225472) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM]; if (e === 65535 && s === 4294901760 && o === 0 && i === 0) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM]; if (e === 4294967295 && s === 0 && o === 0 && i === 0) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT]; break; case 24: break; case 16: if (e === 31744 && s === 992 && o === 31 && i === 32768) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM]; if (e === 63488 && s === 2016 && o === 31 && i === 0) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM]; if (e === 3840 && s === 240 && o === 15 && i === 61440) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM]; if (e === 255 && s === 0 && o === 0 && i === 65280) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM]; if (e === 65535 && s === 0 && o === 0 && i === 0) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM]; break; case 8: if (e === 255 && s === 0 && o === 0 && i === 0) return Qt[W.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM]; break }throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${t}, rBitMask = ${e}, gBitMask = ${s}, aBitMask = ${i}`)
        } c(S1, "getUncompressedTextureFormat"); var Gb = { extension: { type: x.LoadParser, priority: mt.High }, name: "loadDDS", test (r) { return vt(r, [".dds"]) }, async load (r, t, e) { let s = await lr(), i = await (await fetch(r)).arrayBuffer(), n = Yd(i, s), a = new ge(n); return Zt(a, e, r) }, unload (r) { Array.isArray(r) ? r.forEach(t => t.destroy(!0)) : r.destroy(!0) } }; pe(); S(); var t_ = (r => (r[r.RGBA8_SNORM = 36759] = "RGBA8_SNORM", r[r.RGBA = 6408] = "RGBA", r[r.RGBA8UI = 36220] = "RGBA8UI", r[r.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", r[r.RGBA8I = 36238] = "RGBA8I", r[r.RGBA8 = 32856] = "RGBA8", r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", r[r.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", r[r.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", r[r.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", r[r.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", r[r.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", r[r.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", r[r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", r[r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", r[r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", r))(t_ || {}); var T1 = { [33776]: "bc1-rgba-unorm", [33777]: "bc1-rgba-unorm", [33778]: "bc2-rgba-unorm", [33779]: "bc3-rgba-unorm", [35916]: "bc1-rgba-unorm-srgb", [35917]: "bc1-rgba-unorm-srgb", [35918]: "bc2-rgba-unorm-srgb", [35919]: "bc3-rgba-unorm-srgb", [36283]: "bc4-r-unorm", [36284]: "bc4-r-snorm", [36285]: "bc5-rg-unorm", [36286]: "bc5-rg-snorm", [37488]: "eac-r11unorm", [37490]: "eac-rg11snorm", [37492]: "etc2-rgb8unorm", [37496]: "etc2-rgba8unorm", [37493]: "etc2-rgb8unorm-srgb", [37497]: "etc2-rgba8unorm-srgb", [37494]: "etc2-rgb8a1unorm", [37495]: "etc2-rgb8a1unorm-srgb", [37808]: "astc-4x4-unorm", [37840]: "astc-4x4-unorm-srgb", [37809]: "astc-5x4-unorm", [37841]: "astc-5x4-unorm-srgb", [37810]: "astc-5x5-unorm", [37842]: "astc-5x5-unorm-srgb", [37811]: "astc-6x5-unorm", [37843]: "astc-6x5-unorm-srgb", [37812]: "astc-6x6-unorm", [37844]: "astc-6x6-unorm-srgb", [37813]: "astc-8x5-unorm", [37845]: "astc-8x5-unorm-srgb", [37814]: "astc-8x6-unorm", [37846]: "astc-8x6-unorm-srgb", [37815]: "astc-8x8-unorm", [37847]: "astc-8x8-unorm-srgb", [37816]: "astc-10x5-unorm", [37848]: "astc-10x5-unorm-srgb", [37817]: "astc-10x6-unorm", [37849]: "astc-10x6-unorm-srgb", [37818]: "astc-10x8-unorm", [37850]: "astc-10x8-unorm-srgb", [37819]: "astc-10x10-unorm", [37851]: "astc-10x10-unorm-srgb", [37820]: "astc-12x10-unorm", [37852]: "astc-12x10-unorm-srgb", [37821]: "astc-12x12-unorm", [37853]: "astc-12x12-unorm-srgb", [36492]: "bc7-rgba-unorm", [36493]: "bc7-rgba-unorm-srgb", [36494]: "bc6h-rgb-float", [36495]: "bc6h-rgb-ufloat", [35907]: "rgba8unorm-srgb", [36759]: "rgba8snorm", [36220]: "rgba8uint", [36238]: "rgba8sint", [6408]: "rgba8unorm" }, E1 = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], P1 = { FILE_IDENTIFIER: 0, ENDIANNESS: 12, GL_TYPE: 16, GL_TYPE_SIZE: 20, GL_FORMAT: 24, GL_INTERNAL_FORMAT: 28, GL_BASE_INTERNAL_FORMAT: 32, PIXEL_WIDTH: 36, PIXEL_HEIGHT: 40, PIXEL_DEPTH: 44, NUMBER_OF_ARRAY_ELEMENTS: 48, NUMBER_OF_FACES: 52, NUMBER_OF_MIPMAP_LEVELS: 56, BYTES_OF_KEY_VALUE_DATA: 60 }, C1 = 64, B1 = 67305985, A1 = { [5121]: 1, [5123]: 2, [5124]: 4, [5125]: 4, [5126]: 4, [36193]: 8 }, w1 = { [6408]: 4, [6407]: 3, [33319]: 2, [6403]: 1, [6409]: 1, [6410]: 2, [6406]: 1 }, R1 = { [32819]: 2, [32820]: 2, [33635]: 2 }, M1 = { [33776]: .5, [33777]: .5, [33778]: 1, [33779]: 1, [35916]: .5, [35917]: .5, [35918]: 1, [35919]: 1, [36283]: .5, [36284]: .5, [36285]: 1, [36286]: 1, [37488]: .5, [37489]: .5, [37490]: 1, [37491]: 1, [37492]: .5, [37496]: 1, [37493]: .5, [37497]: 1, [37494]: .5, [37495]: .5, [37808]: 1, [37840]: 1, [37809]: .8, [37841]: .8, [37810]: .64, [37842]: .64, [37811]: .53375, [37843]: .53375, [37812]: .445, [37844]: .445, [37813]: .4, [37845]: .4, [37814]: .33375, [37846]: .33375, [37815]: .25, [37847]: .25, [37816]: .32, [37848]: .32, [37817]: .26625, [37849]: .26625, [37818]: .2, [37850]: .2, [37819]: .16, [37851]: .16, [37820]: .13375, [37852]: .13375, [37821]: .11125, [37853]: .11125, [36492]: 1, [36493]: 1, [36494]: 1, [36495]: 1 }, St = { FILE_HEADER_SIZE: C1, FILE_IDENTIFIER: E1, FORMATS_TO_COMPONENTS: w1, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: M1, INTERNAL_FORMAT_TO_TEXTURE_FORMATS: T1, FIELDS: P1, TYPES_TO_BYTES_PER_COMPONENT: A1, TYPES_TO_BYTES_PER_PIXEL: R1, ENDIANNESS: B1 }; function $d (r, t) { let e = new DataView(r); if (!I1(e)) throw new Error("Invalid KTX identifier in header"); let { littleEndian: s, glType: o, glFormat: i, glInternalFormat: n, pixelWidth: a, pixelHeight: l, numberOfMipmapLevels: h, offset: u } = F1(e), d = St.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[n]; if (!d) throw new Error(`Unknown texture format ${n}`); if (!t.includes(d)) throw new Error(`Unsupported texture format: ${d}, supportedFormats: ${t}`); let f = U1(o, i, n), p = G1(e, o, f, a, l, u, h, s); return { format: d, width: a, height: l, resource: p, alphaMode: "no-premultiply-alpha" } } c($d, "parseKTX"); function G1 (r, t, e, s, o, i, n, a) { let l = s + 3 & -4, h = o + 3 & -4, u = s * o; t === 0 && (u = l * h); let d = u * e, f = s, p = o, g = l, b = h, _ = i, y = new Array(n); for (let v = 0; v < n; v++) { let T = r.getUint32(_, a), P = _ + 4; y[v] = new Uint8Array(r.buffer, P, d), P += d, _ += T + 4, _ = _ % 4 !== 0 ? _ + 4 - _ % 4 : _, f = f >> 1 || 1, p = p >> 1 || 1, g = f + 4 - 1 & ~(4 - 1), b = p + 4 - 1 & ~(4 - 1), d = g * b * e } return y } c(G1, "getImageBuffers"); function U1 (r, t, e) { let s = St.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[e]; if (r !== 0 && (St.TYPES_TO_BYTES_PER_COMPONENT[r] ? s = St.TYPES_TO_BYTES_PER_COMPONENT[r] * St.FORMATS_TO_COMPONENTS[t] : s = St.TYPES_TO_BYTES_PER_PIXEL[r]), s === void 0) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!"); return s } c(U1, "getImagePixelByteSize"); function F1 (r) { let t = r.getUint32(St.FIELDS.ENDIANNESS, !0) === St.ENDIANNESS, e = r.getUint32(St.FIELDS.GL_TYPE, t), s = r.getUint32(St.FIELDS.GL_FORMAT, t), o = r.getUint32(St.FIELDS.GL_INTERNAL_FORMAT, t), i = r.getUint32(St.FIELDS.PIXEL_WIDTH, t), n = r.getUint32(St.FIELDS.PIXEL_HEIGHT, t) || 1, a = r.getUint32(St.FIELDS.PIXEL_DEPTH, t) || 1, l = r.getUint32(St.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, t) || 1, h = r.getUint32(St.FIELDS.NUMBER_OF_FACES, t), u = r.getUint32(St.FIELDS.NUMBER_OF_MIPMAP_LEVELS, t), d = r.getUint32(St.FIELDS.BYTES_OF_KEY_VALUE_DATA, t); if (n === 0 || a !== 1) throw new Error("Only 2D textures are supported"); if (h !== 1) throw new Error("CubeTextures are not supported by KTXLoader yet!"); if (l !== 1) throw new Error("WebGL does not support array textures"); return { littleEndian: t, glType: e, glFormat: s, glInternalFormat: o, pixelWidth: i, pixelHeight: n, numberOfMipmapLevels: u, offset: St.FILE_HEADER_SIZE + d } } c(F1, "parseKTXHeader"); function I1 (r) { for (let t = 0; t < St.FILE_IDENTIFIER.length; t++)if (r.getUint8(t) !== St.FILE_IDENTIFIER[t]) return !1; return !0 } c(I1, "validate"); var Ub = { extension: { type: x.LoadParser, priority: mt.High }, name: "loadKTX", test (r) { return vt(r, ".ktx") }, async load (r, t, e) { let s = await lr(), i = await (await fetch(r)).arrayBuffer(), n = $d(i, s), a = new ge(n); return Zt(a, e, r) }, unload (r) { Array.isArray(r) ? r.forEach(t => t.destroy(!0)) : r.destroy(!0) } }; pe(); S(); var O1 = `(function () {
    'use strict';

    const converters = {
      rgb8unorm: {
        convertedFormat: "rgba8unorm",
        convertFunction: convertRGBtoRGBA
      },
      "rgb8unorm-srgb": {
        convertedFormat: "rgba8unorm-srgb",
        convertFunction: convertRGBtoRGBA
      }
    };
    function convertFormatIfRequired(textureOptions) {
      const format = textureOptions.format;
      if (converters[format]) {
        const convertFunction = converters[format].convertFunction;
        const levelBuffers = textureOptions.resource;
        for (let i = 0; i < levelBuffers.length; i++) {
          levelBuffers[i] = convertFunction(levelBuffers[i]);
        }
        textureOptions.format = converters[format].convertedFormat;
      }
    }
    function convertRGBtoRGBA(levelBuffer) {
      const pixelCount = levelBuffer.byteLength / 3;
      const levelBufferWithAlpha = new Uint32Array(pixelCount);
      for (let i = 0; i < pixelCount; ++i) {
        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;
      }
      return new Uint8Array(levelBufferWithAlpha.buffer);
    }

    function createLevelBuffersFromKTX(ktxTexture) {
      const levelBuffers = [];
      for (let i = 0; i < ktxTexture.numLevels; i++) {
        const imageData = ktxTexture.getImageData(i, 0, 0);
        const levelBuffer = new Uint8Array(imageData.byteLength);
        levelBuffer.set(imageData);
        levelBuffers.push(levelBuffer);
      }
      return levelBuffers;
    }

    const glFormatToGPUFormatMap = {
      6408: "rgba8unorm",
      32856: "bgra8unorm",
      //
      32857: "rgb10a2unorm",
      33189: "depth16unorm",
      33190: "depth24plus",
      33321: "r8unorm",
      33323: "rg8unorm",
      33325: "r16float",
      33326: "r32float",
      33327: "rg16float",
      33328: "rg32float",
      33329: "r8sint",
      33330: "r8uint",
      33331: "r16sint",
      33332: "r16uint",
      33333: "r32sint",
      33334: "r32uint",
      33335: "rg8sint",
      33336: "rg8uint",
      33337: "rg16sint",
      33338: "rg16uint",
      33339: "rg32sint",
      33340: "rg32uint",
      33778: "bc2-rgba-unorm",
      33779: "bc3-rgba-unorm",
      34836: "rgba32float",
      34842: "rgba16float",
      35056: "depth24plus-stencil8",
      35898: "rg11b10ufloat",
      35901: "rgb9e5ufloat",
      35907: "rgba8unorm-srgb",
      // bgra8unorm-srgb
      36012: "depth32float",
      36013: "depth32float-stencil8",
      36168: "stencil8",
      36208: "rgba32uint",
      36214: "rgba16uint",
      36220: "rgba8uint",
      36226: "rgba32sint",
      36232: "rgba16sint",
      36238: "rgba8sint",
      36492: "bc7-rgba-unorm",
      36756: "r8snorm",
      36757: "rg8snorm",
      36759: "rgba8snorm",
      37496: "etc2-rgba8unorm",
      37808: "astc-4x4-unorm"
    };
    function glFormatToGPUFormat(glInternalFormat) {
      const format = glFormatToGPUFormatMap[glInternalFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported glInternalFormat: \${glInternalFormat}\`);
    }

    const vkFormatToGPUFormatMap = {
      23: "rgb8unorm",
      // VK_FORMAT_R8G8B8_UNORM
      37: "rgba8unorm",
      // VK_FORMAT_R8G8B8A8_UNORM
      43: "rgba8unorm-srgb"
      // VK_FORMAT_R8G8B8A8_SRGB
      // TODO add more!
    };
    function vkFormatToGPUFormat(vkFormat) {
      const format = vkFormatToGPUFormatMap[vkFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported VkFormat: \${vkFormat}\`);
    }

    function getTextureFormatFromKTXTexture(ktxTexture) {
      if (ktxTexture.classId === 2) {
        return vkFormatToGPUFormat(ktxTexture.vkFormat);
      }
      return glFormatToGPUFormat(ktxTexture.glInternalformat);
    }

    const gpuFormatToBasisTranscoderFormatMap = {
      "bc3-rgba-unorm": "BC3_RGBA",
      "bc7-rgba-unorm": "BC7_M5_RGBA",
      "etc2-rgba8unorm": "ETC2_RGBA",
      "astc-4x4-unorm": "ASTC_4x4_RGBA",
      // Uncompressed
      rgba8unorm: "RGBA32",
      rg11b10ufloat: "R11F_G11F_B10F"
    };
    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
      if (format) {
        return format;
      }
      throw new Error(\`Unsupported transcoderFormat: \${transcoderFormat}\`);
    }

    const settings = {
      jsUrl: "",
      wasmUrl: ""
    };
    let basisTranscoderFormat;
    let basisTranscodedTextureFormat;
    let ktxPromise;
    async function getKTX() {
      if (!ktxPromise) {
        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;
        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;
        importScripts(absoluteJsUrl);
        ktxPromise = new Promise((resolve) => {
          LIBKTX({
            locateFile: (_file) => absoluteWasmUrl
          }).then((libktx) => {
            resolve(libktx);
          });
        });
      }
      return ktxPromise;
    }
    async function fetchKTXTexture(url, ktx) {
      const ktx2Response = await fetch(url);
      if (ktx2Response.ok) {
        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();
        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));
      }
      throw new Error(\`Failed to load KTX(2) texture: \${url}\`);
    }
    const preferredTranscodedFormat = [
      "bc7-rgba-unorm",
      "astc-4x4-unorm",
      "etc2-rgba8unorm",
      "bc3-rgba-unorm",
      "rgba8unorm"
    ];
    async function load(url) {
      const ktx = await getKTX();
      const ktxTexture = await fetchKTXTexture(url, ktx);
      let format;
      if (ktxTexture.needsTranscoding) {
        format = basisTranscodedTextureFormat;
        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];
        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);
        if (result !== ktx.ErrorCode.SUCCESS) {
          throw new Error("Unable to transcode basis texture.");
        }
      } else {
        format = getTextureFormatFromKTXTexture(ktxTexture);
      }
      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);
      const textureOptions = {
        width: ktxTexture.baseWidth,
        height: ktxTexture.baseHeight,
        format,
        mipLevelCount: ktxTexture.numLevels,
        resource: levelBuffers,
        alphaMode: "no-premultiply-alpha"
      };
      convertFormatIfRequired(textureOptions);
      return textureOptions;
    }
    async function init(jsUrl, wasmUrl, supportedTextures) {
      if (jsUrl)
        settings.jsUrl = jsUrl;
      if (wasmUrl)
        settings.wasmUrl = wasmUrl;
      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];
      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);
      await getKTX();
    }
    const messageHandlers = {
      init: async (data) => {
        const { jsUrl, wasmUrl, supportedTextures } = data;
        await init(jsUrl, wasmUrl, supportedTextures);
      },
      load: async (data) => {
        try {
          const textureOptions = await load(data.url);
          return {
            type: "load",
            url: data.url,
            success: true,
            textureOptions,
            transferables: textureOptions.resource?.map((arr) => arr.buffer)
          };
        } catch (e) {
          throw e;
        }
      }
    };
    self.onmessage = async (messageEvent) => {
      const message = messageEvent.data;
      const response = await messageHandlers[message.type]?.(message);
      if (response) {
        self.postMessage(response, response.transferables);
      }
    };

})();
`, gc = null, _c = class { constructor() { gc || (gc = URL.createObjectURL(new Blob([O1], { type: "application/javascript" }))), this.worker = new Worker(gc) } }; c(_c, "WorkerInstance"); _c.revokeObjectURL = c(function () { gc && (URL.revokeObjectURL(gc), gc = null) }, "revokeObjectURL"); var Jn = { jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js", wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm" }; function Fb (r) { Object.assign(Jn, r) } c(Fb, "setKTXTranscoderPath"); var jd, P0 = {}; function k1 (r) { return jd || (jd = new _c().worker, jd.onmessage = t => { let { success: e, url: s, textureOptions: o } = t.data; e || console.warn("Failed to load KTX texture", s), P0[s](o) }, jd.postMessage({ type: "init", jsUrl: Jn.jsUrl, wasmUrl: Jn.wasmUrl, supportedTextures: r })), jd } c(k1, "getKTX2Worker"); function Kd (r, t) { let e = k1(t); return new Promise(s => { P0[r] = s, e.postMessage({ type: "load", url: r }) }) } c(Kd, "loadKTX2onWorker"); var Ib = { extension: { type: x.LoadParser, priority: mt.High }, name: "loadKTX2", test (r) { return vt(r, ".ktx2") }, async load (r, t, e) { let s = await lr(), o = await Kd(r, s), i = new ge(o); return Zt(i, e, r) }, unload (r) { Array.isArray(r) ? r.forEach(t => t.destroy(!0)) : r.destroy(!0) } }; var Ob = { rgb8unorm: { convertedFormat: "rgba8unorm", convertFunction: C0 }, "rgb8unorm-srgb": { convertedFormat: "rgba8unorm-srgb", convertFunction: C0 } }; function kb (r) { let t = r.format; if (Ob[t]) { let e = Ob[t].convertFunction, s = r.resource; for (let o = 0; o < s.length; o++)s[o] = e(s[o]); r.format = Ob[t].convertedFormat } } c(kb, "convertFormatIfRequired"); function C0 (r) { let t = r.byteLength / 3, e = new Uint32Array(t); for (let s = 0; s < t; ++s)e[s] = r[s * 3] + (r[s * 3 + 1] << 8) + (r[s * 3 + 2] << 16) + 4278190080; return new Uint8Array(e.buffer) } c(C0, "convertRGBtoRGBA"); function Db (r) { let t = []; for (let e = 0; e < r.numLevels; e++) { let s = r.getImageData(e, 0, 0), o = new Uint8Array(s.byteLength); o.set(s), t.push(o) } return t } c(Db, "createLevelBuffersFromKTX"); var D1 = { 6408: "rgba8unorm", 32856: "bgra8unorm", 32857: "rgb10a2unorm", 33189: "depth16unorm", 33190: "depth24plus", 33321: "r8unorm", 33323: "rg8unorm", 33325: "r16float", 33326: "r32float", 33327: "rg16float", 33328: "rg32float", 33329: "r8sint", 33330: "r8uint", 33331: "r16sint", 33332: "r16uint", 33333: "r32sint", 33334: "r32uint", 33335: "rg8sint", 33336: "rg8uint", 33337: "rg16sint", 33338: "rg16uint", 33339: "rg32sint", 33340: "rg32uint", 33778: "bc2-rgba-unorm", 33779: "bc3-rgba-unorm", 34836: "rgba32float", 34842: "rgba16float", 35056: "depth24plus-stencil8", 35898: "rg11b10ufloat", 35901: "rgb9e5ufloat", 35907: "rgba8unorm-srgb", 36012: "depth32float", 36013: "depth32float-stencil8", 36168: "stencil8", 36208: "rgba32uint", 36214: "rgba16uint", 36220: "rgba8uint", 36226: "rgba32sint", 36232: "rgba16sint", 36238: "rgba8sint", 36492: "bc7-rgba-unorm", 36756: "r8snorm", 36757: "rg8snorm", 36759: "rgba8snorm", 37496: "etc2-rgba8unorm", 37808: "astc-4x4-unorm" }; function qd (r) { let t = D1[r]; if (t) return t; throw new Error(`Unsupported glInternalFormat: ${r}`) } c(qd, "glFormatToGPUFormat"); var L1 = { 23: "rgb8unorm", 37: "rgba8unorm", 43: "rgba8unorm-srgb" }; function Zd (r) { let t = L1[r]; if (t) return t; throw new Error(`Unsupported VkFormat: ${r}`) } c(Zd, "vkFormatToGPUFormat"); function Lb (r) { return r.classId === 2 ? Zd(r.vkFormat) : qd(r.glInternalformat) } c(Lb, "getTextureFormatFromKTXTexture"); var H1 = { "bc3-rgba-unorm": "BC3_RGBA", "bc7-rgba-unorm": "BC7_M5_RGBA", "etc2-rgba8unorm": "ETC2_RGBA", "astc-4x4-unorm": "ASTC_4x4_RGBA", rgba8unorm: "RGBA32", rg11b10ufloat: "R11F_G11F_B10F" }; function Hb (r) { let t = H1[r]; if (t) return t; throw new Error(`Unsupported transcoderFormat: ${r}`) } c(Hb, "gpuFormatToKTXBasisTranscoderFormat"); S(); Xr(); S(); var ta = ["basis", "bc7", "bc6h", "astc", "etc2", "bc5", "bc4", "bc3", "bc2", "bc1", "eac"], Nb = { extension: x.ResolveParser, test: r => vt(r, [".ktx", ".ktx2", ".dds"]), parse: r => { let t, e = r.split("."); if (e.length > 2) { let s = e[e.length - 2]; ta.includes(s) && (t = s) } else t = e[e.length - 1]; return { resolution: parseFloat(Dt.RETINA_PREFIX.exec(r)?.[1] ?? "1"), format: t, src: r } } }; var e_, Wb = { extension: { type: x.DetectionParser, priority: 2 }, test: async () => !!(await cr() || ar()), add: async r => { let t = await Zn(); return e_ = N1(t), [...e_, ...r] }, remove: async r => e_ ? r.filter(t => !(t in e_)) : r }; function N1 (r) { let t = ["basis"], e = {}; return r.forEach(s => { let o = s.split("-")[0]; o && !e[o] && (e[o] = !0, t.push(o)) }), t.sort((s, o) => { let i = ta.indexOf(s), n = ta.indexOf(o); return i === -1 ? 1 : n === -1 ? -1 : i - n }), t } c(N1, "extractExtensionsForCompressedTextureFormats"); te(); vo(); var W1 = new it, Xb = c(class { cull (t, e, s = !0) { this._cullRecursive(t, e, s) } _cullRecursive (t, e, s = !0) { if (t.cullable && t.measurable && t.includeInBuild) { let o = t.cullArea ?? Ye(t, s, W1); t.culled = !(o.x >= e.x + e.width || o.y >= e.y + e.height || o.x + o.width <= e.x || o.y + o.height <= e.y) } if (!(!t.cullableChildren || t.culled || !t.renderable || !t.measurable || !t.includeInBuild)) for (let o = 0; o < t.children.length; o++)this._cullRecursive(t.children[o], e, s) } }, "_Culler"); Xb.shared = new Xb; var Qd = Xb; S(); var ea = class { static init () { this._renderRef = this.render.bind(this), this.render = () => { Qd.shared.cull(this.stage, this.renderer.screen), this.renderer.render({ container: this.stage }) } } static destroy () { this.render = this._renderRef } }; c(ea, "CullerPlugin"); ea.extension = { priority: 10, type: x.Application, name: "culler" }; gf(); ft(); Hf(); var B0 = Tt("/node_modules/@xmldom/xmldom?_v=0.8.10&_env=prod"), zb = { createCanvas: (r, t) => new OffscreenCanvas(r ?? 0, t ?? 0), getCanvasRenderingContext2D: () => OffscreenCanvasRenderingContext2D, getWebGLRenderingContext: () => WebGLRenderingContext, getNavigator: () => navigator, getBaseUrl: () => globalThis.location.href, getFontFaceSet: () => globalThis.fonts, fetch: (r, t) => fetch(r, t), parseXML: r => new B0.DOMParser().parseFromString(r, "text/xml") }; Df(); hl(); al(); ha(); Lf(); da(); cl(); ll(); S(); xe(); Pe(); Ot(); ir(); var xo = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`; var Jd = `
in vec2 vTextureCoord;

out vec4 finalColor;

uniform float uAlpha;
uniform sampler2D uTexture;

void main()
{
    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;
}
`; var bc = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uTexture, uSampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`; var A0 = c(class w0 extends Nt { constructor(t) { t = { ...w0.defaultOptions, ...t }; let e = ht.from({ vertex: { source: bc, entryPoint: "mainVertex" }, fragment: { source: bc, entryPoint: "mainFragment" } }), s = bt.from({ vertex: xo, fragment: Jd, name: "alpha-filter" }), { alpha: o, ...i } = t, n = new et({ uAlpha: { value: o, type: "f32" } }); super({ ...i, gpuProgram: e, glProgram: s, resources: { alphaUniforms: n } }) } get alpha () { return this.resources.alphaUniforms.uniforms.uAlpha } set alpha (t) { this.resources.alphaUniforms.uniforms.uAlpha = t } }, "_AlphaFilter"); A0.defaultOptions = { alpha: 1 }; var Vb = A0; br(); Re(); lt(); ir(); br(); Re(); ir(); xe(); var ra = { 5: [.153388, .221461, .250301], 7: [.071303, .131514, .189879, .214607], 9: [.028532, .067234, .124009, .179044, .20236], 11: [.0093, .028002, .065984, .121703, .175713, .198596], 13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641], 15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448] }; var X1 = ["in vec2 vBlurTexCoords[%size%];", "uniform sampler2D uTexture;", "out vec4 finalColor;", "void main(void)", "{", "    finalColor = vec4(0.0);", "    %blur%", "}"].join(`
`); function tf (r) {
          let t = ra[r], e = t.length, s = X1, o = "", i = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;", n; for (let a = 0; a < r; a++) {
            let l = i.replace("%index%", a.toString()); n = a, a >= e && (n = r - a - 1), l = l.replace("%value%", t[n].toString()), o += l, o += `
`} return s = s.replace("%blur%", o), s = s.replace("%size%", r.toString()), s
        } c(tf, "generateBlurFragSource"); var z1 = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`; function ef (r, t) {
          let e = Math.ceil(r / 2), s = z1, o = "", i; t ? i = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : i = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);"; for (let n = 0; n < r; n++) {
            let a = i.replace("%index%", n.toString()); a = a.replace("%sampleIndex%", `${n - (e - 1)}.0`), o += a, o += `
`} return s = s.replace("%blur%", o), s = s.replace("%size%", r.toString()), s = s.replace("%dimension%", t ? "z" : "w"), s
        } c(ef, "generateBlurVertSource"); function rf (r, t) { let e = ef(t, r), s = tf(t); return bt.from({ vertex: e, fragment: s, name: `blur-${r ? "horizontal" : "vertical"}-pass-filter` }) } c(rf, "generateBlurGlProgram"); Pe(); var sf = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let strength = gfu.uInputSize.w * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`; function of (r, t) {
          let e = ra[t], s = e.length, o = [], i = [], n = []; for (let d = 0; d < t; d++) { o[d] = `@location(${d}) offset${d}: vec2<f32>,`, r ? i[d] = `filteredCord + vec2(${d - s + 1} * strength, 0.0),` : i[d] = `filteredCord + vec2(0.0, ${d - s + 1} * strength),`; let f = d < s ? d : t - d - 1, p = e[f].toString(); n[d] = `finalColor += textureSample(uTexture, uSampler, offset${d}) * ${p};` } let a = o.join(`
`), l = i.join(`
`), h = n.join(`
`), u = sf.replace("%blur-struct%", a).replace("%blur-vertex-out%", l).replace("%blur-fragment-in%", a).replace("%blur-sampling%", h); return ht.from({ vertex: { source: u, entryPoint: "mainVertex" }, fragment: { source: u, entryPoint: "mainFragment" } })
        } c(of, "generateBlurProgram"); var R0 = c(class M0 extends Nt { constructor(t) { t = { ...M0.defaultOptions, ...t }; let e = rf(t.horizontal, t.kernelSize), s = of(t.horizontal, t.kernelSize); super({ glProgram: e, gpuProgram: s, resources: { blurUniforms: { uStrength: { value: 0, type: "f32" } } }, ...t }), this.horizontal = t.horizontal, this._quality = 0, this.quality = t.quality, this.blur = t.strength, this._uniforms = this.resources.blurUniforms.uniforms } apply (t, e, s, o) { if (this._uniforms.uStrength = this.strength / this.passes, this.passes === 1) t.applyFilter(this, e, s, o); else { let i = gt.getSameSizeTexture(e), n = e, a = i; this._state.blend = !1; for (let l = 0; l < this.passes - 1; l++) { t.applyFilter(this, n, a, t.renderer.type === yt.WEBGPU); let h = a; a = n, n = h } this._state.blend = !0, t.applyFilter(this, n, s, o), gt.returnTexture(i) } } get blur () { return this.strength } set blur (t) { this.padding = 1 + Math.abs(t) * 2, this.strength = t } get quality () { return this._quality } set quality (t) { this._quality = t, this.passes = t } }, "_BlurFilterPass"); R0.defaultOptions = { strength: 8, quality: 4, kernelSize: 5 }; var sa = R0; var oa = class extends Nt { constructor(...t) { let e = t[0] ?? {}; typeof e == "number" && (w(G, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"), e = { strength: e }, t[1] && (e.quality = t[1]), t[2] && (e.resolution = t[2]), t[3] && (e.kernelSize = t[3])), e = { ...sa.defaultOptions, ...e }; let { strength: s, quality: o, ...i } = e; super({ ...i, compatibleRenderers: yt.BOTH, resources: {} }), this._repeatEdgePixels = !1, this.blurXFilter = new sa({ horizontal: !1, ...e }), this.blurYFilter = new sa({ horizontal: !0, ...e }), this.quality = o, this.blur = s, this.repeatEdgePixels = !1 } apply (t, e, s, o) { let i = Math.abs(this.blurXFilter.strength), n = Math.abs(this.blurYFilter.strength); if (i && n) { let a = gt.getSameSizeTexture(e); this.blurXFilter.apply(t, e, a, !0), this.blurYFilter.apply(t, a, s, o), gt.returnTexture(a) } else n ? this.blurYFilter.apply(t, e, s, o) : this.blurXFilter.apply(t, e, s, o) } updatePadding () { this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2 } get blur () { return this.blurXFilter.blur } set blur (t) { this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding() } get quality () { return this.blurXFilter.quality } set quality (t) { this.blurXFilter.quality = this.blurYFilter.quality = t } get blurX () { return this.blurXFilter.blur } set blurX (t) { this.blurXFilter.blur = t, this.updatePadding() } get blurY () { return this.blurYFilter.blur } set blurY (t) { this.blurYFilter.blur = t, this.updatePadding() } get blendMode () { return this.blurYFilter.blendMode } set blendMode (t) { this.blurYFilter.blendMode = t } get repeatEdgePixels () { return this._repeatEdgePixels } set repeatEdgePixels (t) { this._repeatEdgePixels = t, this.updatePadding() } }; c(oa, "BlurFilter"); oa.defaultOptions = { strength: 8, quality: 4, kernelSize: 5 }; $t(); xe(); Pe(); Ot(); ir(); var nf = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uColorMatrix[20];
uniform float uAlpha;

uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;

    if (uAlpha == 0.0) {
        finalColor = color;
        return;
    }

    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    vec4 result;

    result.r = (uColorMatrix[0] * color.r);
        result.r += (uColorMatrix[1] * color.g);
        result.r += (uColorMatrix[2] * color.b);
        result.r += (uColorMatrix[3] * color.a);
        result.r += uColorMatrix[4];

    result.g = (uColorMatrix[5] * color.r);
        result.g += (uColorMatrix[6] * color.g);
        result.g += (uColorMatrix[7] * color.b);
        result.g += (uColorMatrix[8] * color.a);
        result.g += uColorMatrix[9];

    result.b = (uColorMatrix[10] * color.r);
       result.b += (uColorMatrix[11] * color.g);
       result.b += (uColorMatrix[12] * color.b);
       result.b += (uColorMatrix[13] * color.a);
       result.b += uColorMatrix[14];

    result.a = (uColorMatrix[15] * color.r);
       result.a += (uColorMatrix[16] * color.g);
       result.a += (uColorMatrix[17] * color.b);
       result.a += (uColorMatrix[18] * color.a);
       result.a += uColorMatrix[19];

    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    finalColor = vec4(rgb, result.a);
}
`; var yc = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct ColorMatrixUniforms {
  uColorMatrix:array<vec4<f32>, 5>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;
@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
  };
  
fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
  );
}


@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {


  var c = textureSample(uTexture, uSampler, uv);
  
  if (colorMatrixUniforms.uAlpha == 0.0) {
    return c;
  }

 
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.r /= c.a;
      c.g /= c.a;
      c.b /= c.a;
    }

    var cm = colorMatrixUniforms.uColorMatrix;


    var result = vec4<f32>(0.);

    result.r = (cm[0][0] * c.r);
    result.r += (cm[0][1] * c.g);
    result.r += (cm[0][2] * c.b);
    result.r += (cm[0][3] * c.a);
    result.r += cm[1][0];

    result.g = (cm[1][1] * c.r);
    result.g += (cm[1][2] * c.g);
    result.g += (cm[1][3] * c.b);
    result.g += (cm[2][0] * c.a);
    result.g += cm[2][1];

    result.b = (cm[2][2] * c.r);
    result.b += (cm[2][3] * c.g);
    result.b += (cm[3][0] * c.b);
    result.b += (cm[3][1] * c.a);
    result.b += cm[3][2];

    result.a = (cm[3][3] * c.r);
    result.a += (cm[4][0] * c.g);
    result.a += (cm[4][1] * c.b);
    result.a += (cm[4][2] * c.a);
    result.a += cm[4][3];

    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);

    rgb.r *= result.a;
    rgb.g *= result.a;
    rgb.b *= result.a;

    return vec4(rgb, result.a);
}`; var vc = class extends Nt { constructor(t = {}) { let e = new et({ uColorMatrix: { value: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], type: "f32", size: 20 }, uAlpha: { value: 1, type: "f32" } }), s = ht.from({ vertex: { source: yc, entryPoint: "mainVertex" }, fragment: { source: yc, entryPoint: "mainFragment" } }), o = bt.from({ vertex: xo, fragment: nf, name: "color-matrix-filter" }); super({ ...t, gpuProgram: s, glProgram: o, resources: { colorMatrixUniforms: e } }), this.alpha = 1 } _loadMatrix (t, e = !1) { let s = t; e && (this._multiply(s, this.matrix, t), s = this._colorMatrix(s)), this.resources.colorMatrixUniforms.uniforms.uColorMatrix = s, this.resources.colorMatrixUniforms.update() } _multiply (t, e, s) { return t[0] = e[0] * s[0] + e[1] * s[5] + e[2] * s[10] + e[3] * s[15], t[1] = e[0] * s[1] + e[1] * s[6] + e[2] * s[11] + e[3] * s[16], t[2] = e[0] * s[2] + e[1] * s[7] + e[2] * s[12] + e[3] * s[17], t[3] = e[0] * s[3] + e[1] * s[8] + e[2] * s[13] + e[3] * s[18], t[4] = e[0] * s[4] + e[1] * s[9] + e[2] * s[14] + e[3] * s[19] + e[4], t[5] = e[5] * s[0] + e[6] * s[5] + e[7] * s[10] + e[8] * s[15], t[6] = e[5] * s[1] + e[6] * s[6] + e[7] * s[11] + e[8] * s[16], t[7] = e[5] * s[2] + e[6] * s[7] + e[7] * s[12] + e[8] * s[17], t[8] = e[5] * s[3] + e[6] * s[8] + e[7] * s[13] + e[8] * s[18], t[9] = e[5] * s[4] + e[6] * s[9] + e[7] * s[14] + e[8] * s[19] + e[9], t[10] = e[10] * s[0] + e[11] * s[5] + e[12] * s[10] + e[13] * s[15], t[11] = e[10] * s[1] + e[11] * s[6] + e[12] * s[11] + e[13] * s[16], t[12] = e[10] * s[2] + e[11] * s[7] + e[12] * s[12] + e[13] * s[17], t[13] = e[10] * s[3] + e[11] * s[8] + e[12] * s[13] + e[13] * s[18], t[14] = e[10] * s[4] + e[11] * s[9] + e[12] * s[14] + e[13] * s[19] + e[14], t[15] = e[15] * s[0] + e[16] * s[5] + e[17] * s[10] + e[18] * s[15], t[16] = e[15] * s[1] + e[16] * s[6] + e[17] * s[11] + e[18] * s[16], t[17] = e[15] * s[2] + e[16] * s[7] + e[17] * s[12] + e[18] * s[17], t[18] = e[15] * s[3] + e[16] * s[8] + e[17] * s[13] + e[18] * s[18], t[19] = e[15] * s[4] + e[16] * s[9] + e[17] * s[14] + e[18] * s[19] + e[19], t } _colorMatrix (t) { let e = new Float32Array(t); return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e } brightness (t, e) { let s = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(s, e) } tint (t, e) { let [s, o, i] = j.shared.setValue(t).toArray(), n = [s, 0, 0, 0, 0, 0, o, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(n, e) } greyscale (t, e) { let s = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(s, e) } grayscale (t, e) { this.greyscale(t, e) } blackAndWhite (t) { let e = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } hue (t, e) { t = (t || 0) / 180 * Math.PI; let s = Math.cos(t), o = Math.sin(t), i = Math.sqrt, n = 1 / 3, a = i(n), l = s + (1 - s) * n, h = n * (1 - s) - a * o, u = n * (1 - s) + a * o, d = n * (1 - s) + a * o, f = s + n * (1 - s), p = n * (1 - s) - a * o, g = n * (1 - s) - a * o, b = n * (1 - s) + a * o, _ = s + n * (1 - s), y = [l, h, u, 0, 0, d, f, p, 0, 0, g, b, _, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(y, e) } contrast (t, e) { let s = (t || 0) + 1, o = -.5 * (s - 1), i = [s, 0, 0, 0, o, 0, s, 0, 0, o, 0, 0, s, 0, o, 0, 0, 0, 1, 0]; this._loadMatrix(i, e) } saturate (t = 0, e) { let s = t * 2 / 3 + 1, o = (s - 1) * -.5, i = [s, o, o, 0, 0, o, s, o, 0, 0, o, o, s, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(i, e) } desaturate () { this.saturate(-1) } negative (t) { let e = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } sepia (t) { let e = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } technicolor (t) { let e = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } polaroid (t) { let e = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } toBGR (t) { let e = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } kodachrome (t) { let e = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } browni (t) { let e = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } vintage (t) { let e = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } colorTone (t, e, s, o, i) { t = t || .2, e = e || .15, s = s || 16770432, o = o || 3375104; let n = j.shared, [a, l, h] = n.setValue(s).toArray(), [u, d, f] = n.setValue(o).toArray(), p = [.3, .59, .11, 0, 0, a, l, h, t, 0, u, d, f, e, 0, a - u, l - d, h - f, 0, 0]; this._loadMatrix(p, i) } night (t, e) { t = t || .1; let s = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(s, e) } predator (t, e) { let s = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0]; this._loadMatrix(s, e) } lsd (t) { let e = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) } reset () { let t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(t, !1) } get matrix () { return this.resources.colorMatrixUniforms.uniforms.uColorMatrix } set matrix (t) { this.resources.colorMatrixUniforms.uniforms.uColorMatrix = t } get alpha () { return this.resources.colorMatrixUniforms.uniforms.uAlpha } set alpha (t) { this.resources.colorMatrixUniforms.uniforms.uAlpha = t } }; c(vc, "ColorMatrixFilter"); ot(); ce(); xe(); Pe(); Ot(); zr(); lt(); ir(); var af = `
in vec2 vTextureCoord;
in vec2 vFilterUv;

out vec4 finalColor;

uniform sampler2D uTexture;
uniform sampler2D uMapTexture;

uniform vec4 uInputClamp;
uniform highp vec4 uInputSize;
uniform mat2 uRotation;
uniform vec2 uScale;

void main()
{
    vec4 map = texture(uMapTexture, vFilterUv);
    
    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; 

    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));
}
`; var cf = `in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 vFilterUv;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

uniform mat3 uFilterMatrix;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( void )
{
  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;
}


void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
    vFilterUv = getFilterCoord();
}
`; var Sc = `
struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct DisplacementUniforms {
  uFilterMatrix:mat3x3<f32>,
  uScale:vec2<f32>,
  uRotation:mat2x2<f32>
};



@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;
@group(1) @binding(1) var uMapTexture: texture_2d<f32>;
@group(1) @binding(2) var uMapSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var map = textureSample(uMapTexture, uMapSampler, filterUv);

    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; 
   
    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));
}`; var Tc = class extends Nt { constructor(...t) { let e = t[0]; e instanceof wt && (t[1] && w(G, "DisplacementFilter now uses options object instead of params. {sprite, scale}"), e = { sprite: e, scale: t[1] }); let { sprite: s, scale: o, ...i } = e, n = o ?? 20; typeof n == "number" && (n = new V(n, n)); let a = new et({ uFilterMatrix: { value: new B, type: "mat3x3<f32>" }, uScale: { value: n, type: "vec2<f32>" }, uRotation: { value: new Float32Array([0, 0, 0, 0]), type: "mat2x2<f32>" } }), l = bt.from({ vertex: cf, fragment: af, name: "displacement-filter" }), h = ht.from({ vertex: { source: Sc, entryPoint: "mainVertex" }, fragment: { source: Sc, entryPoint: "mainFragment" } }), u = s.texture.source; super({ ...i, gpuProgram: h, glProgram: l, resources: { filterUniforms: a, uMapTexture: u, uMapSampler: u.style } }), this._sprite = e.sprite, this._sprite.renderable = !1 } apply (t, e, s, o) { let i = this.resources.filterUniforms.uniforms; t.calculateSpriteMatrix(i.uFilterMatrix, this._sprite); let n = this._sprite.worldTransform, a = Math.sqrt(n.a * n.a + n.b * n.b), l = Math.sqrt(n.c * n.c + n.d * n.d); a !== 0 && l !== 0 && (i.uRotation[0] = n.a / a, i.uRotation[1] = n.b / a, i.uRotation[2] = n.c / l, i.uRotation[3] = n.d / l), this.resources.uMapTexture = this._sprite.texture.source, t.applyFilter(this, e, s, o) } get scale () { return this.resources.filterUniforms.uniforms.uScale } }; c(Tc, "DisplacementFilter"); xe(); Pe(); Ot(); ir(); var lf = `
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) *  uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    finalColor = color;
}
`; var Ec = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct NoiseUniforms {
  uNoise:f32,
  uSeed:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

fn rand(co:vec2<f32>) -> f32
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}



@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);
  
    
    var sample = textureSample(uTexture, uSampler, uv);
    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);
    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;
  
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (sample.a > 0.0) {
      sample.r /= sample.a;
      sample.g /= sample.a;
      sample.b /= sample.a;
    }

    sample.r += diff;
    sample.g += diff;
    sample.b += diff;

    // Premultiply alpha again.
    sample.r *= sample.a;
    sample.g *= sample.a;
    sample.b *= sample.a;
    
    return sample;
}`; var G0 = c(class U0 extends Nt { constructor(t = {}) { t = { ...U0.defaultOptions, ...t }; let e = ht.from({ vertex: { source: Ec, entryPoint: "mainVertex" }, fragment: { source: Ec, entryPoint: "mainFragment" } }), s = bt.from({ vertex: xo, fragment: lf, name: "noise-filter" }), { noise: o, seed: i, ...n } = t; super({ ...n, gpuProgram: e, glProgram: s, resources: { noiseUniforms: new et({ uNoise: { value: 1, type: "f32" }, uSeed: { value: 1, type: "f32" } }) } }), this.noise = o, this.seed = i ?? Math.random() } get noise () { return this.resources.noiseUniforms.uniforms.uNoise } set noise (t) { this.resources.noiseUniforms.uniforms.uNoise = t } get seed () { return this.resources.noiseUniforms.uniforms.uSeed } set seed (t) { this.resources.noiseUniforms.uniforms.uSeed = t } }, "_NoiseFilter"); G0.defaultOptions = { noise: .5 }; var Yb = G0; ir(); aa(); Im(); Dm(); ax(); var $b = `fn getLuminosity(c: vec3<f32>) -> f32 {
  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
}

fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {
  let d: f32 = lum - getLuminosity(c);
  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);

  // clip back into legal range
  let newLum: f32 = getLuminosity(newColor);
  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));
  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));

  let t1: f32 = newLum / (newLum - cMin);
  let t2: f32 = (1.0 - newLum) / (cMax - newLum);

  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));

  return finalColor;
}

fn getSaturation(c: vec3<f32>) -> f32 {
  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
}

// Set saturation if color components are sorted in ascending order.
fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {
  var result: vec3<f32>;
  if (cSorted.z > cSorted.x) {
    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));
    result = vec3<f32>(0.0, newY, s);
  } else {
    result = vec3<f32>(0.0, 0.0, 0.0);
  }
  return vec3<f32>(result.x, result.y, result.z);
}

fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {
    var result: vec3<f32> = c;

    if (c.r <= c.g && c.r <= c.b) {
        if (c.g <= c.b) {
            result = setSaturationMinMidMax(result, s);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.r, temp.b, temp.g);
        }
    } else if (c.g <= c.r && c.g <= c.b) {
        if (c.r <= c.b) {
            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.g, temp.r, temp.b);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.g, temp.b, temp.r);
        }
    } else {
        if (c.r <= c.g) {
            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.b, temp.r, temp.g);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.b, temp.g, temp.r);
        }
    }

    return result;
}`; ox(); ix(); nx(); gl(); ot(); zc(); wi(); jl(); bo(); ce(); function Pc (r, t, e, s, o, i, n, a) { let l = n - e, h = a - s, u = o - e, d = i - s, f = r - e, p = t - s, g = l * l + h * h, b = l * u + h * d, _ = l * f + h * p, y = u * u + d * d, v = u * f + d * p, T = 1 / (g * y - b * b), P = (y * _ - b * v) * T, M = (g * v - b * _) * T; return P >= 0 && M >= 0 && P + M < 1 } c(Pc, "pointInTriangle"); vp(); Sp(); Tp(); Gt(); Pp(); jl(); Gt(); var ni = class { constructor(t = 0, e = 0, s = 0, o = 0, i = 0, n = 0) { this.type = "triangle", this.x = t, this.y = e, this.x2 = s, this.y2 = o, this.x3 = i, this.y3 = n } contains (t, e) { let s = (this.x - this.x3) * (e - this.y3) - (this.y - this.y3) * (t - this.x3), o = (this.x2 - this.x) * (e - this.y) - (this.y2 - this.y) * (t - this.x); if (s < 0 != o < 0 && s !== 0 && o !== 0) return !1; let i = (this.x3 - this.x2) * (e - this.y2) - (this.y3 - this.y2) * (t - this.x2); return i === 0 || i < 0 == s + o <= 0 } strokeContains (t, e, s) { let o = s / 2, i = o * o, { x: n, x2: a, x3: l, y: h, y2: u, y3: d } = this; return ns(t, e, n, h, a, d) <= i || ns(t, e, a, u, l, d) <= i || ns(t, e, l, d, n, h) <= i } clone () { return new ni(this.x, this.y, this.x2, this.y2, this.x3, this.y3) } copyFrom (t) { return this.x = t.x, this.y = t.y, this.x2 = t.x2, this.y2 = t.y2, this.x3 = t.x3, this.y3 = t.y3, this } copyTo (t) { return t.copyFrom(this), t } getBounds (t) { t = t || new H; let e = Math.min(this.x, this.x2, this.x3), s = Math.max(this.x, this.x2, this.x3), o = Math.min(this.y, this.y2, this.y3), i = Math.max(this.y, this.y2, this.y3); return t.x = e, t.y = o, t.width = s - e, t.height = i - o, t } }; c(ni, "Triangle"); It(); Eo(); Po(); var F0 = c(class I0 { constructor(t) { this._tick = () => { this.timeout = setTimeout(this._processQueue, 0) }, this._processQueue = () => { let { queue: e } = this, s = 0; for (; e.length && s < I0.uploadsPerFrame;) { let o = e.shift(); this.uploadQueueItem(o), s++ } e.length ? Bt.system.addOnce(this._tick, this, re.UTILITY) : this._resolve() }, this.renderer = t, this.queue = [], this.resolves = [] } getQueue () { return [...this.queue] } add (t) { let e = Array.isArray(t) ? t : [t]; for (let s of e) s instanceof N ? this._addContainer(s) : this.resolveQueueItem(s, this.queue); return this } _addContainer (t) { this.resolveQueueItem(t, this.queue); for (let e of t.children) this._addContainer(e) } upload (t) { return t && this.add(t), new Promise(e => { this.queue.length ? (this.resolves.push(e), this.dedupeQueue(), Bt.system.addOnce(this._tick, this, re.UTILITY)) : e() }) } dedupeQueue () { let t = Object.create(null), e = 0; for (let s = 0; s < this.queue.length; s++) { let o = this.queue[s]; t[o.uid] || (t[o.uid] = !0, this.queue[e++] = o) } this.queue.length = e } _resolve () { let { resolves: t } = this, e = t.slice(0); t.length = 0; for (let s of e) s() } }, "_PrepareBase"); F0.uploadsPerFrame = 4; var uf = F0; Lt(); rt(); It(); mu(); Fo(); wo(); Se(); rt(); lt(); It(); Rr(); var _e = class extends N { constructor(...t) { let e = t[0]; e instanceof oe && (w(G, "Mesh: use new Mesh({ geometry, shader }) instead"), e = { geometry: e, shader: t[1] }, t[3] && (w(G, "Mesh: drawMode argument has been removed, use geometry.topology instead"), e.geometry.topology = t[3])); let { geometry: s, shader: o, texture: i, roundPixels: n, state: a, ...l } = e; super({ label: "Mesh", ...l }), this.renderPipeId = "mesh", this.canBundle = !0, this._roundPixels = 0, this.allowChildren = !1, this.shader = o, this.texture = i ?? o?.texture ?? E.WHITE, this.state = a ?? Pt.for2d(), this._geometry = s, this._geometry.on("update", this.onViewUpdate, this), this.roundPixels = n ?? !1 } get roundPixels () { return !!this._roundPixels } set roundPixels (t) { this._roundPixels = t ? 1 : 0 } get material () { return w(G, "mesh.material property has been removed, use mesh.shader instead"), this._shader } set shader (t) { this._shader !== t && (this._shader = t, this.onViewUpdate()) } get shader () { return this._shader } set geometry (t) { this._geometry !== t && (this._geometry?.off("update", this.onViewUpdate, this), t.on("update", this.onViewUpdate, this), this._geometry = t, this.onViewUpdate()) } get geometry () { return this._geometry } set texture (t) { t || (t = E.EMPTY); let e = this._texture; e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this.shader && (this.shader.texture = t), this._texture = t, this.onViewUpdate()) } get texture () { return this._texture } get batched () { return this._shader ? !1 : this._geometry instanceof qt ? this._geometry.batchMode === "auto" ? this._geometry.positions.length / 2 <= 100 : this._geometry.batchMode === "batch" : !1 } get bounds () { return this._geometry.bounds } addBounds (t) { t.addBounds(this.geometry.bounds) } containsPoint (t) { let { x: e, y: s } = t; if (!this.bounds.containsPoint(e, s)) return !1; let o = this.geometry.getBuffer("aPosition").data, i = this.geometry.topology === "triangle-strip" ? 3 : 1; if (this.geometry.getIndex()) { let n = this.geometry.getIndex().data, a = n.length; for (let l = 0; l + 2 < a; l += i) { let h = n[l] * 2, u = n[l + 1] * 2, d = n[l + 2] * 2; if (Pc(e, s, o[h], o[h + 1], o[u], o[u + 1], o[d], o[d + 1])) return !0 } } else { let n = o.length / 2; for (let a = 0; a + 2 < n; a += i) { let l = a * 2, h = (a + 1) * 2, u = (a + 2) * 2; if (Pc(e, s, o[l], o[l + 1], o[h], o[h + 1], o[u], o[u + 1])) return !0 } } return !1 } onViewUpdate () { this._didChangeId += 4096, !this.didViewUpdate && (this.didViewUpdate = !0, this.renderGroup && this.renderGroup.onChildViewUpdate(this)) } destroy (t) { if (super.destroy(t), typeof t == "boolean" ? t : t?.texture) { let s = typeof t == "boolean" ? t : t?.textureSource; this._texture.destroy(s) } this._geometry?.off("update", this.onViewUpdate, this), this._texture = null, this._geometry = null, this._shader = null } }; c(_e, "Mesh"); zr(); rt(); Eo(); Po(); zr(); var ur = class extends wt { constructor(t, e = !0) { super(t[0] instanceof E ? t[0] : t[0].texture), this._textures = null, this._durations = null, this._autoUpdate = e, this._isConnectedToTicker = !1, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = !1, this._previousFrame = null, this.textures = t } stop () { this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Bt.shared.remove(this.update, this), this._isConnectedToTicker = !1)) } play () { this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Bt.shared.add(this.update, this, re.HIGH), this._isConnectedToTicker = !0)) } gotoAndStop (t) { this.stop(), this.currentFrame = t } gotoAndPlay (t) { this.currentFrame = t, this.play() } update (t) { if (!this._playing) return; let e = t.deltaTime, s = this.animationSpeed * e, o = this.currentFrame; if (this._durations !== null) { let i = this._currentTime % 1 * this._durations[this.currentFrame]; for (i += s / 60 * 1e3; i < 0;)this._currentTime--, i += this._durations[this.currentFrame]; let n = Math.sign(this.animationSpeed * e); for (this._currentTime = Math.floor(this._currentTime); i >= this._durations[this.currentFrame];)i -= this._durations[this.currentFrame] * n, this._currentTime += n; this._currentTime += i / this._durations[this.currentFrame] } else this._currentTime += s; this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : o !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < o || this.animationSpeed < 0 && this.currentFrame > o) && this.onLoop(), this._updateTexture()) } _updateTexture () { let t = this.currentFrame; this._previousFrame !== t && (this._previousFrame = t, this.texture = this._textures[t], this.updateAnchor && this.anchor.copyFrom(this.texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame)) } destroy () { this.stop(), super.destroy(), this.onComplete = null, this.onFrameChange = null, this.onLoop = null } static fromFrames (t) { let e = []; for (let s = 0; s < t.length; ++s)e.push(E.from(t[s])); return new ur(e) } static fromImages (t) { let e = []; for (let s = 0; s < t.length; ++s)e.push(E.from(t[s])); return new ur(e) } get totalFrames () { return this._textures.length } get textures () { return this._textures } set textures (t) { if (t[0] instanceof E) this._textures = t, this._durations = null; else { this._textures = [], this._durations = []; for (let e = 0; e < t.length; e++)this._textures.push(t[e].texture), this._durations.push(t[e].time) } this._previousFrame = null, this.gotoAndStop(0), this._updateTexture() } get currentFrame () { let t = Math.floor(this._currentTime) % this._textures.length; return t < 0 && (t += this._textures.length), t } set currentFrame (t) { if (t < 0 || t > this.totalFrames - 1) throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`); let e = this.currentFrame; this._currentTime = t, e !== this.currentFrame && this._updateTexture() } get playing () { return this._playing } get autoUpdate () { return this._autoUpdate } set autoUpdate (t) { t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Bt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Bt.shared.add(this.update, this), this._isConnectedToTicker = !0)) } }; c(ur, "AnimatedSprite"); Ke(); bo(); rt(); lt(); ot(); bo(); var ai = class { constructor({ matrix: t, observer: e } = {}) { this.dirty = !0, this._matrix = t ?? new B, this.observer = e, this.position = new at(this, 0, 0), this.scale = new at(this, 1, 1), this.pivot = new at(this, 0, 0), this.skew = new at(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1 } get matrix () { let t = this._matrix; return this.dirty && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this.dirty = !1), t } _onUpdate (t) { this.dirty = !0, t === this.skew && this.updateSkew(), this.observer?._onUpdate(this) } updateSkew () { this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = !0 } toString () { return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]` } setFromMatrix (t) { t.decompose(this), this.dirty = !0 } get rotation () { return this._rotation } set rotation (t) { this._rotation !== t && (this._rotation = t, this._onUpdate(this.skew)) } }; c(ai, "Transform"); It(); var O0 = c(class r_ extends N { constructor(...t) { let e = t[0] || {}; e instanceof E && (e = { texture: e }), t.length > 1 && (w(G, "use new TilingSprite({ texture, width:100, height:100 }) instead"), e.width = t[1], e.height = t[2]), e = { ...r_.defaultOptions, ...e }; let { texture: s, anchor: o, tilePosition: i, tileScale: n, tileRotation: a, width: l, height: h, applyAnchorToTexture: u, roundPixels: d, ...f } = e ?? {}; super({ label: "TilingSprite", ...f }), this.renderPipeId = "tilingSprite", this.canBundle = !0, this.batched = !0, this._roundPixels = 0, this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._boundsDirty = !0, this.allowChildren = !1, this._anchor = new at(this), this._applyAnchorToTexture = u, this.texture = s, this._width = l ?? s.width, this._height = h ?? s.height, this._tileTransform = new ai({ observer: { _onUpdate: () => this.onViewUpdate() } }), o && (this.anchor = o), this.tilePosition = i, this.tileScale = n, this.tileRotation = a, this.roundPixels = d ?? !1 } static from (t, e = {}) { return typeof t == "string" ? new r_({ texture: tt.get(t), ...e }) : new r_({ texture: t, ...e }) } get clampMargin () { return this._texture.textureMatrix.clampMargin } set clampMargin (t) { this._texture.textureMatrix.clampMargin = t } get anchor () { return this._anchor } set anchor (t) { typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t) } get tilePosition () { return this._tileTransform.position } set tilePosition (t) { this._tileTransform.position.copyFrom(t) } get tileScale () { return this._tileTransform.scale } set tileScale (t) { typeof t == "number" ? this._tileTransform.scale.set(t) : this._tileTransform.scale.copyFrom(t) } set tileRotation (t) { this._tileTransform.rotation = t } get tileRotation () { return this._tileTransform.rotation } get tileTransform () { return this._tileTransform } get roundPixels () { return !!this._roundPixels } set roundPixels (t) { this._roundPixels = t ? 1 : 0 } get bounds () { return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds } set texture (t) { t || (t = E.EMPTY); let e = this._texture; e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate()) } get texture () { return this._texture } set width (t) { this._width = t, this.onViewUpdate() } get width () { return this._width } set height (t) { this._height = t, this.onViewUpdate() } get height () { return this._height } _updateBounds () { let t = this._bounds, e = this._anchor, s = this._width, o = this._height; t.maxX = -e._x * s, t.minX = t.maxX + s, t.maxY = -e._y * o, t.minY = t.maxY + o } addBounds (t) { let e = this.bounds; t.addFrame(e.minX, e.minY, e.maxX, e.maxY) } containsPoint (t) { let e = this.bounds.minX, s = this.bounds.minY, o = -e * this._anchor._x, i = 0; return t.x >= o && t.x <= o + e && (i = -s * this._anchor._y, t.y >= i && t.y <= i + s) } onViewUpdate () { this._boundsDirty = !0, this._didTilingSpriteUpdate = !0, this._didChangeId += 4096, !this.didViewUpdate && (this.didViewUpdate = !0, this.renderGroup && this.renderGroup.onChildViewUpdate(this)) } destroy (t = !1) { if (super.destroy(t), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof t == "boolean" ? t : t?.texture) { let s = typeof t == "boolean" ? t : t?.textureSource; this._texture.destroy(s) } this._texture = null } }, "_TilingSprite"); O0.defaultOptions = { texture: E.EMPTY, anchor: { x: 0, y: 0 }, tilePosition: { x: 0, y: 0 }, tileScale: { x: 1, y: 1 }, tileRotation: 0, applyAnchorToTexture: !1 }; var hf = O0; bo(); lt(); te(); It(); var Xe = class extends N { constructor(t, e) { let { text: s, resolution: o, style: i, anchor: n, width: a, height: l, roundPixels: h, ...u } = t; super({ ...u }), this.batched = !0, this.resolution = null, this._didTextUpdate = !0, this._roundPixels = 0, this._bounds = new it, this._boundsDirty = !0, this._styleClass = e, this.text = s ?? "", this.style = i, this.resolution = o ?? null, this.allowChildren = !1, this._anchor = new at({ _onUpdate: () => { this.onViewUpdate() } }), n && (this.anchor = n), this.roundPixels = h ?? !1, a && (this.width = a), l && (this.height = l) } get anchor () { return this._anchor } set anchor (t) { typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t) } get roundPixels () { return !!this._roundPixels } set roundPixels (t) { this._roundPixels = t ? 1 : 0 } set text (t) { t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate()) } get text () { return this._text } get style () { return this._style } set style (t) { t = t || {}, this._style?.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate() } get bounds () { return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds } get width () { return Math.abs(this.scale.x) * this.bounds.width } set width (t) { this._setWidth(t, this.bounds.width) } get height () { return Math.abs(this.scale.y) * this.bounds.height } set height (t) { this._setHeight(t, this.bounds.height) } getSize (t) { return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t } setSize (t, e) { let s, o; typeof t != "object" ? (s = t, o = e ?? t) : (s = t.width, o = t.height ?? t.width), s !== void 0 && this._setWidth(s, this.bounds.width), o !== void 0 && this._setHeight(o, this.bounds.height) } addBounds (t) { let e = this.bounds; t.addFrame(e.minX, e.minY, e.maxX, e.maxY) } containsPoint (t) { let e = this.bounds.maxX, s = this.bounds.maxY, o = -e * this.anchor.x, i = 0; return t.x >= o && t.x <= o + e && (i = -s * this.anchor.y, t.y >= i && t.y <= i + s) } onViewUpdate () { this._didChangeId += 4096, this._boundsDirty = !0, !this.didViewUpdate && (this.didViewUpdate = !0, this._didTextUpdate = !0, this.renderGroup && this.renderGroup.onChildViewUpdate(this)) } _getKey () { return `${this.text}:${this._style.styleKey}` } destroy (t = !1) { super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t?.style) && this._style.destroy(t), this._style = null, this._text = null } }; c(Xe, "AbstractText"); function go (r, t) { let e = r[0] ?? {}; return (typeof e == "string" || r[1]) && (w(G, `use new ${t}({ text: "hi!", style }) instead`), e = { text: e, style: r[1] }), e } c(go, "ensureOptions"); Ji(); as(); var kr = class extends Xe { constructor(...t) { let e = go(t, "Text"); super(e, Ht), this.renderPipeId = "text" } _updateBounds () { let t = this._bounds, e = this._style.padding, s = this._anchor, o = Kt.measureText(this._text, this._style), { width: i, height: n } = o; t.minX = -s._x * i - e, t.maxX = t.minX + i, t.minY = -s._y * n - e, t.maxY = t.minY + n } }; c(kr, "Text"); var ci = class extends uf { resolveQueueItem (t, e) { return t instanceof N ? this.resolveContainerQueueItem(t, e) : t instanceof J || t instanceof E ? e.push(t.source) : t instanceof Vt && e.push(t), null } resolveContainerQueueItem (t, e) { t instanceof wt || t instanceof hf || t instanceof _e ? e.push(t.texture.source) : t instanceof kr ? e.push(t) : t instanceof Ee ? e.push(t.context) : t instanceof ur && t.textures.forEach(s => { s.source ? e.push(s.source) : e.push(s.texture.source) }) } resolveGraphicsContextQueueItem (t) { this.renderer.graphicsContext.getContextRenderData(t); let { instructions: e } = t; for (let s of e) if (s.action === "texture") { let { image: o } = s.data; return o.source } else if (s.action === "fill") { let { texture: o } = s.data.style; return o.source } return null } }; c(ci, "PrepareQueue"); S(); Lt(); Fo(); as(); Ga(); var li = class extends Xe { constructor(...t) { var e; let s = go(t, "BitmapText"); s.style ?? (s.style = s.style || {}), (e = s.style).fill ?? (e.fill = 16777215), super(s, Ht), this.renderPipeId = "bitmapText" } _updateBounds () { let t = this._bounds, e = this._style.padding, s = this._anchor, o = Br.measureText(this.text, this._style), i = o.scale, n = o.offsetY * i, a = o.width * i, l = o.height * i; t.minX = -s._x * a - e, t.maxX = t.minX + a, t.minY = -s._y * (l + n) - e, t.maxY = t.minY + l } }; c(li, "BitmapText"); Ha(); Zu(); var ui = class extends Xe { constructor(...t) { let e = go(t, "HtmlText"); super(e, ue), this.renderPipeId = "htmlText" } _updateBounds () { let t = this._bounds, e = this._style.padding, s = this._anchor, o = an(this.text, this._style), { width: i, height: n } = o; t.minX = -s._x * i - e, t.maxX = t.minX + i, t.minY = -s._y * n - e, t.maxY = t.minY + n } }; c(ui, "HTMLText"); var hi = class extends ci { uploadQueueItem (t) { t instanceof J ? this.uploadTextureSource(t) : t instanceof kr ? this.uploadText(t) : t instanceof ui ? this.uploadHTMLText(t) : t instanceof li ? this.uploadBitmapText(t) : t instanceof Vt && this.uploadGraphicsContext(t) } uploadTextureSource (t) { this.renderer.texture.initSource(t) } uploadText (t) { this.renderer.renderPipes.text.initGpuText(t) } uploadBitmapText (t) { this.renderer.renderPipes.bitmapText.initGpuText(t) } uploadHTMLText (t) { this.renderer.renderPipes.htmlText.initGpuText(t) } uploadGraphicsContext (t) { this.renderer.graphicsContext.getContextRenderData(t); let { instructions: e } = t; for (let s of e) if (s.action === "texture") { let { image: o } = s.data; this.uploadTextureSource(o.source) } else if (s.action === "fill") { let { texture: o } = s.data.style; this.uploadTextureSource(o.source) } return null } }; c(hi, "PrepareUpload"); var ia = class extends hi { destroy () { clearTimeout(this.timeout), this.renderer = null, this.queue = null, this.resolves = null } }; c(ia, "PrepareSystem"); ia.extension = { type: [x.WebGLSystem, x.WebGPUSystem], name: "prepare" }; qx(); Bl(); function jb (r) { let t = [], e = 0; for (let s = 0; s < r; s++)t[e] = { texture: { sampleType: "float", viewDimension: "2d", multisampled: !1 }, binding: e, visibility: GPUShaderStage.FRAGMENT }, e++, t[e] = { sampler: { type: "filtering" }, binding: e, visibility: GPUShaderStage.FRAGMENT }, e++; return t } c(jb, "generateGPULayout"); function Kb (r) { let t = {}, e = 0; for (let s = 0; s < r; s++)t[`textureSource${s + 1}`] = e++, t[`textureSampler${s + 1}`] = e++; return t } c(Kb, "generateLayout"); va(); Ym(); Ml(); sx(); lp(); Ze(); sr(); cm(); rm(); om(); im(); nm(); function qb (r) {
          let t = r.split(/([\n{}])/g).map(o => o.trim()).filter(o => o.length), e = ""; return t.map(o => { let i = e + o; return o === "{" ? e += "    " : o === "}" && (e = e.substr(0, e.length - 4), i = e + o), i }).join(`
`)
        } c(qb, "formatShader"); am(); lm(); Oo(); ko(); um(); Lo(); or(); _h(); Kf(); lx(); qf(); ux(); Kc(); _a(); ba(); var Cc = class { constructor(t) { this.priority = 0, this.pipe = "scissorMask", this.mask = t, this.mask.renderable = !1, this.mask.measurable = !1 } addBounds (t, e) { Vr(this.mask, t, e) } addLocalBounds (t, e) { Yr(this.mask, t, e) } containsPoint (t, e) { let s = this.mask; return e(s, t) } reset () { this.mask.measurable = !0, this.mask = null } destroy () { this.reset() } }; c(Cc, "ScissorMask"); Zf(); hx(); _a(); ba(); Zx(); Qx(); Jx(); Wo(); tg(); sg(); rg(); og(); ig(); ng(); hg(); ag(); ug(); dg(); fg(); La(); pg(); xe(); mg(); Eg(); Bg(); function Zb (r) {
          return r = r.replaceAll("texture2D", "texture").replaceAll("gl_FragColor", "finalColor").replaceAll("varying", "in"), r = `
        out vec4 finalColor;
    ${r}
    `, r
        } c(Zb, "migrateFragmentFromV7toV8"); xg(); ad(); Xh(); _g(); Sg(); zp(); Wp(); bg(); yg(); vg(); var V1 = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 }; function Qb (r) { return V1[r] } c(Qb, "mapSize"); ld(); Vp(); Yp(); $p(); jp(); Kp(); sd(); lg(); cg(); Cg(); Pg(); wg(); Ag(); Jh(); Rg(); Hg(); Mg(); Gg(); Sd(); Ug(); Ig(); Og(); kg(); Dg(); Fg(); Lg(); Ng(); Sx(); Tx(); xr(); qe(); function Jb (r, t) { let e = r.descriptor.size, s = t.gpu.device, o = new _t({ data: new Float32Array(24e5), usage: K.MAP_READ | K.COPY_DST }), i = t.buffer.createGPUBuffer(o), n = s.createCommandEncoder(); n.copyBufferToBuffer(t.buffer.getGPUBuffer(r), 0, i, 0, e), s.queue.submit([n.finish()]), i.mapAsync(GPUMapMode.READ, 0, e).then(() => { i.getMappedRange(0, e), i.unmap() }) } c(Jb, "GpuReadBuffer"); Mx(); Ex(); Px(); Cx(); Bx(); Rx(); Gx(); Ux(); Fx(); Ox(); kx(); Dx(); _r(); Pe(); Lx(); Oh(); wx(); qp(); Zp(); Ax(); Jp(); tm(); em(); Hx(); Nx(); zh(); Yx(); Wx(); Xx(); qh(); zx(); Vx(); $x(); dx(); fx(); xr(); Ja(); qe(); Al(); px(); xx(); lt(); var k0 = { POINTS: "point-list", LINES: "line-list", LINE_STRIP: "line-strip", TRIANGLES: "triangle-list", TRIANGLE_STRIP: "triangle-strip" }, ty = new Proxy(k0, { get (r, t) { return w(G, `DRAW_MODES.${t} is deprecated, use '${k0[t]}' instead`), r[t] } }); wo(); Gl(); ip(); sn(); np(); Ul(); sl(); gx(); Ix(); Rh(); $h(); Gt(); var Y1 = new H(0, 0, 1, 1); function ey (r, t, e) { e || (e = Y1); let s = t.pixelWidth, o = t.pixelHeight; return r.x = e.x * s | 0, r.y = e.y * o | 0, r.width = e.width * s | 0, r.height = e.height * o | 0, r } c(ey, "viewportFromFrame"); Qp(); Me(); Fh(); Ot(); Dh(); xp(); Hh(); kh(); bx(); Jr(); cp(); Se(); Mn(); Uh(); mh(); Yi(); lt(); var s_ = (r => (r[r.NONE = 0] = "NONE", r[r.LOW = 2] = "LOW", r[r.MEDIUM = 4] = "MEDIUM", r[r.HIGH = 8] = "HIGH", r))(s_ || {}), Bc = (r => (r.CLAMP = "clamp-to-edge", r.REPEAT = "repeat", r.MIRRORED_REPEAT = "mirror-repeat", r))(Bc || {}), ry = new Proxy(Bc, { get (r, t) { return w(G, `DRAW_MODES.${t} is deprecated, use '${Bc[t]}' instead`), r[t] } }), Ac = (r => (r.NEAREST = "nearest", r.LINEAR = "linear", r))(Ac || {}), sy = new Proxy(Ac, { get (r, t) { return w(G, `DRAW_MODES.${t} is deprecated, use '${Ac[t]}' instead`), r[t] } }); mx(); bl(); Mi(); Ao(); Lt(); Pl(); rt(); yx(); yl(); br(); Vf(); gl(); var wc = class { constructor() { this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8) } set (t, e, s) { let o = e.width, i = e.height; if (s) { let n = t.width / 2 / o, a = t.height / 2 / i, l = t.x / o + n, h = t.y / i + a; s = Q.add(s, Q.NW), this.x0 = l + n * Q.uX(s), this.y0 = h + a * Q.uY(s), s = Q.add(s, 2), this.x1 = l + n * Q.uX(s), this.y1 = h + a * Q.uY(s), s = Q.add(s, 2), this.x2 = l + n * Q.uX(s), this.y2 = h + a * Q.uY(s), s = Q.add(s, 2), this.x3 = l + n * Q.uX(s), this.y3 = h + a * Q.uY(s) } else this.x0 = t.x / o, this.y0 = t.y / i, this.x1 = (t.x + t.width) / o, this.y1 = t.y / i, this.x2 = (t.x + t.width) / o, this.y2 = (t.y + t.height) / i, this.x3 = t.x / o, this.y3 = (t.y + t.height) / i; this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3 } toString () { return `[pixi.js/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]` } }; c(wc, "TextureUvs"); var $1 = 0; function oy () { return $1++ } c(oy, "generateUID"); Mh(); sp(); zi(); function iy (r) { let t = r.toString(), e = t.indexOf("{"), s = t.lastIndexOf("}"); if (e === -1 || s === -1) throw new Error("getFunctionBody: No body found in function definition"); return t.slice(e + 1, s).trim() } c(iy, "parseFunctionBody"); vx(); Re(); te(); Om(); vo(); ca(); km(); vi(); _f(); bf(); yf(); Ef(); Pf(); Cf(); Bf(); It(); $m(); te(); It(); var Rc = class extends N { constructor(t) { typeof t == "function" && (t = { render: t }); let { render: e, ...s } = t; super({ label: "RenderContainer", ...s }), this.batched = !1, this.bounds = new it, this.canBundle = !1, this.renderPipeId = "customRender", e && (this.render = e), this.containsPoint = t.containsPoint ?? (() => !1), this.addBounds = t.addBounds ?? (() => !1) } render (t) { } }; c(Rc, "RenderContainer"); Af(); jm(); ex(); wf(); Wa(); Tf(); Km(); Ri(); bh(); Zm(); qm(); up(); function ny (r, t) { let e = t._scale, s = t._pivot, o = t._position, i = e._x, n = e._y, a = s._x, l = s._y; r.a = t._cx * i, r.b = t._sx * i, r.c = t._cy * n, r.d = t._sy * n, r.tx = o._x - (a * r.a + l * r.c), r.ty = o._y - (a * r.b + l * r.d) } c(ny, "updateLocalTransform"); Jm(); function ay (r, t, e) { let s = r.a, o = r.b, i = r.c, n = r.d, a = r.tx, l = r.ty, h = t.a, u = t.b, d = t.c, f = t.d; e.a = s * h + o * d, e.b = s * u + o * f, e.c = i * h + n * d, e.d = i * u + n * f, e.tx = a * h + l * d + t.tx, e.ty = a * u + l * f + t.ty } c(ay, "updateWorldTransform"); tx(); jx(); Xi(); Xm(); Il(); Kl(); Bp(); Zl(); Ap(); wp(); Ol(); fp(); Nl(); Wl(); Xl(); hp(); Ba(); iu(); mu(); Fo(); Ea(); mp(); wa(); Rp(); Mp(); Gp(); yp(); pp(); Gl(); Ul(); Rr(); Ol(); Nl(); Wl(); Xl(); wa(); var j1 = { rectangle: Li, polygon: Di, triangle: Hi, circle: Je, ellipse: Je, roundedRectangle: Je }; function cy (r) { r instanceof ne && (r = { path: r, textureMatrix: null, out: null }); let t = [], e = [], s = [], o = r.path.shapePath, i = r.textureMatrix; o.shapePrimitives.forEach(({ shape: l, transform: h }) => { let u = s.length, d = t.length / 2, f = [], p = j1[l.type]; p.build(l, f), h && Go(f, h), p.triangulate(f, t, 2, d, s, u); let g = e.length / 2; i ? (h && i.append(h.clone().invert()), Fi(t, 2, d, e, g, 2, t.length / 2 - d, i)) : Ii(e, g, 2, t.length / 2 - d) }); let n = r.out; return n ? (n.positions = new Float32Array(t), n.uvs = new Float32Array(e), n.indices = new Uint32Array(s), n) : new qt({ positions: new Float32Array(t), uvs: new Float32Array(e), indices: new Uint32Array(s) }) } c(cy, "buildGeometryFromPath"); nu(); dp(); Hl(); Ri(); oh(); var Mc = class extends _e { constructor(t) { let { texture: e, verticesX: s, verticesY: o, ...i } = t, n = new cn(me({ width: e.width, height: e.height, verticesX: s, verticesY: o })); super(me({ ...i, geometry: n, texture: e })), this.texture = e, this.autoResize = !0 } textureUpdated () { let t = this.geometry, { width: e, height: s } = this.texture; this.autoResize && (t.width !== e || t.height !== s) && (t.width = e, t.height = s, t.build({})) } set texture (t) { this._texture?.off("update", this.textureUpdated, this), super.texture = t, t.on("update", this.textureUpdated, this), this.textureUpdated() } get texture () { return this._texture } destroy (t) { this.texture.off("update", this.textureUpdated, this), super.destroy(t) } }; c(Mc, "MeshPlane"); oh(); Ri(); Rr(); var D0 = c(class L0 extends qt { constructor(t) { let { width: e, points: s, textureScale: o } = { ...L0.defaultOptions, ...t }; super({ positions: new Float32Array(s.length * 4), uvs: new Float32Array(s.length * 4), indices: new Uint32Array((s.length - 1) * 6) }), this.points = s, this._width = e, this.textureScale = o, this._build() } get width () { return this._width } _build () { let t = this.points; if (!t) return; let e = this.getBuffer("aPosition"), s = this.getBuffer("aUV"), o = this.getIndex(); if (t.length < 1) return; e.data.length / 4 !== t.length && (e.data = new Float32Array(t.length * 4), s.data = new Float32Array(t.length * 4), o.data = new Uint16Array((t.length - 1) * 6)); let i = s.data, n = o.data; i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1; let a = 0, l = t[0], h = this._width * this.textureScale, u = t.length; for (let f = 0; f < u; f++) { let p = f * 4; if (this.textureScale > 0) { let g = l.x - t[f].x, b = l.y - t[f].y, _ = Math.sqrt(g * g + b * b); l = t[f], a += _ / h } else a = f / (u - 1); i[p] = a, i[p + 1] = 0, i[p + 2] = a, i[p + 3] = 1 } let d = 0; for (let f = 0; f < u - 1; f++) { let p = f * 2; n[d++] = p, n[d++] = p + 1, n[d++] = p + 2, n[d++] = p + 2, n[d++] = p + 1, n[d++] = p + 3 } s.update(), o.update(), this.updateVertices() } updateVertices () { let t = this.points; if (t.length < 1) return; let e = t[0], s, o = 0, i = 0, n = this.buffers[0].data, a = t.length, l = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2; for (let h = 0; h < a; h++) { let u = t[h], d = h * 4; h < t.length - 1 ? s = t[h + 1] : s = u, i = -(s.x - e.x), o = s.y - e.y; let f = (1 - h / (a - 1)) * 10; f > 1 && (f = 1); let p = Math.sqrt(o * o + i * i); p < 1e-6 ? (o = 0, i = 0) : (o /= p, i /= p, o *= l, i *= l), n[d] = u.x + o, n[d + 1] = u.y + i, n[d + 2] = u.x - o, n[d + 3] = u.y - i, e = u } this.buffers[0].update() } update () { this.textureScale > 0 ? this._build() : this.updateVertices() } }, "_RopeGeometry"); D0.defaultOptions = { width: 200, points: [], textureScale: 0 }; var df = D0; var H0 = c(class N0 extends _e { constructor(t) { let { texture: e, points: s, textureScale: o, ...i } = { ...N0.defaultOptions, ...t }, n = new df(me({ width: e.height, points: s, textureScale: o })); o > 0 && (e.source.style.addressMode = "repeat"), super(me({ ...i, texture: e, geometry: n })), this.autoUpdate = !0, this.onRender = this._render } _render () { let t = this.geometry; (this.autoUpdate || t._width !== this.texture.height) && (t._width = this.texture.height, t.update()) } }, "_MeshRope"); H0.defaultOptions = { textureScale: 0 }; var ly = H0; Ri(); Rr(); var Gc = class extends _e { constructor(t) { let { texture: e, vertices: s, uvs: o, indices: i, topology: n, ...a } = t, l = new qt(me({ positions: s, uvs: o, indices: i, topology: n })); super(me({ ...a, texture: e, geometry: l })), this.autoUpdate = !0, this.onRender = this._render } get vertices () { return this.geometry.getBuffer("aPosition").data } set vertices (t) { this.geometry.getBuffer("aPosition").data = t } _render () { this.autoUpdate && this.geometry.getBuffer("aPosition").update() } }; c(Gc, "MeshSimple"); Kx(); zm(); Pa(); function uy (r, t) { let { width: e, height: s } = r.frame; return t.scale(1 / e, 1 / s), t } c(uy, "getTextureDefaultMatrix"); Rr(); gp(); ih(); rt(); lt(); It(); ih(); var W0 = c(class X0 extends N { constructor(t) { t instanceof E && (t = { texture: t }); let { width: e, height: s, leftWidth: o, rightWidth: i, topHeight: n, bottomHeight: a, texture: l, roundPixels: h, ...u } = t; super({ label: "NineSliceSprite", ...u }), this._roundPixels = 0, this.renderPipeId = "nineSliceSprite", this.batched = !0, this._didSpriteUpdate = !0, this.bounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 }, this._leftWidth = o ?? l?.defaultBorders?.left ?? Le.defaultOptions.leftWidth, this._topHeight = n ?? l?.defaultBorders?.top ?? Le.defaultOptions.topHeight, this._rightWidth = i ?? l?.defaultBorders?.right ?? Le.defaultOptions.rightWidth, this._bottomHeight = a ?? l?.defaultBorders?.bottom ?? Le.defaultOptions.bottomHeight, this.bounds.maxX = this._width = e ?? l.width ?? Le.defaultOptions.width, this.bounds.maxY = this._height = s ?? l.height ?? Le.defaultOptions.height, this.allowChildren = !1, this.texture = l ?? X0.defaultOptions.texture, this.roundPixels = h ?? !1 } get width () { return this._width } set width (t) { this.bounds.maxX = this._width = t, this.onViewUpdate() } get height () { return this._height } set height (t) { this.bounds.maxY = this._height = t, this.onViewUpdate() } get leftWidth () { return this._leftWidth } set leftWidth (t) { this._leftWidth = t, this.onViewUpdate() } get topHeight () { return this._topHeight } set topHeight (t) { this._topHeight = t, this.onViewUpdate() } get rightWidth () { return this._rightWidth } set rightWidth (t) { this._rightWidth = t, this.onViewUpdate() } get bottomHeight () { return this._bottomHeight } set bottomHeight (t) { this._bottomHeight = t, this.onViewUpdate() } get texture () { return this._texture } set texture (t) { t || (t = E.EMPTY); let e = this._texture; e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate()) } get roundPixels () { return !!this._roundPixels } set roundPixels (t) { this._roundPixels = t ? 1 : 0 } get originalWidth () { return this._texture.width } get originalHeight () { return this._texture.height } onViewUpdate () { this._didChangeId += 4096, this._didSpriteUpdate = !0, !this.didViewUpdate && (this.didViewUpdate = !0, this.renderGroup && this.renderGroup.onChildViewUpdate(this)) } addBounds (t) { let e = this.bounds; t.addFrame(e.minX, e.minY, e.maxX, e.maxY) } containsPoint (t) { let e = this.bounds; return t.x >= e.minX && t.x <= e.maxX && t.y >= e.minY && t.y <= e.maxY } destroy (t) { if (super.destroy(t), typeof t == "boolean" ? t : t?.texture) { let s = typeof t == "boolean" ? t : t?.textureSource; this._texture.destroy(s) } this._texture = null, this.bounds = null } }, "_NineSliceSprite"); W0.defaultOptions = { texture: E.EMPTY }; var o_ = W0, Uc = class extends o_ { constructor(...t) { let e = t[0]; e instanceof E && (w(G, "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}"), e = { texture: e, leftWidth: t[1], topHeight: t[2], rightWidth: t[3], bottomHeight: t[4] }), w(G, "NineSlicePlane is deprecated. Use NineSliceSprite instead."), super(e) } }; c(Uc, "NineSlicePlane"); Fm(); Cm(); Bm(); Um(); Rm(); Am(); wm(); Mm(); Ca(); zr(); rx(); uu(); kp(); Dp(); Lp(); Hp(); Op(); Ga(); pm(); Fp(); du(); hu(); mm(); Xu(); Ha(); Pm(); _m(); vm(); Sm(); Tm(); bm(); ym(); Em(); Zu(); gm(); Ji(); _p(); Up(); Ma(); lu(); fm(); hm(); dm(); as(); Ha(); as(); function hy (r, t) { return t instanceof Ht || t instanceof ue ? t : r === "html" ? new ue(t) : new Ht(t) } c(hy, "ensureTextStyle"); au(); cu(); Yf(); $f(); Eo(); Po(); If(); El(); Rf(); xm(); ph(); bp(); var K1 = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1), dy = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i; Yc(); Wt(); ga(); ap(); lt(); async function fy (r, t, e = 200) { let s = await t.extract.base64(r); await t.encoder.commandFinished; let o = e; console.log(`logging texture ${r.source.width}px ${r.source.height}px`); let i = ["font-size: 1px;", `padding: ${o}px 300px;`, `background: url(${s}) no-repeat;`, "background-size: contain;"].join(" "); console.log("%c ", i) } c(fy, "logDebugTexture"); zr(); var q1 = ["#000080", "#228B22", "#8B0000", "#4169E1", "#008080", "#800000", "#9400D3", "#FF8C00", "#556B2F", "#8B008B"], Z1 = 0; function i_ (r, t = 0, e = { color: "#000000" }) { r.isRenderGroupRoot && (e.color = q1[Z1++]); let s = ""; for (let n = 0; n < t; n++)s += "    "; let o = r.label; !o && r instanceof wt && (o = `sprite:${r.texture.label}`); let i = `%c ${s}|- ${o} (worldX:${r.worldTransform.tx}, relativeRenderX:${r.relativeGroupTransform.tx}, renderX:${r.groupTransform.tx}, localX:${r.x})`; r.isRenderGroupRoot && (i += " (RenderGroup)"), r.filters && (i += "(*filters)"), console.log(i, `color:${e.color}; font-weight:bold;`), t++; for (let n = 0; n < r.children.length; n++) { let a = r.children[n]; i_(a, t, { ...e }) } } c(i_, "logScene"); function n_ (r, t = 0, e = { index: 0, color: "#000000" }) { let s = ""; for (let i = 0; i < t; i++)s += "    "; let o = `%c ${s}- ${e.index}: ${r.root.label} worldX:${r.worldTransform.tx}`; console.log(o, `color:${e.color}; font-weight:bold;`), t++; for (let i = 0; i < r.renderGroupChildren.length; i++) { let n = r.renderGroupChildren[i]; n_(n, t, { ...e, index: i }) } } c(n_, "logRenderGroupScene"); ut(); zf(); Wr(); jc(); Jt(); _x(); db(); Gf(); Uf(); Ff(); Of(); Ke(); pe(); Xr(); Ei(); xl(); Nf(); fa(); $t(); gf(); ft(); Hf(); Df(); hl(); al(); ha(); Lf(); da(); cl(); ll(); ox(); ix(); nx(); ir(); aa(); Im(); Dm(); ax(); gl(); ot(); zc(); wi(); jl(); bo(); ce(); vp(); Sp(); Tp(); Gt(); Pp(); qx(); Bl(); va(); Ym(); Ml(); sx(); lp(); Ze(); sr(); cm(); rm(); om(); im(); nm(); am(); lm(); Oo(); ko(); um(); Lo(); or(); _h(); Kf(); lx(); qf(); ux(); Kc(); Zf(); hx(); _a(); ba(); Zx(); Qx(); Jx(); Wo(); tg(); sg(); rg(); og(); ig(); ng(); hg(); ag(); ug(); dg(); fg(); La(); pg(); xe(); mg(); Eg(); Bg(); xg(); ad(); Xh(); _g(); Sg(); zp(); Wp(); bg(); yg(); vg(); ld(); Vp(); Yp(); $p(); jp(); Kp(); sd(); lg(); cg(); Cg(); Pg(); wg(); Ag(); Jh(); Rg(); Hg(); Mg(); Gg(); Sd(); Ug(); Ig(); Og(); kg(); Dg(); Fg(); Lg(); Ng(); Sx(); Tx(); Mx(); Ex(); Px(); Cx(); Bx(); Rx(); Gx(); Ux(); Fx(); Ox(); kx(); Dx(); _r(); Pe(); Lx(); Oh(); wx(); qp(); Zp(); Ax(); Jp(); tm(); em(); Hx(); Nx(); zh(); Yx(); Wx(); Xx(); qh(); zx(); Vx(); $x(); dx(); fx(); xr(); Ja(); qe(); Al(); px(); xx(); wo(); Gl(); ip(); sn(); np(); Ul(); sl(); gx(); Ix(); Rh(); $h(); Qp(); Me(); Fh(); Ot(); Dh(); xp(); Hh(); kh(); bx(); Jr(); cp(); Se(); Mn(); Uh(); mh(); Yi(); mx(); bl(); Mi(); Ao(); Lt(); Pl(); rt(); yx(); yl(); br(); Vf(); Mh(); sp(); zi(); vx(); Re(); te(); Om(); vo(); ca(); km(); vi(); _f(); bf(); yf(); Ef(); Pf(); Cf(); Bf(); It(); $m(); Af(); jm(); ex(); wf(); Wa(); Tf(); Km(); Ri(); bh(); Zm(); qm(); up(); Jm(); tx(); jx(); Xi(); Xm(); Il(); Kl(); Bp(); Zl(); Ap(); wp(); Ol(); fp(); Nl(); Wl(); Xl(); hp(); Ba(); iu(); mu(); Fo(); Ea(); mp(); wa(); Rp(); Mp(); Gp(); yp(); pp(); nu(); dp(); Hl(); oh(); Kx(); zm(); Pa(); Rr(); gp(); ih(); Fm(); Cm(); Bm(); Um(); Rm(); Am(); wm(); Mm(); Ca(); zr(); rx(); uu(); kp(); Dp(); Lp(); Hp(); Op(); Ga(); pm(); Fp(); du(); hu(); mm(); Xu(); Ha(); Pm(); _m(); vm(); Sm(); Tm(); bm(); ym(); Em(); Zu(); gm(); Ji(); _p(); Up(); Ma(); lu(); fm(); hm(); dm(); as(); au(); cu(); Yf(); $f(); Eo(); Po(); If(); El(); Rf(); xm(); ph(); bp(); var z0 = Ct(Tt("/node_modules/eventemitter3?_v=5.0.1&_env=prod"), 1); Yc(); Wt(); ga(); ap(); lt(); ut(); zf(); Wr(); jc(); Jt(); _x(); var V0 = Ct(Tt("/node_modules/earcut?_v=2.2.4&_env=prod"), 1); I.add(Lm, Hm); return tS(Q1);
      })();
      ;
      return __dependency__;
    };</script>
  <script path="/node_modules/@pixi/spine-pixi?_v=1.0.8&_env=prod">window[Symbol.for('__modules__')] = window[Symbol.for('__modules__')] || {};
    window[Symbol.for('__modules__')]['/node_modules/@pixi/spine-pixi?_v=1.0.8&_env=prod'] = (window) => {
      var __dependency__ = (() => { var ne = Object.defineProperty; var fe = Object.getOwnPropertyDescriptor; var me = Object.getOwnPropertyNames; var xe = Object.prototype.hasOwnProperty; var g = (n, e) => ne(n, "name", { value: e, configurable: !0 }), B = (n => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(n, { get: (e, t) => (typeof require < "u" ? require : e)[t] }) : n)(function (n) { if (typeof require < "u") return require.apply(this, arguments); throw new Error('Dynamic require of "' + n + '" is not supported') }); var we = (n, e) => { for (var t in e) ne(n, t, { get: e[t], enumerable: !0 }) }, oe = (n, e, t, r) => { if (e && typeof e == "object" || typeof e == "function") for (let o of me(e)) !xe.call(n, o) && o !== t && ne(n, o, { get: () => e[o], enumerable: !(r = fe(e, o)) || r.enumerable }); return n }, Y = (n, e, t) => (oe(n, e, "default"), t && oe(t, e, "default")); var be = n => oe(ne({}, "__esModule", { value: !0 }), n); var E = {}; we(E, { Spine: () => I, SpineDebugRenderer: () => te, SpinePipe: () => G, SpineTexture: () => O }); if (typeof window < "u" && window.PIXI) { let n = window.require; window.require = e => { if (n) return n(e); if (e.startsWith("@pixi/") || e.startsWith("pixi.js")) return window.PIXI } } var S = B("/node_modules/pixi.js?_v=8.1.1&_env=prod"); var ae = B("/node_modules/pixi.js?_v=8.1.1&_env=prod"), w = B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod"); var Ce = Object.defineProperty, Se = g((n, e, t) => e in n ? Ce(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, "__defNormalProp"), le = g((n, e, t) => (Se(n, typeof e != "symbol" ? e + "" : e, t), t), "__publicField"), ce = g(class V extends w.Texture { constructor(e) { super(e.resource), le(this, "texture"), this.texture = ae.Texture.from(e) } static from (e) { return V.textureMap.has(e) ? V.textureMap.get(e) : new V(e) } setFilters (e, t) { let r = this.texture.source.style; r.minFilter = V.toPixiTextureFilter(e), r.magFilter = V.toPixiTextureFilter(t), this.texture.source.autoGenerateMipmaps = V.toPixiMipMap(e), this.texture.source.updateMipmaps() } setWraps (e, t) { let r = this.texture.source.style; r.addressModeU = V.toPixiTextureWrap(e), r.addressModeV = V.toPixiTextureWrap(t) } dispose () { this.texture.destroy() } static toPixiMipMap (e) { switch (e) { case w.TextureFilter.Nearest: case w.TextureFilter.Linear: return !1; case w.TextureFilter.MipMapNearestLinear: case w.TextureFilter.MipMapNearestNearest: case w.TextureFilter.MipMapLinearLinear: case w.TextureFilter.MipMapLinearNearest: return !0; default: throw new Error(`Unknown texture filter: ${String(e)}`) } } static toPixiTextureFilter (e) { switch (e) { case w.TextureFilter.Nearest: case w.TextureFilter.MipMapNearestLinear: case w.TextureFilter.MipMapNearestNearest: return "nearest"; case w.TextureFilter.Linear: case w.TextureFilter.MipMapLinearLinear: case w.TextureFilter.MipMapLinearNearest: return "linear"; default: throw new Error(`Unknown texture filter: ${String(e)}`) } } static toPixiTextureWrap (e) { switch (e) { case w.TextureWrap.ClampToEdge: return "clamp-to-edge"; case w.TextureWrap.MirroredRepeat: return "mirror-repeat"; case w.TextureWrap.Repeat: return "repeat"; default: throw new Error(`Unknown texture wrap: ${String(e)}`) } } static toPixiBlending (e) { switch (e) { case w.BlendMode.Normal: return "normal"; case w.BlendMode.Additive: return "add"; case w.BlendMode.Multiply: return "multiply"; case w.BlendMode.Screen: return "screen"; default: throw new Error(`Unknown blendMode: ${String(e)}`) } } }, "_SpineTexture"); le(ce, "textureMap", new Map); var O = ce; var he = B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod"), Pe = { extension: S.ExtensionType.Asset, loader: { extension: { type: S.ExtensionType.LoadParser, priority: S.LoaderParserPriority.Normal, name: "spineTextureAtlasLoader" }, test (n) { return (0, S.checkExtension)(n, ".atlas") }, async load (n) { return await (await S.DOMAdapter.get().fetch(n)).text() }, testParse (n, e) { let t = (0, S.checkExtension)(e.src, ".atlas"), r = typeof n == "string"; return Promise.resolve(t && r) }, unload (n) { n.dispose() }, async parse (n, e, t) { let r = e.data || {}, o = S.path.dirname(e.src); o && o.lastIndexOf("/") !== o.length - 1 && (o += "/"); let s = new he.TextureAtlas(n); if (r.images instanceof S.TextureSource || typeof r.images == "string") { let c = r.images; r.images = {}, r.images[s.pages[0].name] = c } let i = []; for (let c of s.pages) { let u = c.name, l = r?.images ? r.images[u] : void 0; if (l instanceof S.TextureSource) c.setTexture(O.from(l)); else { let h = l ?? S.path.normalize([...o.split(S.path.sep), u].join(S.path.sep)), d = t.load({ src: h, data: r.imageMetadata }).then(a => { c.setTexture(O.from(a.source)) }); i.push(d) } } return await Promise.all(i), s } } }; S.extensions.add(Pe); var M = B("/node_modules/pixi.js?_v=8.1.1&_env=prod"); function ve (n) { return Object.prototype.hasOwnProperty.call(n, "bones") } g(ve, "isJson"); function ye (n) { return n instanceof Uint8Array } g(ye, "isBuffer"); var Te = { extension: M.ExtensionType.Asset, loader: { extension: { type: M.ExtensionType.LoadParser, priority: M.LoaderParserPriority.Normal, name: "spineSkeletonLoader" }, test (n) { return (0, M.checkExtension)(n, ".skel") }, async load (n) { let e = await M.DOMAdapter.get().fetch(n); return new Uint8Array(await e.arrayBuffer()) }, testParse (n, e) { let t = (0, M.checkExtension)(e.src, ".json") && ve(n), r = (0, M.checkExtension)(e.src, ".skel") && ye(n); return Promise.resolve(t || r) } } }; M.extensions.add(Te); var k = B("/node_modules/pixi.js?_v=8.1.1&_env=prod"); var Ae = Object.defineProperty, Be = g((n, e, t) => e in n ? Ae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, "__defNormalProp"), L = g((n, e, t) => (Be(n, typeof e != "symbol" ? e + "" : e, t), t), "__publicField"), j = class { constructor() { L(this, "indexStart"), L(this, "textureId"), L(this, "texture"), L(this, "location"), L(this, "batcher"), L(this, "batch"), L(this, "renderable"), L(this, "slot"), L(this, "indexSize"), L(this, "vertexSize"), L(this, "clippedVertices", []), L(this, "clippedTriangles", []), L(this, "roundPixels") } get blendMode () { return this.renderable.groupBlendMode } reset () { this.renderable = null, this.texture = null, this.batcher = null, this.batch = null } setClipper (e) { de(e.clippedVertices, this.clippedVertices), de(e.clippedTriangles, this.clippedTriangles), this.vertexSize = e.clippedVertices.length / 8, this.indexSize = e.clippedTriangles.length } packIndex (e, t, r) { let o = this.clippedTriangles; for (let s = 0; s < o.length; s++)e[t++] = o[s] + r } packAttributes (e, t, r, o) { let s = this.clippedVertices, i = this.vertexSize, c = this.renderable.groupColor, u = o << 16 | this.roundPixels & 65535; for (let l = 0; l < i; l++) { let h = l * 8; e[r++] = s[h], e[r++] = s[h + 1] * -1, e[r++] = s[h + 6], e[r++] = s[h + 7], t[r++] = c, e[r++] = u } } }; g(j, "BatchableClippedSpineSlot"); function de (n, e) { for (let t = 0; t < n.length; t++)e[t] = n[t] } g(de, "copyArray"); var K = B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod"); var _e = Object.defineProperty, Me = g((n, e, t) => e in n ? _e(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, "__defNormalProp"), F = g((n, e, t) => (Me(n, typeof e != "symbol" ? e + "" : e, t), t), "__publicField"), Le = [0, 1, 2, 2, 3, 0], ee = class { constructor() { F(this, "indexStart"), F(this, "textureId"), F(this, "texture"), F(this, "location"), F(this, "batcher"), F(this, "batch"), F(this, "renderable"), F(this, "slot"), F(this, "indexSize"), F(this, "vertexSize"), F(this, "roundPixels") } get blendMode () { return this.renderable.groupBlendMode } reset () { this.renderable = null, this.texture = null, this.batcher = null, this.batch = null } setSlot (e) { this.slot = e; let t = e.getAttachment(); t instanceof K.RegionAttachment ? (this.vertexSize = 4, this.indexSize = 6) : t instanceof K.MeshAttachment && (this.vertexSize = t.worldVerticesLength / 2, this.indexSize = t.triangles.length) } packIndex (e, t, r) { let o = this.slot.getAttachment().triangles ?? Le; for (let s = 0; s < o.length; s++)e[t++] = o[s] + r } packAttributes (e, t, r, o) { let s = this.slot, i = s.getAttachment(); i instanceof K.MeshAttachment ? i.computeWorldVertices(s, 0, i.worldVerticesLength, e, r, 6) : i instanceof K.RegionAttachment && i.computeWorldVertices(s, e, r, 6); let c = this.vertexSize, u = this.renderable.groupColor, l = this.renderable.groupAlpha, h = s.color, d, a = h.a * l * 255; if (u !== 16777215) { let W = u >> 16 & 255, A = u >> 8 & 255, q = u & 255, H = h.r * q * 255, Q = h.g * A * 255, D = h.b * W * 255; d = a << 24 | D << 16 | Q << 8 | H } else d = a << 24 | h.b * 255 << 16 | h.g * 255 << 8 | h.r * 255; let C = i.uvs, p = this.renderable.groupTransform, f = p.a, x = p.b, m = p.c, T = p.d, _ = p.tx, X = p.ty, $ = o << 16 | this.roundPixels & 65535; for (let W = 0; W < c; W++) { let A = e[r], q = -e[r + 1]; e[r++] = f * A + m * q + _, e[r++] = x * A + T * q + X, e[r++] = C[W * 2], e[r++] = C[W * 2 + 1], t[r++] = d, t[r++] = $ } } }; g(ee, "BatchableSpineSlot"); var R = B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod"); var ke = Object.defineProperty, Ue = g((n, e, t) => e in n ? ke(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, "__defNormalProp"), ie = g((n, e, t) => (Ue(n, typeof e != "symbol" ? e + "" : e, t), t), "__publicField"), ue = [0, 1, 2, 2, 3, 0], se = new Float32Array(8), Re = new R.Color, Fe = new R.Color, G = class { constructor(e) { ie(this, "renderer"), ie(this, "activeBatchableSpineSlots", []), this.renderer = e, e.runners.prerender.add({ prerender: () => { this.buildStart() } }) } validateRenderable (e) { return !0 } buildStart () { this._returnActiveBatches() } addRenderable (e) { let t = this.renderer.renderPipes.batch, r = e.skeleton.getRootBone(); r.x = 0, r.y = 0, r.scaleX = 1, r.scaleY = 1, r.rotation = 0, e.state.apply(e.skeleton), e.skeleton.updateWorldTransform(); let o = e.skeleton.drawOrder, s = this.activeBatchableSpineSlots, i = new R.SkeletonClipping; for (let c = 0, u = o.length; c < u; c++) { let l = o[c], h = l.getAttachment(); if (h instanceof R.RegionAttachment || h instanceof R.MeshAttachment) if (i?.isClipping()) { if (h instanceof R.RegionAttachment) { let d = se; if (h.computeWorldVertices(l, d, 0, 2), i.clipTriangles(se, se.length, ue, ue.length, h.uvs, Re, Fe, !1), i.clippedVertices.length > 0) { let a = k.BigPool.get(j); s.push(a), a.texture = h.region?.texture.texture || k.Texture.WHITE, a.roundPixels = this.renderer._roundPixels | e._roundPixels, a.setClipper(i), a.renderable = e, t.addToBatch(a) } } } else { let d = k.BigPool.get(ee); s.push(d), d.renderable = e, d.setSlot(l), d.texture = h.region?.texture.texture || k.Texture.EMPTY, d.roundPixels = this.renderer._roundPixels | e._roundPixels, t.addToBatch(d) } else h instanceof R.ClippingAttachment ? i.clipStart(l, h) : i.clipEndWithSlot(l) } i.clipEnd() } updateRenderable (e) { } destroyRenderable (e) { this._returnActiveBatches() } destroy () { this._returnActiveBatches(), this.renderer = null } _returnActiveBatches () { let e = this.activeBatchableSpineSlots; for (let t = 0; t < e.length; t++)k.BigPool.return(e[t]); e.length = 0 } }; g(G, "SpinePipe"); ie(G, "extension", { type: [k.ExtensionType.WebGLPipes, k.ExtensionType.WebGPUPipes, k.ExtensionType.CanvasPipes], name: "spine" }); k.extensions.add(G); var y = B("/node_modules/pixi.js?_v=8.1.1&_env=prod"); var Z = B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod"); var Ee = new Float32Array(8), pe = []; function ge (n, e) { e.clear(); let t = n.getRootBone(); t.x = 0, t.y = 0, t.scaleX = 1, t.scaleY = -1, t.rotation = 0, n.updateWorldTransform(); let r = n.drawOrder; for (let o = 0, s = r.length; o < s; o++) { let i = r[o], c = i.getAttachment(); if (c instanceof Z.RegionAttachment) { let u = Ee; c.computeWorldVertices(i, u, 0, 2), e.addVertexData(u, 0, 8) } else c instanceof Z.MeshAttachment ? (c.computeWorldVertices(i, 0, c.worldVerticesLength, pe, 0, 2), e.addVertexData(pe, 0, c.worldVerticesLength)) : c instanceof Z.ClippingAttachment && console.warn("[Pixi Spine] ClippingAttachment bounds is not supported yet") } } g(ge, "getSkeletonBounds"); var P = B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod"); var Xe = Object.defineProperty, Ye = g((n, e, t) => e in n ? Xe(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, "__defNormalProp"), U = g((n, e, t) => (Ye(n, typeof e != "symbol" ? e + "" : e, t), t), "__publicField"), re = new P.Vector2, I = class extends y.Container { constructor(e) { e instanceof P.SkeletonData && (e = { skeletonData: e }), super(), U(this, "batched", !0), U(this, "buildId", 0), U(this, "renderPipeId", "spine"), U(this, "_didSpineUpdate", !1), U(this, "_boundsDirty", !0), U(this, "_roundPixels"), U(this, "_bounds", new y.Bounds), U(this, "skeleton"), U(this, "state"), U(this, "skeletonBounds"), U(this, "_debug"), U(this, "autoUpdateWarned", !1), U(this, "_autoUpdate", !0); let t = e instanceof P.SkeletonData ? e : e.skeletonData; this.skeleton = new P.Skeleton(t), this.state = new P.AnimationState(new P.AnimationStateData(t)), this.autoUpdate = e?.autoUpdate ?? !0 } get debug () { return this._debug } set debug (e) { this._debug && this._debug.unregisterSpine(this), e && e.registerSpine(this), this._debug = e } get autoUpdate () { return this._autoUpdate } set autoUpdate (e) { e ? (y.Ticker.shared.add(this.internalUpdate, this), this.autoUpdateWarned = !1) : y.Ticker.shared.remove(this.internalUpdate, this), this._autoUpdate = e } update (e) { this.autoUpdate && !this.autoUpdateWarned && (console.warn("You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want."), this.autoUpdateWarned = !0), this.internalUpdate(0, e) } internalUpdate (e, t) { this.updateState(t ?? y.Ticker.shared.deltaMS / 1e3) } get bounds () { return this._boundsDirty && this.updateBounds(), this._bounds } setBonePosition (e, t) { let r = e; if (typeof e == "string" && (e = this.skeleton.findBone(e)), !e) throw Error(`Cant set bone position, bone ${String(r)} not found`); if (re.set(t.x, t.y), e.parent) { let o = e.parent.worldToLocal(re); e.x = o.x, e.y = o.y } else e.x = re.x, e.y = re.y } getBonePosition (e, t) { let r = e; return typeof e == "string" && (e = this.skeleton.findBone(e)), e ? (t || (t = { x: 0, y: 0 }), t.x = e.worldX, t.y = e.worldY, t) : (console.error(`Cant set bone position! Bone ${String(r)} not found`), t) } updateState (e) { this.state.update(e), this._boundsDirty = !0, this.onViewUpdate() } onViewUpdate () { this._didChangeId += 4096, this._didSpineUpdate = !0, this._didSpineUpdate = !0, this._boundsDirty = !0, !this.didViewUpdate && (this.didViewUpdate = !0, this.renderGroup && this.renderGroup.onChildViewUpdate(this), this.debug?.renderDebug(this)) } updateBounds () { this._boundsDirty = !1, this.skeletonBounds || (this.skeletonBounds = new P.SkeletonBounds); let e = this.skeletonBounds; e.update(this.skeleton, !0), e.minX === 1 / 0 ? (this.state.apply(this.skeleton), ge(this.skeleton, this._bounds)) : (this._bounds.minX = e.minX, this._bounds.minY = e.minY, this._bounds.maxX = e.maxX, this._bounds.maxY = e.maxY) } addBounds (e) { e.addBounds(this.bounds) } containsPoint (e) { return !1 } destroy (e = !1) { super.destroy(e), y.Ticker.shared.remove(this.internalUpdate, this), this.state.clearListeners(), this.debug = void 0, this.skeleton = null, this.state = null } get roundPixels () { return !!this._roundPixels } set roundPixels (e) { this._roundPixels = e ? 1 : 0 } static from ({ skeleton: e, atlas: t, scale: r = 1 }) { let o = `${e}-${t}`; if (y.Cache.has(o)) return new I(y.Cache.get(o)); let s = y.Assets.get(e), i = y.Assets.get(t), c = new P.AtlasAttachmentLoader(i), u = s instanceof Uint8Array ? new P.SkeletonBinary(c) : new P.SkeletonJson(c); u.scale = r; let l = u.readSkeletonData(s); return y.Cache.set(o, l), new I({ skeletonData: l }) } }; g(I, "Spine"); var v = B("/node_modules/pixi.js?_v=8.1.1&_env=prod"), z = B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod"); var ze = Object.defineProperty, We = g((n, e, t) => e in n ? ze(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, "__defNormalProp"), b = g((n, e, t) => (We(n, typeof e != "symbol" ? e + "" : e, t), t), "__publicField"), te = class { constructor() { b(this, "registeredSpines", new Map), b(this, "drawMeshHull", !0), b(this, "drawMeshTriangles", !0), b(this, "drawBones", !0), b(this, "drawPaths", !0), b(this, "drawBoundingBoxes", !0), b(this, "drawClipping", !0), b(this, "drawRegionAttachments", !0), b(this, "drawEvents", !0), b(this, "lineWidth", 1), b(this, "regionAttachmentsColor", 30975), b(this, "meshHullColor", 30975), b(this, "meshTrianglesColor", 16763904), b(this, "clippingPolygonColor", 16711935), b(this, "boundingBoxesRectColor", 65280), b(this, "boundingBoxesPolygonColor", 65280), b(this, "boundingBoxesCircleColor", 65280), b(this, "pathsCurveColor", 16711680), b(this, "pathsLineColor", 16711935), b(this, "skeletonXYColor", 16711680), b(this, "bonesColor", 61132), b(this, "eventFontSize", 24), b(this, "eventFontColor", 0) } registerSpine (e) { if (this.registeredSpines.has(e)) { console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!", e); return } let t = { parentDebugContainer: new v.Container, bones: new v.Container, skeletonXY: new v.Graphics, regionAttachmentsShape: new v.Graphics, meshTrianglesLine: new v.Graphics, meshHullLine: new v.Graphics, clippingPolygon: new v.Graphics, boundingBoxesRect: new v.Graphics, boundingBoxesCircle: new v.Graphics, boundingBoxesPolygon: new v.Graphics, pathsCurve: new v.Graphics, pathsLine: new v.Graphics, eventText: new v.Container, eventCallback: { event: (r, o) => { if (this.drawEvents) { let s = Math.abs(e.scale.x || e.scale.y || 1), i = new v.Text({ text: o.data.name, style: { fontSize: this.eventFontSize / s, fill: this.eventFontColor, fontFamily: "monospace" } }); i.scale.x = Math.sign(e.scale.x), i.anchor.set(.5), t.eventText.addChild(i), setTimeout(() => { i.destroyed || i.destroy() }, 250) } } } }; t.parentDebugContainer.addChild(t.bones), t.parentDebugContainer.addChild(t.skeletonXY), t.parentDebugContainer.addChild(t.regionAttachmentsShape), t.parentDebugContainer.addChild(t.meshTrianglesLine), t.parentDebugContainer.addChild(t.meshHullLine), t.parentDebugContainer.addChild(t.clippingPolygon), t.parentDebugContainer.addChild(t.boundingBoxesRect), t.parentDebugContainer.addChild(t.boundingBoxesCircle), t.parentDebugContainer.addChild(t.boundingBoxesPolygon), t.parentDebugContainer.addChild(t.pathsCurve), t.parentDebugContainer.addChild(t.pathsLine), t.parentDebugContainer.addChild(t.eventText), t.parentDebugContainer.zIndex = 9999999, t.parentDebugContainer.accessibleChildren = !1, t.parentDebugContainer.eventMode = "none", t.parentDebugContainer.interactiveChildren = !1, e.addChild(t.parentDebugContainer), e.state.addListener(t.eventCallback), this.registeredSpines.set(e, t) } renderDebug (e) { this.registeredSpines.has(e) || this.registerSpine(e); let t = this.registeredSpines.get(e); if (!t) return; e.addChild(t.parentDebugContainer), t.skeletonXY.clear(), t.regionAttachmentsShape.clear(), t.meshTrianglesLine.clear(), t.meshHullLine.clear(), t.clippingPolygon.clear(), t.boundingBoxesRect.clear(), t.boundingBoxesCircle.clear(), t.boundingBoxesPolygon.clear(), t.pathsCurve.clear(), t.pathsLine.clear(); for (let s = t.bones.children.length; s > 0; s--)t.bones.children[s - 1].destroy({ children: !0, texture: !0, textureSource: !0 }); let r = Math.abs(e.scale.x || e.scale.y || 1), o = this.lineWidth / r; if (this.drawBones && this.drawBonesFunc(e, t, o, r), this.drawPaths && this.drawPathsFunc(e, t, o), this.drawBoundingBoxes && this.drawBoundingBoxesFunc(e, t, o), this.drawClipping && this.drawClippingFunc(e, t, o), (this.drawMeshHull || this.drawMeshTriangles) && this.drawMeshHullAndMeshTriangles(e, t, o), this.drawRegionAttachments && this.drawRegionAttachmentsFunc(e, t, o), this.drawEvents) for (let s of t.eventText.children) s.alpha -= .05, s.y -= 2 } drawBonesFunc (e, t, r, o) { let s = e.skeleton, i = s.x, c = s.y, u = s.bones; t.skeletonXY.strokeStyle = { width: r, color: this.skeletonXYColor }; for (let h = 0, d = u.length; h < d; h++) { let a = u[h], C = a.data.length, p = i + a.worldX, f = c + a.worldY, x = i + C * a.a + a.worldX, m = c + C * a.b + a.worldY; if (a.data.name === "root" || a.data.parent === null) continue; let T = Math.abs(p - x), _ = Math.abs(f - m), X = Math.pow(T, 2), $ = _, W = Math.pow(_, 2), A = Math.sqrt(X + W), q = Math.pow(A, 2), H = Math.PI / 180, Q = Math.acos((q + W - X) / (2 * $ * A)) || 0; if (A === 0) continue; let D = new v.Graphics; t.bones.addChild(D); let J = A / 50 / o; D.context.poly([0, 0, 0 - J, A - J * 3, 0, A - J, 0 + J, A - J * 3]).fill(this.bonesColor), D.x = p, D.y = f, D.pivot.y = A; let N = 0; p < x && f < m ? N = -Q + 180 * H : p > x && f < m ? N = 180 * (H + Q) : p > x && f > m ? N = -Q : p < x && f > m ? N = Q : f === m && p < x ? N = 90 * H : f === m && p > x ? N = -90 * H : p === x && f < m ? N = 180 * H : p === x && f > m && (N = 0), D.rotation = N, D.circle(0, A, J * 1.2).fill({ color: 0, alpha: .6 }).stroke({ width: r, color: this.skeletonXYColor }) } let l = r * 3; t.skeletonXY.context.moveTo(i - l, c - l).lineTo(i + l, c + l).moveTo(i + l, c - l).lineTo(i - l, c + l).stroke() } drawRegionAttachmentsFunc (e, t, r) { let s = e.skeleton.slots; for (let i = 0, c = s.length; i < c; i++) { let u = s[i], l = u.getAttachment(); if (l === null || !(l instanceof z.RegionAttachment)) continue; let h = l, d = new Float32Array(8); h.computeWorldVertices(u, d, 0, 2), t.regionAttachmentsShape.poly(Array.from(d.slice(0, 8))) } t.regionAttachmentsShape.stroke({ color: this.regionAttachmentsColor, width: r }) } drawMeshHullAndMeshTriangles (e, t, r) { let s = e.skeleton.slots; for (let i = 0, c = s.length; i < c; i++) { let u = s[i]; if (!u.bone.active) continue; let l = u.getAttachment(); if (l === null || !(l instanceof z.MeshAttachment)) continue; let h = l, d = new Float32Array(h.worldVerticesLength), a = h.triangles, C = h.hullLength; if (h.computeWorldVertices(u, 0, h.worldVerticesLength, d, 0, 2), this.drawMeshTriangles) for (let p = 0, f = a.length; p < f; p += 3) { let x = a[p] * 2, m = a[p + 1] * 2, T = a[p + 2] * 2; t.meshTrianglesLine.context.moveTo(d[x], d[x + 1]).lineTo(d[m], d[m + 1]).lineTo(d[T], d[T + 1]) } if (this.drawMeshHull && C > 0) { C = (C >> 1) * 2; let p = d[C - 2], f = d[C - 1]; for (let x = 0, m = C; x < m; x += 2) { let T = d[x], _ = d[x + 1]; t.meshHullLine.context.moveTo(T, _).lineTo(p, f), p = T, f = _ } } } t.meshHullLine.stroke({ width: r, color: this.meshHullColor }), t.meshTrianglesLine.stroke({ width: r, color: this.meshTrianglesColor }) } drawClippingFunc (e, t, r) { let s = e.skeleton.slots; for (let i = 0, c = s.length; i < c; i++) { let u = s[i]; if (!u.bone.active) continue; let l = u.getAttachment(); if (l === null || !(l instanceof z.ClippingAttachment)) continue; let h = l, d = h.worldVerticesLength, a = new Float32Array(d); h.computeWorldVertices(u, 0, d, a, 0, 2), t.clippingPolygon.poly(Array.from(a)) } t.clippingPolygon.stroke({ width: r, color: this.clippingPolygonColor, alpha: 1 }) } drawBoundingBoxesFunc (e, t, r) { t.boundingBoxesRect.lineStyle(r, this.boundingBoxesRectColor, 5); let o = new z.SkeletonBounds; o.update(e.skeleton, !0), t.boundingBoxesRect.rect(o.minX, o.minY, o.getWidth(), o.getHeight()).stroke({ width: r, color: this.boundingBoxesRectColor }); let s = o.polygons, i = g((c, u, l) => { if (l < 3) throw new Error("Polygon must contain at least 3 vertices"); let h = [], d = r * 2; for (let a = 0, C = c.length; a < C; a += 2) { let p = c[a], f = c[a + 1]; t.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor), t.boundingBoxesCircle.drawCircle(p, f, d), t.boundingBoxesCircle.fill(0), h.push(p, f) } t.boundingBoxesPolygon.poly(h).fill({ color: this.boundingBoxesPolygonColor, alpha: .1 }).stroke({ width: r, color: this.boundingBoxesPolygonColor }) }, "drawPolygon"); for (let c = 0, u = s.length; c < u; c++) { let l = s[c]; i(l, 0, l.length) } } drawPathsFunc (e, t, r) { let s = e.skeleton.slots; for (let i = 0, c = s.length; i < c; i++) { let u = s[i]; if (!u.bone.active) continue; let l = u.getAttachment(); if (l === null || !(l instanceof z.PathAttachment)) continue; let h = l, d = h.worldVerticesLength, a = new Float32Array(d); h.computeWorldVertices(u, 0, d, a, 0, 2); let C = a[2], p = a[3], f = 0, x = 0; if (h.closed) { let m = a[0], T = a[1], _ = a[d - 2], X = a[d - 1]; f = a[d - 4], x = a[d - 3], t.pathsCurve.moveTo(C, p), t.pathsCurve.bezierCurveTo(m, T, _, X, f, x), t.pathsLine.moveTo(C, p), t.pathsLine.lineTo(m, T), t.pathsLine.moveTo(f, x), t.pathsLine.lineTo(_, X) } d -= 4; for (let m = 4; m < d; m += 6) { let T = a[m], _ = a[m + 1], X = a[m + 2], $ = a[m + 3]; f = a[m + 4], x = a[m + 5], t.pathsCurve.moveTo(C, p), t.pathsCurve.bezierCurveTo(T, _, X, $, f, x), t.pathsLine.moveTo(C, p), t.pathsLine.lineTo(T, _), t.pathsLine.moveTo(f, x), t.pathsLine.lineTo(X, $), C = f, p = x } } t.pathsCurve.stroke({ width: r, color: this.pathsCurveColor }), t.pathsLine.stroke({ width: r, color: this.pathsLineColor }) } unregisterSpine (e) { this.registeredSpines.has(e) || console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!", e); let t = this.registeredSpines.get(e); t && (e.state.removeListener(t.eventCallback), t.parentDebugContainer.destroy({ textureSource: !0, children: !0, texture: !0 }), this.registeredSpines.delete(e)) } }; g(te, "SpineDebugRenderer"); Y(E, B("/node_modules/@esotericsoftware/spine-core?_v=4.1.51&_env=prod")); return be(E); })();
      ;
      return __dependency__;
    };</script>
  <script>var b = Object.defineProperty;
    var r = (i, e) => b(i, "name", {
      value: e,
      configurable: !0
    });
    var V = require("/node_modules/@pixi/spine-pixi?_v=1.0.8&_env=prod"),
      m = require("/node_modules/pixi.js?_v=8.1.1&_env=prod");
    var g = require("/node_modules/@pixi/spine-pixi?_v=1.0.8&_env=prod"),
      w = require("/node_modules/pixi.js?_v=8.1.1&_env=prod");
    console.log("Import Spine.js");
    var o = {
      idle: {
        name: "idle",
        loop: !0
      },
      walk: {
        name: "walk",
        loop: !0
      },
      run: {
        name: "run",
        loop: !0
      },
      jump: {
        name: "jump",
        timeScale: 1.5
      },
      hover: {
        name: "hoverboard",
        loop: !0
      },
      spawn: {
        name: "portal"
      }
    },
      p = class {
        constructor() {
          this.state = {
            walk: !1,
            run: !1,
            hover: !1,
            jump: !1
          }, this.view = new w.Container(), this.directionalView = new w.Container(), this.spine = g.Spine.from({
            skeleton: "spineSkeleton",
            atlas: "spineAtlas"
          }), this.directionalView.addChild(this.spine), this.view.addChild(this.directionalView), this.spine.state.data.defaultMix = .2;
        }
        spawn () {
          this.spine.state.setAnimation(0, o.spawn.name);
        }
        playAnimation ({
          name: e,
          loop: s = !1,
          timeScale: t = 1
        }) {
          if (this.currentAnimationName === e) return;
          let n = this.spine.state.setAnimation(0, e, s);
          n.timeScale = t;
        }
        update () {
          this.state.jump && this.playAnimation(o.jump), !this.isAnimationPlaying(o.jump) && (this.state.hover ? this.playAnimation(o.hover) : this.state.run ? this.playAnimation(o.run) : this.state.walk ? this.playAnimation(o.walk) : this.playAnimation(o.idle));
        }
        isSpawning () {
          return this.isAnimationPlaying(o.spawn);
        }
        isAnimationPlaying ({
          name: e
        }) {
          return this.currentAnimationName === e && !this.spine.state.getCurrent(0).isComplete();
        }
        get currentAnimationName () {
          return this.spine.state.getCurrent(0)?.animation.name;
        }
        get direction () {
          return this.directionalView.scale.x > 0 ? 1 : -1;
        }
        set direction (e) {
          this.directionalView.scale.x = e;
        }
      };
    r(p, "SpineBoy");
    var k = {
      Space: "space",
      KeyW: "up",
      ArrowUp: "up",
      KeyA: "left",
      ArrowLeft: "left",
      KeyS: "down",
      ArrowDown: "down",
      KeyD: "right",
      ArrowRight: "right"
    },
      l = class {
        constructor() {
          this.keys = {
            up: {
              pressed: !1,
              doubleTap: !1,
              timestamp: 0
            },
            left: {
              pressed: !1,
              doubleTap: !1,
              timestamp: 0
            },
            down: {
              pressed: !1,
              doubleTap: !1,
              timestamp: 0
            },
            right: {
              pressed: !1,
              doubleTap: !1,
              timestamp: 0
            },
            space: {
              pressed: !1,
              doubleTap: !1,
              timestamp: 0
            }
          }, window.addEventListener("keydown", e => this.keydownHandler(e)), window.addEventListener("keyup", e => this.keyupHandler(e));
        }
        keydownHandler (e) {
          let s = k[e.code];
          if (!s) return;
          let t = Date.now();
          this.keys[s].doubleTap = this.keys[s].doubleTap || t - this.keys[s].timestamp < 300, this.keys[s].pressed = !0;
        }
        keyupHandler (e) {
          let s = k[e.code];
          if (!s) return;
          let t = Date.now();
          this.keys[s].pressed = !1, this.keys[s].doubleTap ? this.keys[s].doubleTap = !1 : this.keys[s].timestamp = t;
        }
      };
    r(l, "Controller");
    var a = require("/node_modules/pixi.js?_v=8.1.1&_env=prod");
    var h = class {
      constructor(e, s) {
        this.view = new a.Container(), this.sky = a.Sprite.from("sky"), this.sky.anchor.set(0, 1), this.sky.width = e, this.sky.height = s;
        let t = a.Texture.from("background"),
          n = a.Texture.from("midground"),
          f = a.Texture.from("platform"),
          y = f.height,
          u = Math.min(y, s * .4),
          d = this.scale = u / y,
          c = {
            tileScale: {
              x: d,
              y: d
            },
            anchor: {
              x: 0,
              y: 1
            },
            applyAnchorToTexture: !0
          };
        this.background = new a.TilingSprite({
          texture: t,
          width: e,
          height: t.height * d,
          ...c
        }), this.midground = new a.TilingSprite({
          texture: n,
          width: e,
          height: n.height * d,
          ...c
        }), this.platform = new a.TilingSprite({
          texture: f,
          width: e,
          height: u,
          ...c
        }), this.floorHeight = u * .43, this.background.y = this.midground.y = -this.floorHeight, this.view.addChild(this.sky, this.background, this.midground, this.platform);
      }
      get positionX () {
        return this.platform.tilePosition.x;
      }
      set positionX (e) {
        this.background.tilePosition.x = e * .1, this.midground.tilePosition.x = e * .25, this.platform.tilePosition.x = e;
      }
    };
    r(h, "Scene");
    (async () => {
      let i = new m.Application();
      await i.init({
        background: "#000000",
        resizeTo: (window.screen.availWidth / 2, window.screen.availHeight / 2)
      }), document.body.appendChild(i.canvas), console.log("Step 1 - All imports Done"), await m.Assets.load([{
        alias: "spineSkeleton",
        src: "https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pro.skel"
      }, {
        alias: "spineAtlas",
        src: "https://raw.githubusercontent.com/pixijs/spine-v8/main/examples/assets/spineboy-pma.atlas"
      }, {
        alias: "sky",
        src: "https://pixijs.com/assets/tutorials/spineboy-adventure/sky.png"
      }, {
        alias: "background",
        src: "https://pixijs.com/assets/tutorials/spineboy-adventure/background.png"
      }, {
        alias: "midground",
        src: "https://pixijs.com/assets/tutorials/spineboy-adventure/midground.png"
      }, {
        alias: "platform",
        src: "https://pixijs.com/assets/tutorials/spineboy-adventure/platform.png"
      }]);
      let e = new l(),
        s = new h(i.screen.width, i.screen.height),
        t = new p();
      s.view.y = i.screen.height, t.view.x = i.screen.width / 2, t.view.y = i.screen.height - s.floorHeight, t.spine.scale.set(s.scale * .32), i.stage.addChild(s.view, t.view), t.spawn(), i.ticker.add(() => {
        if (t.isSpawning()) return;
        t.state.walk = e.keys.left.pressed || e.keys.right.pressed, t.state.run && t.state.walk ? t.state.run = !0 : t.state.run = e.keys.left.doubleTap || e.keys.right.doubleTap, t.state.hover = e.keys.down.pressed, e.keys.left.pressed ? t.direction = -1 : e.keys.right.pressed && (t.direction = 1), t.state.jump = e.keys.space.pressed, t.update();
        let n = 1.25;
        t.state.hover ? n = 7.5 : t.state.run && (n = 3.75), t.state.walk && (s.positionX -= n * s.scale * t.direction);
      });
    })();</script>
</body>

</html>L;RP+VhQQIop